import { PHPResponse as Le, LatestSupportedPHPVersion as me, FSHelpers as R, loadPHPRuntime as ge, __private__dont__use as q } from "@php-wasm/universal";
import * as E from "comlink";
import { jspi as Ke } from "wasm-feature-detect";
import { logger as v } from "@php-wasm/logger";
import { teeRequest as Ie, cloneRequest as De } from "@php-wasm/web-service-worker";
import { Semaphore as We, joinPaths as oe, basename as Re } from "@php-wasm/util";
import { journalFSEvents as be } from "@php-wasm/fs-journal";
function pt(s, e = void 0) {
  ce();
  const t = s instanceof Worker ? s : E.windowEndpoint(s, e), r = E.wrap(t), n = j(r);
  return new Proxy(n, {
    get: (i, a) => a === "isConnected" ? async () => {
      for (; ; )
        try {
          await Pe(r.isConnected(), 200);
          break;
        } catch {
        }
    } : r[a]
  });
}
async function Pe(s, e) {
  return new Promise((t, r) => {
    setTimeout(r, e), s.then(t);
  });
}
function wt(s, e) {
  ce();
  const t = Promise.resolve();
  let r, n;
  const i = new Promise((c, S) => {
    r = c, n = S;
  }), a = j(s), _ = new Proxy(a, {
    get: (c, S) => S === "isConnected" ? () => t : S === "isReady" ? () => i : S in c ? c[S] : e == null ? void 0 : e[S]
  });
  return E.expose(
    _,
    typeof window < "u" ? E.windowEndpoint(self.parent) : void 0
  ), [r, n, _];
}
let V = !1;
function ce() {
  if (V)
    return;
  V = !0, E.transferHandlers.set("EVENT", {
    canHandle: (t) => t instanceof CustomEvent,
    serialize: (t) => [
      {
        detail: t.detail
      },
      []
    ],
    deserialize: (t) => t
  }), E.transferHandlers.set("FUNCTION", {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
    canHandle: (t) => typeof t == "function",
    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
    serialize(t) {
      const { port1: r, port2: n } = new MessageChannel();
      return E.expose(t, r), [n, [n]];
    },
    deserialize(t) {
      return t.start(), E.wrap(t);
    }
  }), E.transferHandlers.set("PHPResponse", {
    canHandle: (t) => typeof t == "object" && t !== null && "headers" in t && "bytes" in t && "errors" in t && "exitCode" in t && "httpStatusCode" in t,
    serialize(t) {
      return [t.toRawData(), []];
    },
    deserialize(t) {
      return Le.fromRawData(t);
    }
  });
  const s = E.transferHandlers.get("throw"), e = s == null ? void 0 : s.serialize;
  s.serialize = ({ value: t }) => {
    const r = e({ value: t });
    return t.response && (r[0].value.response = t.response), t.source && (r[0].value.source = t.source), r;
  };
}
function j(s) {
  return new Proxy(s, {
    get(e, t) {
      switch (typeof e[t]) {
        case "function":
          return (...r) => e[t](...r);
        case "object":
          return e[t] === null ? e[t] : j(e[t]);
        case "undefined":
        case "number":
        case "string":
          return e[t];
        default:
          return E.proxy(e[t]);
      }
    }
  });
}
async function Be(s = me) {
  if (await Ke())
    switch (s) {
      case "8.4":
        return await import("./php/jspi/php_8_4.js");
      case "8.3":
        return await import("./php/jspi/php_8_3.js");
      case "8.2":
        return await import("./php/jspi/php_8_2.js");
      case "8.1":
        return await import("./php/jspi/php_8_1.js");
      case "8.0":
        return await import("./php/jspi/php_8_0.js");
      case "7.4":
        return await import("./php/jspi/php_7_4.js");
      case "7.3":
        return await import("./php/jspi/php_7_3.js");
      case "7.2":
        return await import("./php/jspi/php_7_2.js");
    }
  else
    switch (s) {
      case "8.4":
        return await import("./php/asyncify/php_8_4.js");
      case "8.3":
        return await import("./php/asyncify/php_8_3.js");
      case "8.2":
        return await import("./php/asyncify/php_8_2.js");
      case "8.1":
        return await import("./php/asyncify/php_8_1.js");
      case "8.0":
        return await import("./php/asyncify/php_8_0.js");
      case "7.4":
        return await import("./php/asyncify/php_7_4.js");
      case "7.3":
        return await import("./php/asyncify/php_7_3.js");
      case "7.2":
        return await import("./php/asyncify/php_7_2.js");
    }
  throw new Error(`Unsupported PHP version ${s}`);
}
function p(s) {
  return Object.fromEntries(Object.entries(s).map(([e, t]) => [t, e]));
}
function u(s) {
  let e = 0;
  s.forEach((n) => e += n.length);
  const t = new Uint8Array(e);
  let r = 0;
  return s.forEach((n) => {
    t.set(n, r), r += n.length;
  }), t;
}
function B(s) {
  return u(s.map((e) => new Uint8Array(e))).buffer;
}
function I(s) {
  return new Uint8Array([s >> 8 & 255, s & 255]);
}
function y(s) {
  return new Uint8Array([
    s >> 16 & 255,
    s >> 8 & 255,
    s & 255
  ]);
}
function Y(s) {
  const e = new ArrayBuffer(8);
  return new DataView(e).setBigUint64(0, BigInt(s), !1), new Uint8Array(e);
}
class m {
  constructor(e) {
    this.offset = 0, this.buffer = e, this.view = new DataView(e);
  }
  readUint8() {
    const e = this.view.getUint8(this.offset);
    return this.offset += 1, e;
  }
  readUint16() {
    const e = this.view.getUint16(this.offset);
    return this.offset += 2, e;
  }
  readUint32() {
    const e = this.view.getUint32(this.offset);
    return this.offset += 4, e;
  }
  readUint8Array(e) {
    const t = this.buffer.slice(this.offset, this.offset + e);
    return this.offset += e, new Uint8Array(t);
  }
  isFinished() {
    return this.offset >= this.buffer.byteLength;
  }
}
class M {
  constructor(e) {
    this.offset = 0, this.buffer = new ArrayBuffer(e), this.uint8Array = new Uint8Array(this.buffer), this.view = new DataView(this.buffer);
  }
  writeUint8(e) {
    this.view.setUint8(this.offset, e), this.offset += 1;
  }
  writeUint16(e) {
    this.view.setUint16(this.offset, e), this.offset += 2;
  }
  writeUint32(e) {
    this.view.setUint32(this.offset, e), this.offset += 4;
  }
  writeUint8Array(e) {
    this.uint8Array.set(e, this.offset), this.offset += e.length;
  }
}
const b = {
  server_name: 0,
  max_fragment_length: 1,
  client_certificate_url: 2,
  trusted_ca_keys: 3,
  truncated_hmac: 4,
  status_request: 5,
  user_mapping: 6,
  client_authz: 7,
  server_authz: 8,
  cert_type: 9,
  supported_groups: 10,
  ec_point_formats: 11,
  srp: 12,
  signature_algorithms: 13,
  use_srtp: 14,
  heartbeat: 15,
  application_layer_protocol_negotiation: 16,
  status_request_v2: 17,
  signed_certificate_timestamp: 18,
  client_certificate_type: 19,
  server_certificate_type: 20,
  padding: 21,
  encrypt_then_mac: 22,
  extended_master_secret: 23,
  token_binding: 24,
  cached_info: 25,
  tls_its: 26,
  compress_certificate: 27,
  record_size_limit: 28,
  pwd_protect: 29,
  pwo_clear: 30,
  password_salt: 31,
  ticket_pinning: 32,
  tls_cert_with_extern_psk: 33,
  delegated_credential: 34,
  session_ticket: 35,
  TLMSP: 36,
  TLMSP_proxying: 37,
  TLMSP_delegate: 38,
  supported_ekt_ciphers: 39,
  pre_shared_key: 41,
  early_data: 42,
  supported_versions: 43,
  cookie: 44,
  psk_key_exchange_modes: 45,
  reserved: 46,
  certificate_authorities: 47,
  oid_filters: 48,
  post_handshake_auth: 49,
  signature_algorithms_cert: 50,
  key_share: 51,
  transparency_info: 52,
  connection_id: 54
}, Ue = p(b), Se = {
  host_name: 0
}, ve = p(Se);
class Ce {
  static decodeFromClient(e) {
    const t = new DataView(e.buffer);
    let r = 0;
    const n = t.getUint16(r);
    r += 2;
    const i = [];
    for (; r < n + 2; ) {
      const a = e[r];
      r += 1;
      const _ = t.getUint16(r);
      r += 2;
      const c = e.slice(r, r + _);
      switch (r += _, a) {
        case Se.host_name:
          i.push({
            name_type: ve[a],
            name: {
              host_name: new TextDecoder().decode(c)
            }
          });
          break;
        default:
          throw new Error(`Unsupported name type ${a}`);
      }
    }
    return { server_name_list: i };
  }
  /**
   * Encode the server_name extension
   *
   * +------------------------------------+
   * | Extension Type (server_name) [2B]  |
   * | 0x00 0x00                          |
   * +------------------------------------+
   * | Extension Length             [2B]  |
   * | 0x00 0x00                          |
   * +------------------------------------+
   */
  static encodeForClient(e) {
    if (e != null && e.server_name_list.length)
      throw new Error(
        "Encoding non-empty lists for ClientHello is not supported yet. Only empty lists meant for ServerHello are supported today."
      );
    const t = new M(4);
    return t.writeUint16(b.server_name), t.writeUint16(0), t.uint8Array;
  }
}
const he = {
  TLS1_CK_PSK_WITH_RC4_128_SHA: 138,
  TLS1_CK_PSK_WITH_3DES_EDE_CBC_SHA: 139,
  TLS1_CK_PSK_WITH_AES_128_CBC_SHA: 140,
  TLS1_CK_PSK_WITH_AES_256_CBC_SHA: 141,
  TLS1_CK_DHE_PSK_WITH_RC4_128_SHA: 142,
  TLS1_CK_DHE_PSK_WITH_3DES_EDE_CBC_SHA: 143,
  TLS1_CK_DHE_PSK_WITH_AES_128_CBC_SHA: 144,
  TLS1_CK_DHE_PSK_WITH_AES_256_CBC_SHA: 145,
  TLS1_CK_RSA_PSK_WITH_RC4_128_SHA: 146,
  TLS1_CK_RSA_PSK_WITH_3DES_EDE_CBC_SHA: 147,
  TLS1_CK_RSA_PSK_WITH_AES_128_CBC_SHA: 148,
  TLS1_CK_RSA_PSK_WITH_AES_256_CBC_SHA: 149,
  TLS1_CK_PSK_WITH_AES_128_GCM_SHA256: 168,
  TLS1_CK_PSK_WITH_AES_256_GCM_SHA384: 169,
  TLS1_CK_DHE_PSK_WITH_AES_128_GCM_SHA256: 170,
  TLS1_CK_DHE_PSK_WITH_AES_256_GCM_SHA384: 171,
  TLS1_CK_RSA_PSK_WITH_AES_128_GCM_SHA256: 172,
  TLS1_CK_RSA_PSK_WITH_AES_256_GCM_SHA384: 173,
  TLS1_CK_PSK_WITH_AES_128_CBC_SHA256: 174,
  TLS1_CK_PSK_WITH_AES_256_CBC_SHA384: 175,
  TLS1_CK_PSK_WITH_NULL_SHA256: 176,
  TLS1_CK_PSK_WITH_NULL_SHA384: 177,
  TLS1_CK_DHE_PSK_WITH_AES_128_CBC_SHA256: 178,
  TLS1_CK_DHE_PSK_WITH_AES_256_CBC_SHA384: 179,
  TLS1_CK_DHE_PSK_WITH_NULL_SHA256: 180,
  TLS1_CK_DHE_PSK_WITH_NULL_SHA384: 181,
  TLS1_CK_RSA_PSK_WITH_AES_128_CBC_SHA256: 182,
  TLS1_CK_RSA_PSK_WITH_AES_256_CBC_SHA384: 183,
  TLS1_CK_RSA_PSK_WITH_NULL_SHA256: 184,
  TLS1_CK_RSA_PSK_WITH_NULL_SHA384: 185,
  TLS1_CK_PSK_WITH_NULL_SHA: 44,
  TLS1_CK_DHE_PSK_WITH_NULL_SHA: 45,
  TLS1_CK_RSA_PSK_WITH_NULL_SHA: 46,
  TLS1_CK_RSA_WITH_AES_128_SHA: 47,
  TLS1_CK_DH_DSS_WITH_AES_128_SHA: 48,
  TLS1_CK_DH_RSA_WITH_AES_128_SHA: 49,
  TLS1_CK_DHE_DSS_WITH_AES_128_SHA: 50,
  TLS1_CK_DHE_RSA_WITH_AES_128_SHA: 51,
  TLS1_CK_ADH_WITH_AES_128_SHA: 52,
  TLS1_CK_RSA_WITH_AES_256_SHA: 53,
  TLS1_CK_DH_DSS_WITH_AES_256_SHA: 54,
  TLS1_CK_DH_RSA_WITH_AES_256_SHA: 55,
  TLS1_CK_DHE_DSS_WITH_AES_256_SHA: 56,
  TLS1_CK_DHE_RSA_WITH_AES_256_SHA: 57,
  TLS1_CK_ADH_WITH_AES_256_SHA: 58,
  TLS1_CK_RSA_WITH_NULL_SHA256: 59,
  TLS1_CK_RSA_WITH_AES_128_SHA256: 60,
  TLS1_CK_RSA_WITH_AES_256_SHA256: 61,
  TLS1_CK_DH_DSS_WITH_AES_128_SHA256: 62,
  TLS1_CK_DH_RSA_WITH_AES_128_SHA256: 63,
  TLS1_CK_DHE_DSS_WITH_AES_128_SHA256: 64,
  TLS1_CK_RSA_WITH_CAMELLIA_128_CBC_SHA: 65,
  TLS1_CK_DH_DSS_WITH_CAMELLIA_128_CBC_SHA: 66,
  TLS1_CK_DH_RSA_WITH_CAMELLIA_128_CBC_SHA: 67,
  TLS1_CK_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA: 68,
  TLS1_CK_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: 69,
  TLS1_CK_ADH_WITH_CAMELLIA_128_CBC_SHA: 70,
  TLS1_CK_DHE_RSA_WITH_AES_128_SHA256: 103,
  TLS1_CK_DH_DSS_WITH_AES_256_SHA256: 104,
  TLS1_CK_DH_RSA_WITH_AES_256_SHA256: 105,
  TLS1_CK_DHE_DSS_WITH_AES_256_SHA256: 106,
  TLS1_CK_DHE_RSA_WITH_AES_256_SHA256: 107,
  TLS1_CK_ADH_WITH_AES_128_SHA256: 108,
  TLS1_CK_ADH_WITH_AES_256_SHA256: 109,
  TLS1_CK_RSA_WITH_CAMELLIA_256_CBC_SHA: 132,
  TLS1_CK_DH_DSS_WITH_CAMELLIA_256_CBC_SHA: 133,
  TLS1_CK_DH_RSA_WITH_CAMELLIA_256_CBC_SHA: 134,
  TLS1_CK_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA: 135,
  TLS1_CK_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: 136,
  TLS1_CK_ADH_WITH_CAMELLIA_256_CBC_SHA: 137,
  TLS1_CK_RSA_WITH_SEED_SHA: 150,
  TLS1_CK_DH_DSS_WITH_SEED_SHA: 151,
  TLS1_CK_DH_RSA_WITH_SEED_SHA: 152,
  TLS1_CK_DHE_DSS_WITH_SEED_SHA: 153,
  TLS1_CK_DHE_RSA_WITH_SEED_SHA: 154,
  TLS1_CK_ADH_WITH_SEED_SHA: 155,
  TLS1_CK_RSA_WITH_AES_128_GCM_SHA256: 156,
  TLS1_CK_RSA_WITH_AES_256_GCM_SHA384: 157,
  TLS1_CK_DHE_RSA_WITH_AES_128_GCM_SHA256: 158,
  TLS1_CK_DHE_RSA_WITH_AES_256_GCM_SHA384: 159,
  TLS1_CK_DH_RSA_WITH_AES_128_GCM_SHA256: 160,
  TLS1_CK_DH_RSA_WITH_AES_256_GCM_SHA384: 161,
  TLS1_CK_DHE_DSS_WITH_AES_128_GCM_SHA256: 162,
  TLS1_CK_DHE_DSS_WITH_AES_256_GCM_SHA384: 163,
  TLS1_CK_DH_DSS_WITH_AES_128_GCM_SHA256: 164,
  TLS1_CK_DH_DSS_WITH_AES_256_GCM_SHA384: 165,
  TLS1_CK_ADH_WITH_AES_128_GCM_SHA256: 166,
  TLS1_CK_ADH_WITH_AES_256_GCM_SHA384: 167,
  TLS1_CK_RSA_WITH_AES_128_CCM: 49308,
  TLS1_CK_RSA_WITH_AES_256_CCM: 49309,
  TLS1_CK_DHE_RSA_WITH_AES_128_CCM: 49310,
  TLS1_CK_DHE_RSA_WITH_AES_256_CCM: 49311,
  TLS1_CK_RSA_WITH_AES_128_CCM_8: 49312,
  TLS1_CK_RSA_WITH_AES_256_CCM_8: 49313,
  TLS1_CK_DHE_RSA_WITH_AES_128_CCM_8: 49314,
  TLS1_CK_DHE_RSA_WITH_AES_256_CCM_8: 49315,
  TLS1_CK_PSK_WITH_AES_128_CCM: 49316,
  TLS1_CK_PSK_WITH_AES_256_CCM: 49317,
  TLS1_CK_DHE_PSK_WITH_AES_128_CCM: 49318,
  TLS1_CK_DHE_PSK_WITH_AES_256_CCM: 49319,
  TLS1_CK_PSK_WITH_AES_128_CCM_8: 49320,
  TLS1_CK_PSK_WITH_AES_256_CCM_8: 49321,
  TLS1_CK_DHE_PSK_WITH_AES_128_CCM_8: 49322,
  TLS1_CK_DHE_PSK_WITH_AES_256_CCM_8: 49323,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CCM: 49324,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CCM: 49325,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CCM_8: 49326,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CCM_8: 49327,
  TLS1_CK_RSA_WITH_CAMELLIA_128_CBC_SHA256: 186,
  TLS1_CK_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256: 187,
  TLS1_CK_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256: 188,
  TLS1_CK_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256: 189,
  TLS1_CK_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: 190,
  TLS1_CK_ADH_WITH_CAMELLIA_128_CBC_SHA256: 191,
  TLS1_CK_RSA_WITH_CAMELLIA_256_CBC_SHA256: 192,
  TLS1_CK_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256: 193,
  TLS1_CK_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256: 194,
  TLS1_CK_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256: 195,
  TLS1_CK_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256: 196,
  TLS1_CK_ADH_WITH_CAMELLIA_256_CBC_SHA256: 197,
  TLS1_CK_ECDH_ECDSA_WITH_NULL_SHA: 49153,
  TLS1_CK_ECDH_ECDSA_WITH_RC4_128_SHA: 49154,
  TLS1_CK_ECDH_ECDSA_WITH_DES_192_CBC3_SHA: 49155,
  TLS1_CK_ECDH_ECDSA_WITH_AES_128_CBC_SHA: 49156,
  TLS1_CK_ECDH_ECDSA_WITH_AES_256_CBC_SHA: 49157,
  TLS1_CK_ECDHE_ECDSA_WITH_NULL_SHA: 49158,
  TLS1_CK_ECDHE_ECDSA_WITH_RC4_128_SHA: 49159,
  TLS1_CK_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA: 49160,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: 49161,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: 49162,
  TLS1_CK_ECDH_RSA_WITH_NULL_SHA: 49163,
  TLS1_CK_ECDH_RSA_WITH_RC4_128_SHA: 49164,
  TLS1_CK_ECDH_RSA_WITH_DES_192_CBC3_SHA: 49165,
  TLS1_CK_ECDH_RSA_WITH_AES_128_CBC_SHA: 49166,
  TLS1_CK_ECDH_RSA_WITH_AES_256_CBC_SHA: 49167,
  TLS1_CK_ECDHE_RSA_WITH_NULL_SHA: 49168,
  TLS1_CK_ECDHE_RSA_WITH_RC4_128_SHA: 49169,
  TLS1_CK_ECDHE_RSA_WITH_DES_192_CBC3_SHA: 49170,
  TLS1_CK_ECDHE_RSA_WITH_AES_128_CBC_SHA: 49171,
  TLS1_CK_ECDHE_RSA_WITH_AES_256_CBC_SHA: 49172,
  TLS1_CK_ECDH_anon_WITH_NULL_SHA: 49173,
  TLS1_CK_ECDH_anon_WITH_RC4_128_SHA: 49174,
  TLS1_CK_ECDH_anon_WITH_DES_192_CBC3_SHA: 49175,
  TLS1_CK_ECDH_anon_WITH_AES_128_CBC_SHA: 49176,
  TLS1_CK_ECDH_anon_WITH_AES_256_CBC_SHA: 49177,
  TLS1_CK_SRP_SHA_WITH_3DES_EDE_CBC_SHA: 49178,
  TLS1_CK_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA: 49179,
  TLS1_CK_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA: 49180,
  TLS1_CK_SRP_SHA_WITH_AES_128_CBC_SHA: 49181,
  TLS1_CK_SRP_SHA_RSA_WITH_AES_128_CBC_SHA: 49182,
  TLS1_CK_SRP_SHA_DSS_WITH_AES_128_CBC_SHA: 49183,
  TLS1_CK_SRP_SHA_WITH_AES_256_CBC_SHA: 49184,
  TLS1_CK_SRP_SHA_RSA_WITH_AES_256_CBC_SHA: 49185,
  TLS1_CK_SRP_SHA_DSS_WITH_AES_256_CBC_SHA: 49186,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_128_SHA256: 49187,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_256_SHA384: 49188,
  TLS1_CK_ECDH_ECDSA_WITH_AES_128_SHA256: 49189,
  TLS1_CK_ECDH_ECDSA_WITH_AES_256_SHA384: 49190,
  TLS1_CK_ECDHE_RSA_WITH_AES_128_SHA256: 49191,
  TLS1_CK_ECDHE_RSA_WITH_AES_256_SHA384: 49192,
  TLS1_CK_ECDH_RSA_WITH_AES_128_SHA256: 49193,
  TLS1_CK_ECDH_RSA_WITH_AES_256_SHA384: 49194,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: 49195,
  TLS1_CK_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: 49196,
  TLS1_CK_ECDH_ECDSA_WITH_AES_128_GCM_SHA256: 49197,
  TLS1_CK_ECDH_ECDSA_WITH_AES_256_GCM_SHA384: 49198,
  TLS1_CK_ECDHE_RSA_WITH_AES_128_GCM_SHA256: 49199,
  TLS1_CK_ECDHE_RSA_WITH_AES_256_GCM_SHA384: 49200,
  TLS1_CK_ECDH_RSA_WITH_AES_128_GCM_SHA256: 49201,
  TLS1_CK_ECDH_RSA_WITH_AES_256_GCM_SHA384: 49202,
  TLS1_CK_ECDHE_PSK_WITH_RC4_128_SHA: 49203,
  TLS1_CK_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA: 49204,
  TLS1_CK_ECDHE_PSK_WITH_AES_128_CBC_SHA: 49205,
  TLS1_CK_ECDHE_PSK_WITH_AES_256_CBC_SHA: 49206,
  TLS1_CK_ECDHE_PSK_WITH_AES_128_CBC_SHA256: 49207,
  TLS1_CK_ECDHE_PSK_WITH_AES_256_CBC_SHA384: 49208,
  TLS1_CK_ECDHE_PSK_WITH_NULL_SHA: 49209,
  TLS1_CK_ECDHE_PSK_WITH_NULL_SHA256: 49210,
  TLS1_CK_ECDHE_PSK_WITH_NULL_SHA384: 49211,
  TLS1_CK_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: 49266,
  TLS1_CK_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: 49267,
  TLS1_CK_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: 49268,
  TLS1_CK_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: 49269,
  TLS1_CK_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: 49270,
  TLS1_CK_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384: 49271,
  TLS1_CK_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256: 49272,
  TLS1_CK_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384: 49273,
  TLS1_CK_PSK_WITH_CAMELLIA_128_CBC_SHA256: 49300,
  TLS1_CK_PSK_WITH_CAMELLIA_256_CBC_SHA384: 49301,
  TLS1_CK_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: 49302,
  TLS1_CK_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: 49303,
  TLS1_CK_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256: 49304,
  TLS1_CK_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384: 49305,
  TLS1_CK_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: 49306,
  TLS1_CK_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: 49307,
  TLS1_CK_ECDHE_RSA_WITH_CHACHA20_POLY1305: 52392,
  TLS1_CK_ECDHE_ECDSA_WITH_CHACHA20_POLY1305: 52393,
  TLS1_CK_DHE_RSA_WITH_CHACHA20_POLY1305: 52394,
  TLS1_CK_PSK_WITH_CHACHA20_POLY1305: 52395,
  TLS1_CK_ECDHE_PSK_WITH_CHACHA20_POLY1305: 52396,
  TLS1_CK_DHE_PSK_WITH_CHACHA20_POLY1305: 52397,
  TLS1_CK_RSA_PSK_WITH_CHACHA20_POLY1305: 52398
}, Z = p(he), le = {
  secp256r1: 23,
  secp384r1: 24,
  secp521r1: 25,
  x25519: 29,
  x448: 30
}, J = p(le);
class Me {
  /**
   * +--------------------------------------------------+
   * | Payload Length                            [2B]   |
   * +--------------------------------------------------+
   * | Supported Groups List Length              [2B]   |
   * +--------------------------------------------------+
   * | Supported Group 1                         [2B]   |
   * +--------------------------------------------------+
   * | Supported Group 2                         [2B]   |
   * +--------------------------------------------------+
   * | ...                                              |
   * +--------------------------------------------------+
   * | Supported Group n                         [2B]   |
   * +--------------------------------------------------+
   */
  static decodeFromClient(e) {
    const t = new m(e.buffer);
    t.readUint16();
    const r = [];
    for (; !t.isFinished(); ) {
      const n = t.readUint16();
      n in J && r.push(J[n]);
    }
    return r;
  }
  /**
   * +--------------------------------------------------+
   * | Extension Type (supported_groups)         [2B]   |
   * | 0x00 0x0A                                        |
   * +--------------------------------------------------+
   * | Extension Length                          [2B]   |
   * +--------------------------------------------------+
   * | Selected Group                            [2B]   |
   * +--------------------------------------------------+
   */
  static encodeForClient(e) {
    const t = new M(6);
    return t.writeUint16(b.supported_groups), t.writeUint16(2), t.writeUint16(le[e]), t.uint8Array;
  }
}
const Ae = {
  uncompressed: 0,
  ansiX962_compressed_prime: 1,
  ansiX962_compressed_char2: 2
}, X = p(Ae);
class Ne {
  /**
   * +--------------------------------------------------+
   * | Payload Length                            [2B]   |
   * +--------------------------------------------------+
   * | EC Point Formats Length                   [1B]   |
   * +--------------------------------------------------+
   * | EC Point Format 1                         [1B]   |
   * +--------------------------------------------------+
   * | EC Point Format 2                         [1B]   |
   * +--------------------------------------------------+
   * | ...                                              |
   * +--------------------------------------------------+
   * | EC Point Format n                         [1B]   |
   * +--------------------------------------------------+
   */
  static decodeFromClient(e) {
    const t = new m(e.buffer), r = t.readUint8(), n = [];
    for (let i = 0; i < r; i++) {
      const a = t.readUint8();
      a in X && n.push(X[a]);
    }
    return n;
  }
  /**
   * Encode the ec_point_formats extension
   *
   * +--------------------------------------------------+
   * | Extension Type (ec_point_formats)         [2B]   |
   * | 0x00 0x0B                                        |
   * +--------------------------------------------------+
   * | Body Length                               [2B]   |
   * +--------------------------------------------------+
   * | EC Point Format Length                    [1B]   |
   * +--------------------------------------------------+
   * | EC Point Format                           [1B]   |
   * +--------------------------------------------------+
   */
  static encodeForClient(e) {
    const t = new M(6);
    return t.writeUint16(b.ec_point_formats), t.writeUint16(2), t.writeUint8(1), t.writeUint8(Ae[e]), t.uint8Array;
  }
}
const G = {
  anonymous: 0,
  rsa: 1,
  dsa: 2,
  ecdsa: 3
}, Q = p(G), $ = {
  none: 0,
  md5: 1,
  sha1: 2,
  sha224: 3,
  sha256: 4,
  sha384: 5,
  sha512: 6
}, ee = p($);
class xe {
  /**
   * Binary layout:
   *
   * +------------------------------------+
   * | Payload Length              [2B]   |
   * +------------------------------------+
   * | Hash Algorithm 1            [1B]   |
   * | Signature Algorithm 1       [1B]   |
   * +------------------------------------+
   * | Hash Algorithm 2            [1B]   |
   * | Signature Algorithm 2       [1B]   |
   * +------------------------------------+
   * | ...                                |
   * +------------------------------------+
   */
  static decodeFromClient(e) {
    const t = new m(e.buffer);
    t.readUint16();
    const r = [];
    for (; !t.isFinished(); ) {
      const n = t.readUint8(), i = t.readUint8();
      if (Q[i]) {
        if (!ee[n]) {
          v.warn(`Unknown hash algorithm: ${n}`);
          continue;
        }
        r.push({
          algorithm: Q[i],
          hash: ee[n]
        });
      }
    }
    return r;
  }
  /**
   * +--------------------------------------------------+
   * | Extension Type (signature_algorithms)     [2B]   |
   * | 0x00 0x0D                                        |
   * +--------------------------------------------------+
   * | Body Length                               [2B]   |
   * +--------------------------------------------------+
   * | Hash Algorithm                            [1B]   |
   * | Signature Algorithm                       [1B]   |
   * +--------------------------------------------------+
   */
  static encodeforClient(e, t) {
    const r = new M(6);
    return r.writeUint16(b.signature_algorithms), r.writeUint16(2), r.writeUint8($[e]), r.writeUint8(G[t]), r.uint8Array;
  }
}
const te = {
  server_name: Ce,
  signature_algorithms: xe,
  supported_groups: Me,
  ec_point_formats: Ne
};
function ke(s) {
  const e = new m(s.buffer), t = [];
  for (; !e.isFinished(); ) {
    const r = e.offset, n = e.readUint16(), i = Ue[n], a = e.readUint16(), _ = e.readUint8Array(a);
    if (!(i in te))
      continue;
    const c = te[i];
    t.push({
      type: i,
      data: c.decodeFromClient(_),
      raw: s.slice(r, r + 4 + a)
    });
  }
  return t;
}
async function O(s, e, t, r) {
  const n = B([e, t]), i = await crypto.subtle.importKey(
    "raw",
    s,
    { name: "HMAC", hash: { name: "SHA-256" } },
    !1,
    ["sign"]
  );
  let a = n;
  const _ = [];
  for (; B(_).byteLength < r; ) {
    a = await re(i, a);
    const S = B([a, n]), h = await re(i, S);
    _.push(h);
  }
  return B(_).slice(0, r);
}
async function re(s, e) {
  return await crypto.subtle.sign(
    { name: "HMAC", hash: "SHA-256" },
    s,
    e
  );
}
const qe = {
  Null: 0
}, Oe = {
  Warning: 1,
  Fatal: 2
}, ue = p(Oe), Fe = {
  CloseNotify: 0,
  UnexpectedMessage: 10,
  BadRecordMac: 20,
  DecryptionFailed: 21,
  RecordOverflow: 22,
  DecompressionFailure: 30,
  HandshakeFailure: 40,
  NoCertificate: 41,
  BadCertificate: 42,
  UnsupportedCertificate: 43,
  CertificateRevoked: 44,
  CertificateExpired: 45,
  CertificateUnknown: 46,
  IllegalParameter: 47,
  UnknownCa: 48,
  AccessDenied: 49,
  DecodeError: 50,
  DecryptError: 51,
  ExportRestriction: 60,
  ProtocolVersion: 70,
  InsufficientSecurity: 71,
  InternalError: 80,
  UserCanceled: 90,
  NoRenegotiation: 100,
  UnsupportedExtension: 110
}, He = p(Fe), C = {
  ChangeCipherSpec: 20,
  Alert: 21,
  Handshake: 22,
  ApplicationData: 23
}, d = {
  HelloRequest: 0,
  ClientHello: 1,
  ServerHello: 2,
  Certificate: 11,
  ServerKeyExchange: 12,
  ServerHelloDone: 14,
  ClientKeyExchange: 16,
  Finished: 20
}, je = {
  /**
   * Indicates that a named curve is used.  This option
   * SHOULD be used when applicable.
   */
  NamedCurve: 3
  /**
   * Values 248 through 255 are reserved for private use.
   */
}, Ge = {
  secp256r1: 23
};
class ne extends Error {
}
const U = new Uint8Array([3, 3]), $e = crypto.subtle.generateKey(
  {
    name: "ECDH",
    namedCurve: "P-256"
    // Use secp256r1 curve
  },
  !0,
  // Extractable
  ["deriveKey", "deriveBits"]
  // Key usage
);
class ze {
  constructor() {
    this.receivedRecordSequenceNumber = 0, this.sentRecordSequenceNumber = 0, this.closed = !1, this.receivedBytesBuffer = new Uint8Array(), this.receivedTLSRecords = [], this.partialTLSMessages = {}, this.handshakeMessages = [], this.MAX_CHUNK_SIZE = 1024 * 16, this.clientEnd = {
      // We don't need to chunk the encrypted data.
      // OpenSSL already done that for us.
      upstream: new TransformStream(),
      downstream: new TransformStream()
    }, this.clientDownstreamWriter = this.clientEnd.downstream.writable.getWriter(), this.clientUpstreamReader = this.clientEnd.upstream.readable.getReader(), this.serverEnd = {
      upstream: new TransformStream(),
      /**
       * Chunk the data before encrypting it. The
       * TLS1_CK_ECDHE_RSA_WITH_AES_128_GCM_SHA256 cipher suite
       * only supports up to 16KB of data per record.
       *
       * This will spread some messages across multiple records,
       * but TLS supports it so that's fine.
       */
      downstream: Ve(this.MAX_CHUNK_SIZE)
    }, this.serverUpstreamWriter = this.serverEnd.upstream.writable.getWriter();
    const e = this;
    this.serverEnd.downstream.readable.pipeTo(
      new WritableStream({
        async write(t) {
          await e.writeTLSRecord(
            C.ApplicationData,
            t
          );
        },
        async abort(t) {
          e.clientDownstreamWriter.releaseLock(), e.clientEnd.downstream.writable.abort(t), e.close();
        },
        close() {
          e.close();
        }
      })
    ).catch(() => {
    });
  }
  /**
   * Marks this connections as closed and closes all the associated
   * streams.
   */
  async close() {
    if (!this.closed) {
      this.closed = !0;
      try {
        await this.clientDownstreamWriter.close();
      } catch {
      }
      try {
        await this.clientUpstreamReader.cancel();
      } catch {
      }
      try {
        await this.serverUpstreamWriter.close();
      } catch {
      }
      try {
        await this.clientEnd.upstream.readable.cancel();
      } catch {
      }
      try {
        await this.clientEnd.downstream.writable.close();
      } catch {
      }
    }
  }
  /**
   * TLS handshake as per RFC 5246.
   *
   * https://datatracker.ietf.org/doc/html/rfc5246#section-7.4
   */
  async TLSHandshake(e, t) {
    const r = await this.readNextHandshakeMessage(
      d.ClientHello
    );
    if (!r.body.cipher_suites.length)
      throw new Error(
        "Client did not propose any supported cipher suites."
      );
    const n = crypto.getRandomValues(new Uint8Array(32));
    await this.writeTLSRecord(
      C.Handshake,
      K.serverHello(
        r.body,
        n,
        qe.Null
      )
    ), await this.writeTLSRecord(
      C.Handshake,
      K.certificate(t)
    );
    const i = await $e, a = r.body.random, _ = await K.ECDHEServerKeyExchange(
      a,
      n,
      i,
      e
    );
    await this.writeTLSRecord(C.Handshake, _), await this.writeTLSRecord(
      C.Handshake,
      K.serverHelloDone()
    );
    const c = await this.readNextHandshakeMessage(
      d.ClientKeyExchange
    );
    await this.readNextMessage(C.ChangeCipherSpec), this.sessionKeys = await this.deriveSessionKeys({
      clientRandom: a,
      serverRandom: n,
      serverPrivateKey: i.privateKey,
      clientPublicKey: await crypto.subtle.importKey(
        "raw",
        c.body.exchange_keys,
        { name: "ECDH", namedCurve: "P-256" },
        !1,
        []
      )
    }), await this.readNextHandshakeMessage(d.Finished), await this.writeTLSRecord(
      C.ChangeCipherSpec,
      K.changeCipherSpec()
    ), await this.writeTLSRecord(
      C.Handshake,
      await K.createFinishedMessage(
        this.handshakeMessages,
        this.sessionKeys.masterSecret
      )
    ), this.handshakeMessages = [], this.pollForClientMessages();
  }
  /**
   * Derives the session keys from the random values and the
   * pre-master secret – as per RFC 5246.
   */
  async deriveSessionKeys({
    clientRandom: e,
    serverRandom: t,
    serverPrivateKey: r,
    clientPublicKey: n
  }) {
    const i = await crypto.subtle.deriveBits(
      {
        name: "ECDH",
        public: n
      },
      r,
      256
      // Length of the derived secret (256 bits for P-256)
    ), a = new Uint8Array(
      await O(
        i,
        new TextEncoder().encode("master secret"),
        u([e, t]),
        48
      )
    ), _ = await O(
      a,
      new TextEncoder().encode("key expansion"),
      u([t, e]),
      // Client key, server key, client IV, server IV
      40
    ), c = new m(_), S = c.readUint8Array(16), h = c.readUint8Array(16), l = c.readUint8Array(4), A = c.readUint8Array(4);
    return {
      masterSecret: a,
      clientWriteKey: await crypto.subtle.importKey(
        "raw",
        S,
        { name: "AES-GCM" },
        !1,
        ["encrypt", "decrypt"]
      ),
      serverWriteKey: await crypto.subtle.importKey(
        "raw",
        h,
        { name: "AES-GCM" },
        !1,
        ["encrypt", "decrypt"]
      ),
      clientIV: l,
      serverIV: A
    };
  }
  async readNextHandshakeMessage(e) {
    const t = await this.readNextMessage(C.Handshake);
    if (t.msg_type !== e)
      throw new Error(`Expected ${e} message`);
    return t;
  }
  async readNextMessage(e) {
    let t, r = !1;
    do
      t = await this.readNextTLSRecord(e), r = await this.accumulateUntilMessageIsComplete(
        t
      );
    while (r === !1);
    const n = T.TLSMessage(
      t.type,
      r
    );
    return t.type === C.Handshake && this.handshakeMessages.push(t.fragment), n;
  }
  async readNextTLSRecord(e) {
    for (; ; ) {
      for (let _ = 0; _ < this.receivedTLSRecords.length; _++) {
        const c = this.receivedTLSRecords[_];
        if (c.type === e)
          return this.receivedTLSRecords.splice(_, 1), c;
      }
      const t = await this.pollBytes(5), r = t[3] << 8 | t[4], n = t[0], i = await this.pollBytes(r), a = {
        type: n,
        version: {
          major: t[1],
          minor: t[2]
        },
        length: r,
        fragment: this.sessionKeys && n !== C.ChangeCipherSpec ? await this.decryptData(n, i) : i
      };
      if (a.type === C.Alert) {
        const _ = ue[a.fragment[0]], c = He[a.fragment[1]];
        throw new Error(
          `TLS non-warning alert received: ${_} ${c}`
        );
      }
      this.receivedTLSRecords.push(a);
    }
  }
  /**
   * Returns the requested number of bytes from the client.
   * Waits for the bytes to arrive if necessary.
   */
  async pollBytes(e) {
    for (; this.receivedBytesBuffer.length < e; ) {
      const { value: r, done: n } = await this.clientUpstreamReader.read();
      if (n)
        throw await this.close(), new ne("TLS connection closed");
      if (this.receivedBytesBuffer = u([
        this.receivedBytesBuffer,
        r
      ]), this.receivedBytesBuffer.length >= e)
        break;
      await new Promise((i) => setTimeout(i, 100));
    }
    const t = this.receivedBytesBuffer.slice(0, e);
    return this.receivedBytesBuffer = this.receivedBytesBuffer.slice(e), t;
  }
  /**
   * Listens for all incoming messages and passes them to the
   * server handler.
   */
  async pollForClientMessages() {
    try {
      for (; ; ) {
        const e = await this.readNextMessage(
          C.ApplicationData
        );
        this.serverUpstreamWriter.write(e.body);
      }
    } catch (e) {
      if (e instanceof ne)
        return;
      throw e;
    }
  }
  /**
   * Decrypts data in a TLS 1.2-compliant manner using
   * the AES-GCM algorithm.
   */
  async decryptData(e, t) {
    const r = this.sessionKeys.clientIV, n = t.slice(0, 8), i = new Uint8Array([...r, ...n]), a = await crypto.subtle.decrypt(
      {
        name: "AES-GCM",
        iv: i,
        additionalData: new Uint8Array([
          ...Y(this.receivedRecordSequenceNumber),
          e,
          ...U,
          // Payload length without IV and tag
          ...I(t.length - 8 - 16)
        ]),
        tagLength: 128
      },
      this.sessionKeys.clientWriteKey,
      // Payload without the explicit IV
      t.slice(8)
    );
    return ++this.receivedRecordSequenceNumber, new Uint8Array(a);
  }
  async accumulateUntilMessageIsComplete(e) {
    this.partialTLSMessages[e.type] = u([
      this.partialTLSMessages[e.type] || new Uint8Array(),
      e.fragment
    ]);
    const t = this.partialTLSMessages[e.type];
    switch (e.type) {
      case C.Handshake: {
        if (t.length < 4)
          return !1;
        const r = t[1] << 8 | t[2];
        if (t.length < 3 + r)
          return !1;
        break;
      }
      case C.Alert: {
        if (t.length < 2)
          return !1;
        break;
      }
      case C.ChangeCipherSpec:
      case C.ApplicationData:
        break;
      default:
        throw new Error(`TLS: Unsupported record type ${e.type}`);
    }
    return delete this.partialTLSMessages[e.type], t;
  }
  /**
   * Passes a TLS record to the client.
   *
   * Accepts unencrypted data and ensures it gets encrypted
   * if needed before sending it to the client. The encryption
   * only kicks in after the handshake is complete.
   */
  async writeTLSRecord(e, t) {
    e === C.Handshake && this.handshakeMessages.push(t), this.sessionKeys && e !== C.ChangeCipherSpec && (t = await this.encryptData(e, t));
    const r = U, n = t.length, i = new Uint8Array(5);
    i[0] = e, i[1] = r[0], i[2] = r[1], i[3] = n >> 8 & 255, i[4] = n & 255;
    const a = u([i, t]);
    this.clientDownstreamWriter.write(a);
  }
  /**
   * Encrypts data in a TLS 1.2-compliant manner using
   * the AES-GCM algorithm.
   */
  async encryptData(e, t) {
    const r = this.sessionKeys.serverIV, n = crypto.getRandomValues(new Uint8Array(8)), i = new Uint8Array([...r, ...n]), a = new Uint8Array([
      ...Y(this.sentRecordSequenceNumber),
      e,
      ...U,
      // Payload length without IV and tag
      ...I(t.length)
    ]), _ = await crypto.subtle.encrypt(
      {
        name: "AES-GCM",
        iv: i,
        additionalData: a,
        tagLength: 128
      },
      this.sessionKeys.serverWriteKey,
      t
    );
    return ++this.sentRecordSequenceNumber, u([
      n,
      new Uint8Array(_)
    ]);
  }
}
class T {
  static TLSMessage(e, t) {
    switch (e) {
      case C.Handshake:
        return T.clientHandshake(t);
      case C.Alert:
        return T.alert(t);
      case C.ChangeCipherSpec:
        return T.changeCipherSpec();
      case C.ApplicationData:
        return T.applicationData(t);
      default:
        throw new Error(`TLS: Unsupported TLS record type ${e}`);
    }
  }
  /**
   * Parses the cipher suites from the server hello message.
   *
   * The cipher suites are encoded as a list of 2-byte values.
   *
   * Binary layout:
   *
   * +----------------------------+
   * | Cipher Suites Length       |  2 bytes
   * +----------------------------+
   * | Cipher Suite 1             |  2 bytes
   * +----------------------------+
   * | Cipher Suite 2             |  2 bytes
   * +----------------------------+
   * | ...                        |
   * +----------------------------+
   * | Cipher Suite n             |  2 bytes
   * +----------------------------+
   *
   * The full list of supported cipher suites values is available at:
   *
   * https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#tls-parameters-4
   */
  static parseCipherSuites(e) {
    const t = new m(e);
    t.readUint16();
    const r = [];
    for (; !t.isFinished(); ) {
      const n = t.readUint16();
      n in Z && r.push(Z[n]);
    }
    return r;
  }
  static applicationData(e) {
    return {
      type: C.ApplicationData,
      body: e
    };
  }
  static changeCipherSpec() {
    return {
      type: C.ChangeCipherSpec,
      body: new Uint8Array()
    };
  }
  static alert(e) {
    return {
      type: C.Alert,
      level: ue[e[0]],
      description: He[e[1]]
    };
  }
  static clientHandshake(e) {
    const t = e[0], r = e[1] << 16 | e[2] << 8 | e[3], n = e.slice(4);
    let i;
    switch (t) {
      case d.HelloRequest:
        i = T.clientHelloRequestPayload();
        break;
      case d.ClientHello:
        i = T.clientHelloPayload(n);
        break;
      case d.ClientKeyExchange:
        i = T.clientKeyExchangePayload(n);
        break;
      case d.Finished:
        i = T.clientFinishedPayload(n);
        break;
      default:
        throw new Error(`Invalid handshake type ${t}`);
    }
    return {
      type: C.Handshake,
      msg_type: t,
      length: r,
      body: i
    };
  }
  static clientHelloRequestPayload() {
    return {};
  }
  /**
   *	Offset  Size    Field
   *	(bytes) (bytes)
   *	+------+------+---------------------------+
   *	| 0000 |  1   | Handshake Type (1 = ClientHello)
   *	+------+------+---------------------------+
   *	| 0001 |  3   | Length of ClientHello
   *	+------+------+---------------------------+
   *	| 0004 |  2   | Protocol Version
   *	+------+------+---------------------------+
   *	| 0006 |  32  | Client Random
   *	|      |      | (4 bytes timestamp +
   *	|      |      |  28 bytes random)
   *	+------+------+---------------------------+
   *	| 0038 |  1   | Session ID Length
   *	+------+------+---------------------------+
   *	| 0039 |  0+  | Session ID (variable)
   *	|      |      | (0-32 bytes)
   *	+------+------+---------------------------+
   *	| 003A*|  2   | Cipher Suites Length
   *	+------+------+---------------------------+
   *	| 003C*|  2+  | Cipher Suites
   *	|      |      | (2 bytes each)
   *	+------+------+---------------------------+
   *	| xxxx |  1   | Compression Methods Length
   *	+------+------+---------------------------+
   *	| xxxx |  1+  | Compression Methods
   *	|      |      | (1 byte each)
   *	+------+------+---------------------------+
   *	| xxxx |  2   | Extensions Length
   *	+------+------+---------------------------+
   *	| xxxx |  2   | Extension Type
   *	+------+------+---------------------------+
   *	| xxxx |  2   | Extension Length
   *	+------+------+---------------------------+
   *	| xxxx |  v   | Extension Data
   *	+------+------+---------------------------+
   *	|      |      | (Additional extensions...)
   *	+------+------+---------------------------+
   */
  static clientHelloPayload(e) {
    const t = new m(e.buffer), r = {
      client_version: t.readUint8Array(2),
      /**
       * Technically this consists of a GMT timestamp
       * and 28 random bytes, but we don't need to
       * parse this further.
       */
      random: t.readUint8Array(32)
    }, n = t.readUint8();
    r.session_id = t.readUint8Array(n);
    const i = t.readUint16();
    r.cipher_suites = T.parseCipherSuites(
      t.readUint8Array(i).buffer
    );
    const a = t.readUint8();
    r.compression_methods = t.readUint8Array(
      a
    );
    const _ = t.readUint16();
    return r.extensions = ke(
      t.readUint8Array(_)
    ), r;
  }
  /**
   * Binary layout:
   *
   *	+------------------------------------+
   *	| ECDH Client Public Key Length [1B] |
   *	+------------------------------------+
   *	| ECDH Client Public Key   [variable]|
   *	+------------------------------------+
   */
  static clientKeyExchangePayload(e) {
    return {
      // Skip the first byte, which is the length of the public key
      exchange_keys: e.slice(1, e.length)
    };
  }
  static clientFinishedPayload(e) {
    return {
      verify_data: e
    };
  }
}
function Ve(s) {
  return new TransformStream({
    transform(e, t) {
      for (; e.length > 0; )
        t.enqueue(e.slice(0, s)), e = e.slice(s);
    }
  });
}
class K {
  static certificate(e) {
    const t = [];
    for (const i of e)
      t.push(y(i.byteLength)), t.push(new Uint8Array(i));
    const r = u(t), n = new Uint8Array([
      ...y(r.byteLength),
      ...r
    ]);
    return new Uint8Array([
      d.Certificate,
      ...y(n.length),
      ...n
    ]);
  }
  /*
   * Byte layout of the ServerKeyExchange message:
   *
   * +-----------------------------------+
   * |    ServerKeyExchange Message      |
   * +-----------------------------------+
   * | Handshake type (1 byte)           |
   * +-----------------------------------+
   * | Length (3 bytes)                  |
   * +-----------------------------------+
   * | Curve Type (1 byte)               |
   * +-----------------------------------+
   * | Named Curve (2 bytes)             |
   * +-----------------------------------+
   * | EC Point Format (1 byte)          |
   * +-----------------------------------+
   * | Public Key Length (1 byte)        |
   * +-----------------------------------+
   * | Public Key (variable)             |
   * +-----------------------------------+
   * | Signature Algorithm (2 bytes)     |
   * +-----------------------------------+
   * | Signature Length (2 bytes)        |
   * +-----------------------------------+
   * | Signature (variable)              |
   * +-----------------------------------+
   *
   * @param clientRandom - 32 bytes from ClientHello
   * @param serverRandom - 32 bytes from ServerHello
   * @param ecdheKeyPair - ECDHE key pair
   * @param rsaPrivateKey - RSA private key for signing
   * @returns
   */
  static async ECDHEServerKeyExchange(e, t, r, n) {
    const i = new Uint8Array(
      await crypto.subtle.exportKey("raw", r.publicKey)
    ), a = new Uint8Array([
      // Curve type (1 byte)
      je.NamedCurve,
      // Curve name (2 bytes)
      ...I(Ge.secp256r1),
      // Public key length (1 byte)
      i.byteLength,
      // Public key (65 bytes, uncompressed format)
      ...i
    ]), _ = await crypto.subtle.sign(
      {
        name: "RSASSA-PKCS1-v1_5",
        hash: "SHA-256"
      },
      n,
      new Uint8Array([...e, ...t, ...a])
    ), c = new Uint8Array(_), S = new Uint8Array([
      $.sha256,
      G.rsa
    ]), h = new Uint8Array([
      ...a,
      ...S,
      ...I(c.length),
      ...c
    ]);
    return new Uint8Array([
      d.ServerKeyExchange,
      ...y(h.length),
      ...h
    ]);
  }
  /**
   * +------------------------------------+
   * | Content Type (Handshake)     [1B]  |
   * | 0x16                               |
   * +------------------------------------+
   * | Version (TLS 1.2)            [2B]  |
   * | 0x03 0x03                          |
   * +------------------------------------+
   * | Length                       [2B]  |
   * +------------------------------------+
   * | Handshake Type (ServerHello) [1B]  |
   * | 0x02                               |
   * +------------------------------------+
   * | Handshake Length             [3B]  |
   * +------------------------------------+
   * | Server Version               [2B]  |
   * +------------------------------------+
   * | Server Random               [32B]  |
   * +------------------------------------+
   * | Session ID Length            [1B]  |
   * +------------------------------------+
   * | Session ID             [0-32B]     |
   * +------------------------------------+
   * | Cipher Suite                 [2B]  |
   * +------------------------------------+
   * | Compression Method           [1B]  |
   * +------------------------------------+
   * | Extensions Length            [2B]  |
   * +------------------------------------+
   * | Extension: ec_point_formats        |
   * |   Type (0x00 0x0B)           [2B]  |
   * |   Length                     [2B]  |
   * |   EC Point Formats Length    [1B]  |
   * |   EC Point Format            [1B]  |
   * +------------------------------------+
   * | Other Extensions...                |
   * +------------------------------------+
   */
  static serverHello(e, t, r) {
    const n = e.extensions.map((_) => {
      switch (_.type) {
        case "server_name":
          return Ce.encodeForClient();
      }
    }).filter((_) => _ !== void 0), i = u(n), a = new Uint8Array([
      // Version field – 0x03, 0x03 means TLS 1.2
      ...U,
      ...t,
      e.session_id.length,
      ...e.session_id,
      ...I(he.TLS1_CK_ECDHE_RSA_WITH_AES_128_GCM_SHA256),
      r,
      // Extensions length (2 bytes)
      ...I(i.length),
      ...i
    ]);
    return new Uint8Array([
      d.ServerHello,
      ...y(a.length),
      ...a
    ]);
  }
  static serverHelloDone() {
    return new Uint8Array([d.ServerHelloDone, ...y(0)]);
  }
  /**
   * Server finished message.
   * The structure is defined in:
   * https://datatracker.ietf.org/doc/html/rfc5246#section-7.4.9
   *
   * struct {
   *     opaque verify_data[verify_data_length];
   * } Finished;
   *
   * verify_data
   *    PRF(master_secret, finished_label, Hash(handshake_messages))
   *       [0..verify_data_length-1];
   *
   * finished_label
   *    For Finished messages sent by the client, the string
   *    "client finished".  For Finished messages sent by the server,
   *    the string "server finished".
   */
  static async createFinishedMessage(e, t) {
    const r = await crypto.subtle.digest(
      "SHA-256",
      u(e)
    ), n = new Uint8Array(
      await O(
        t,
        new TextEncoder().encode("server finished"),
        r,
        // verify_data length. TLS 1.2 specifies 12 bytes for verify_data
        12
      )
    );
    return new Uint8Array([
      d.Finished,
      ...y(n.length),
      ...n
    ]);
  }
  static changeCipherSpec() {
    return new Uint8Array([1]);
  }
}
function Ye(s, e) {
  return Ze.generateCertificate(s, e);
}
function yt(s) {
  return `-----BEGIN CERTIFICATE-----
${fe(
    de(s.buffer)
  )}
-----END CERTIFICATE-----`;
}
async function Lt(s) {
  const e = await crypto.subtle.exportKey("pkcs8", s);
  return `-----BEGIN PRIVATE KEY-----
${fe(
    de(e)
  )}
-----END PRIVATE KEY-----`;
}
class Ze {
  static async generateCertificate(e, t) {
    const r = await crypto.subtle.generateKey(
      {
        name: "RSASSA-PKCS1-v1_5",
        hash: "SHA-256",
        modulusLength: 2048,
        publicExponent: new Uint8Array([1, 0, 1])
      },
      !0,
      // extractable
      ["sign", "verify"]
    ), n = await this.signingRequest(
      e,
      r.publicKey
    ), i = await this.sign(
      n,
      (t == null ? void 0 : t.privateKey) ?? r.privateKey
    );
    return {
      keyPair: r,
      certificate: i,
      tbsCertificate: n,
      tbsDescription: e
    };
  }
  static async sign(e, t) {
    const r = await crypto.subtle.sign(
      {
        name: "RSASSA-PKCS1-v1_5",
        hash: "SHA-256"
      },
      t,
      e.buffer
    );
    return o.sequence([
      new Uint8Array(e.buffer),
      this.signatureAlgorithm("sha256WithRSAEncryption"),
      o.bitString(new Uint8Array(r))
    ]);
  }
  static async signingRequest(e, t) {
    const r = [];
    return e.keyUsage && r.push(this.keyUsage(e.keyUsage)), e.extKeyUsage && r.push(this.extKeyUsage(e.extKeyUsage)), e.subjectAltNames && r.push(this.subjectAltName(e.subjectAltNames)), e.nsCertType && r.push(this.nsCertType(e.nsCertType)), e.basicConstraints && r.push(
      this.basicConstraints(e.basicConstraints)
    ), o.sequence([
      this.version(e.version),
      this.serialNumber(e.serialNumber),
      this.signatureAlgorithm(e.signatureAlgorithm),
      this.distinguishedName(e.issuer ?? e.subject),
      this.validity(e.validity),
      this.distinguishedName(e.subject),
      await this.subjectPublicKeyInfo(t),
      this.extensions(r)
    ]);
  }
  static version(e = 2) {
    return o.ASN1(
      160,
      o.integer(new Uint8Array([e]))
    );
  }
  static serialNumber(e = crypto.getRandomValues(new Uint8Array(4))) {
    return o.integer(e);
  }
  static signatureAlgorithm(e = "sha256WithRSAEncryption") {
    return o.sequence([
      o.objectIdentifier(w(e)),
      o.null()
    ]);
  }
  static async subjectPublicKeyInfo(e) {
    return new Uint8Array(await crypto.subtle.exportKey("spki", e));
  }
  static extensions(e) {
    return o.ASN1(163, o.sequence(e));
  }
  static distinguishedName(e) {
    const t = [];
    for (const [r, n] of Object.entries(e)) {
      const i = [
        o.objectIdentifier(w(r))
      ];
      switch (r) {
        case "countryName":
          i.push(o.printableString(n));
          break;
        default:
          i.push(o.utf8String(n));
      }
      t.push(o.set([o.sequence(i)]));
    }
    return o.sequence(t);
  }
  static validity(e) {
    return o.sequence([
      o.ASN1(
        H.UTCTime,
        new TextEncoder().encode(
          ie((e == null ? void 0 : e.notBefore) ?? /* @__PURE__ */ new Date())
        )
      ),
      o.ASN1(
        H.UTCTime,
        new TextEncoder().encode(
          ie(
            (e == null ? void 0 : e.notAfter) ?? Xe(/* @__PURE__ */ new Date(), 10)
          )
        )
      )
    ]);
  }
  static basicConstraints({
    ca: e = !0,
    pathLenConstraint: t = void 0
  }) {
    const r = [o.boolean(e)];
    return t !== void 0 && r.push(
      o.integer(new Uint8Array([t]))
    ), o.sequence([
      o.objectIdentifier(w("basicConstraints")),
      o.octetString(o.sequence(r))
    ]);
  }
  static keyUsage(e) {
    const t = new Uint8Array([0]);
    return e != null && e.digitalSignature && (t[0] |= 1), e != null && e.nonRepudiation && (t[0] |= 2), e != null && e.keyEncipherment && (t[0] |= 4), e != null && e.dataEncipherment && (t[0] |= 8), e != null && e.keyAgreement && (t[0] |= 16), e != null && e.keyCertSign && (t[0] |= 32), e != null && e.cRLSign && (t[0] |= 64), e != null && e.encipherOnly && (t[0] |= 128), e != null && e.decipherOnly && (t[0] |= 64), o.sequence([
      o.objectIdentifier(w("keyUsage")),
      o.boolean(!0),
      // Critical
      o.octetString(o.bitString(t))
    ]);
  }
  static extKeyUsage(e = {}) {
    return o.sequence([
      o.objectIdentifier(w("extKeyUsage")),
      o.boolean(!0),
      // Critical
      o.octetString(
        o.sequence(
          Object.entries(e).map(([t, r]) => r ? o.objectIdentifier(
            w(t)
          ) : o.null())
        )
      )
    ]);
  }
  static nsCertType(e) {
    const t = new Uint8Array([0]);
    return e.client && (t[0] |= 1), e.server && (t[0] |= 2), e.email && (t[0] |= 4), e.objsign && (t[0] |= 8), e.sslCA && (t[0] |= 16), e.emailCA && (t[0] |= 32), e.objCA && (t[0] |= 64), o.sequence([
      o.objectIdentifier(w("nsCertType")),
      o.octetString(t)
    ]);
  }
  static subjectAltName(e) {
    var i, a;
    const t = ((i = e.dnsNames) == null ? void 0 : i.map((_) => {
      const c = o.ia5String(_);
      return o.contextSpecific(2, c);
    })) || [], r = ((a = e.ipAddresses) == null ? void 0 : a.map((_) => {
      const c = o.ia5String(_);
      return o.contextSpecific(7, c);
    })) || [], n = o.octetString(
      o.sequence([...t, ...r])
    );
    return o.sequence([
      o.objectIdentifier(w("subjectAltName")),
      o.boolean(!0),
      n
    ]);
  }
}
const Je = {
  // Algorithm OIDs
  "1.2.840.113549.1.1.1": "rsaEncryption",
  "1.2.840.113549.1.1.4": "md5WithRSAEncryption",
  "1.2.840.113549.1.1.5": "sha1WithRSAEncryption",
  "1.2.840.113549.1.1.7": "RSAES-OAEP",
  "1.2.840.113549.1.1.8": "mgf1",
  "1.2.840.113549.1.1.9": "pSpecified",
  "1.2.840.113549.1.1.10": "RSASSA-PSS",
  "1.2.840.113549.1.1.11": "sha256WithRSAEncryption",
  "1.2.840.113549.1.1.12": "sha384WithRSAEncryption",
  "1.2.840.113549.1.1.13": "sha512WithRSAEncryption",
  "1.3.101.112": "EdDSA25519",
  "1.2.840.10040.4.3": "dsa-with-sha1",
  "1.3.14.3.2.7": "desCBC",
  "1.3.14.3.2.26": "sha1",
  "1.3.14.3.2.29": "sha1WithRSASignature",
  "2.16.840.1.101.3.4.2.1": "sha256",
  "2.16.840.1.101.3.4.2.2": "sha384",
  "2.16.840.1.101.3.4.2.3": "sha512",
  "2.16.840.1.101.3.4.2.4": "sha224",
  "2.16.840.1.101.3.4.2.5": "sha512-224",
  "2.16.840.1.101.3.4.2.6": "sha512-256",
  "1.2.840.113549.2.2": "md2",
  "1.2.840.113549.2.5": "md5",
  // pkcs#7 content types
  "1.2.840.113549.1.7.1": "data",
  "1.2.840.113549.1.7.2": "signedData",
  "1.2.840.113549.1.7.3": "envelopedData",
  "1.2.840.113549.1.7.4": "signedAndEnvelopedData",
  "1.2.840.113549.1.7.5": "digestedData",
  "1.2.840.113549.1.7.6": "encryptedData",
  // pkcs#9 oids
  "1.2.840.113549.1.9.1": "emailAddress",
  "1.2.840.113549.1.9.2": "unstructuredName",
  "1.2.840.113549.1.9.3": "contentType",
  "1.2.840.113549.1.9.4": "messageDigest",
  "1.2.840.113549.1.9.5": "signingTime",
  "1.2.840.113549.1.9.6": "counterSignature",
  "1.2.840.113549.1.9.7": "challengePassword",
  "1.2.840.113549.1.9.8": "unstructuredAddress",
  "1.2.840.113549.1.9.14": "extensionRequest",
  "1.2.840.113549.1.9.20": "friendlyName",
  "1.2.840.113549.1.9.21": "localKeyId",
  "1.2.840.113549.1.9.22.1": "x509Certificate",
  // pkcs#12 safe bags
  "1.2.840.113549.1.12.10.1.1": "keyBag",
  "1.2.840.113549.1.12.10.1.2": "pkcs8ShroudedKeyBag",
  "1.2.840.113549.1.12.10.1.3": "certBag",
  "1.2.840.113549.1.12.10.1.4": "crlBag",
  "1.2.840.113549.1.12.10.1.5": "secretBag",
  "1.2.840.113549.1.12.10.1.6": "safeContentsBag",
  // password-based-encryption for pkcs#12
  "1.2.840.113549.1.5.13": "pkcs5PBES2",
  "1.2.840.113549.1.5.12": "pkcs5PBKDF2",
  "1.2.840.113549.1.12.1.1": "pbeWithSHAAnd128BitRC4",
  "1.2.840.113549.1.12.1.2": "pbeWithSHAAnd40BitRC4",
  "1.2.840.113549.1.12.1.3": "pbeWithSHAAnd3-KeyTripleDES-CBC",
  "1.2.840.113549.1.12.1.4": "pbeWithSHAAnd2-KeyTripleDES-CBC",
  "1.2.840.113549.1.12.1.5": "pbeWithSHAAnd128BitRC2-CBC",
  "1.2.840.113549.1.12.1.6": "pbewithSHAAnd40BitRC2-CBC",
  // hmac OIDs
  "1.2.840.113549.2.7": "hmacWithSHA1",
  "1.2.840.113549.2.8": "hmacWithSHA224",
  "1.2.840.113549.2.9": "hmacWithSHA256",
  "1.2.840.113549.2.10": "hmacWithSHA384",
  "1.2.840.113549.2.11": "hmacWithSHA512",
  // symmetric key algorithm oids
  "1.2.840.113549.3.7": "des-EDE3-CBC",
  "2.16.840.1.101.3.4.1.2": "aes128-CBC",
  "2.16.840.1.101.3.4.1.22": "aes192-CBC",
  "2.16.840.1.101.3.4.1.42": "aes256-CBC",
  // certificate issuer/subject OIDs
  "2.5.4.3": "commonName",
  "2.5.4.4": "surname",
  "2.5.4.5": "serialNumber",
  "2.5.4.6": "countryName",
  "2.5.4.7": "localityName",
  "2.5.4.8": "stateOrProvinceName",
  "2.5.4.9": "streetAddress",
  "2.5.4.10": "organizationName",
  "2.5.4.11": "organizationalUnitName",
  "2.5.4.12": "title",
  "2.5.4.13": "description",
  "2.5.4.15": "businessCategory",
  "2.5.4.17": "postalCode",
  "2.5.4.42": "givenName",
  "1.3.6.1.4.1.311.60.2.1.2": "jurisdictionOfIncorporationStateOrProvinceName",
  "1.3.6.1.4.1.311.60.2.1.3": "jurisdictionOfIncorporationCountryName",
  // X.509 extension OIDs
  "2.16.840.1.113730.1.1": "nsCertType",
  "2.16.840.1.113730.1.13": "nsComment",
  "2.5.29.14": "subjectKeyIdentifier",
  "2.5.29.15": "keyUsage",
  "2.5.29.17": "subjectAltName",
  "2.5.29.18": "issuerAltName",
  "2.5.29.19": "basicConstraints",
  "2.5.29.31": "cRLDistributionPoints",
  "2.5.29.32": "certificatePolicies",
  "2.5.29.35": "authorityKeyIdentifier",
  "2.5.29.37": "extKeyUsage",
  // extKeyUsage purposes
  "1.3.6.1.4.1.11129.2.4.2": "timestampList",
  "1.3.6.1.5.5.7.1.1": "authorityInfoAccess",
  "1.3.6.1.5.5.7.3.1": "serverAuth",
  "1.3.6.1.5.5.7.3.2": "clientAuth",
  "1.3.6.1.5.5.7.3.3": "codeSigning",
  "1.3.6.1.5.5.7.3.4": "emailProtection",
  "1.3.6.1.5.5.7.3.8": "timeStamping"
};
function w(s) {
  for (const [e, t] of Object.entries(Je))
    if (t === s)
      return e;
  throw new Error(`OID not found for name: ${s}`);
}
const se = 32, H = {
  Boolean: 1,
  Integer: 2,
  BitString: 3,
  OctetString: 4,
  Null: 5,
  OID: 6,
  Utf8String: 12,
  Sequence: 16 | se,
  Set: 17 | se,
  PrintableString: 19,
  IA5String: 22,
  UTCTime: 23
};
class o {
  // Helper functions for ASN.1 DER encoding
  static length_(e) {
    if (e < 128)
      return new Uint8Array([e]);
    {
      let t = e;
      const r = [];
      for (; t > 0; )
        r.unshift(t & 255), t >>= 8;
      const n = r.length, i = new Uint8Array(1 + n);
      i[0] = 128 | n;
      for (let a = 0; a < n; a++)
        i[a + 1] = r[a];
      return i;
    }
  }
  static ASN1(e, t) {
    const r = o.length_(t.length), n = new Uint8Array(1 + r.length + t.length);
    return n[0] = e, n.set(r, 1), n.set(t, 1 + r.length), n;
  }
  static integer(e) {
    if (e[0] > 127) {
      const t = new Uint8Array(e.length + 1);
      t[0] = 0, t.set(e, 1), e = t;
    }
    return o.ASN1(H.Integer, e);
  }
  static bitString(e) {
    const t = new Uint8Array([0]), r = new Uint8Array(t.length + e.length);
    return r.set(t), r.set(e, t.length), o.ASN1(H.BitString, r);
  }
  static octetString(e) {
    return o.ASN1(H.OctetString, e);
  }
  static null() {
    return o.ASN1(H.Null, new Uint8Array(0));
  }
  static objectIdentifier(e) {
    const t = e.split(".").map(Number), n = [t[0] * 40 + t[1]];
    for (let i = 2; i < t.length; i++) {
      let a = t[i];
      const _ = [];
      do
        _.unshift(a & 127), a >>= 7;
      while (a > 0);
      for (let c = 0; c < _.length - 1; c++)
        _[c] |= 128;
      n.push(..._);
    }
    return o.ASN1(H.OID, new Uint8Array(n));
  }
  static utf8String(e) {
    const t = new TextEncoder().encode(e);
    return o.ASN1(H.Utf8String, t);
  }
  static printableString(e) {
    const t = new TextEncoder().encode(e);
    return o.ASN1(H.PrintableString, t);
  }
  static sequence(e) {
    return o.ASN1(H.Sequence, u(e));
  }
  static set(e) {
    return o.ASN1(H.Set, u(e));
  }
  static ia5String(e) {
    const t = new TextEncoder().encode(e);
    return o.ASN1(H.IA5String, t);
  }
  static contextSpecific(e, t, r = !1) {
    const n = (r ? 160 : 128) | e;
    return o.ASN1(n, t);
  }
  static boolean(e) {
    return o.ASN1(
      H.Boolean,
      new Uint8Array([e ? 255 : 0])
    );
  }
}
function de(s) {
  return btoa(String.fromCodePoint(...new Uint8Array(s)));
}
function fe(s) {
  var e;
  return ((e = s.match(/.{1,64}/g)) == null ? void 0 : e.join(`
`)) || s;
}
function ie(s) {
  const e = s.getUTCFullYear().toString().substr(2), t = W(s.getUTCMonth() + 1), r = W(s.getUTCDate()), n = W(s.getUTCHours()), i = W(s.getUTCMinutes()), a = W(s.getUTCSeconds());
  return `${e}${t}${r}${n}${i}${a}Z`;
}
function W(s) {
  return s.toString().padStart(2, "0");
}
function Xe(s, e) {
  const t = new Date(s);
  return t.setUTCFullYear(t.getUTCFullYear() + e), t;
}
async function Qe(s, e, t) {
  var a;
  const r = typeof s == "string" ? new Request(s, e) : s;
  if (!t)
    return await fetch(r);
  const [n, i] = await Ie(r);
  try {
    return await fetch(n);
  } catch {
    const c = ((a = new Headers(i.headers).get("x-cors-proxy-allowed-request-headers")) == null ? void 0 : a.split(",")) || [], S = c.includes("authorization") || c.includes("cookie"), h = await De(i, {
      url: `${t}${r.url}`,
      ...S && { credentials: "include" }
    });
    return await fetch(h, e);
  }
}
class et extends TransformStream {
  constructor() {
    let e = new Uint8Array(0), t = "SCAN_CHUNK_SIZE", r = 0;
    super({
      transform(n, i) {
        for (e = u([e, n]); e.length > 0; )
          if (t === "SCAN_CHUNK_SIZE") {
            if (e.length < 3)
              return;
            let a = 0;
            for (; a < e.length; ) {
              const S = e[a];
              if (!(S >= 48 && S <= 57 || // 0-9
              S >= 97 && S <= 102 || // a-f
              S >= 65 && S <= 70)) break;
              a++;
            }
            if (a === 0)
              throw new Error("Invalid chunk size format");
            if (e.length < a + 2)
              return;
            if (e[a] !== 13 || // \r
            e[a + 1] !== 10)
              throw new Error(
                "Invalid chunk size format. Expected CRLF after chunk size"
              );
            const _ = new TextDecoder().decode(
              e.slice(0, a)
            ), c = parseInt(_, 16);
            if (e = e.slice(a + 2), c === 0) {
              t = "SCAN_FINAL_CHUNK", i.terminate();
              return;
            }
            r = c, t = "SCAN_CHUNK_DATA";
          } else if (t === "SCAN_CHUNK_DATA") {
            const a = Math.min(
              r,
              e.length
            ), _ = e.slice(0, a);
            e = e.slice(a), r -= a, i.enqueue(_), r === 0 && (t = "SCAN_CHUNK_TRAILER");
          } else if (t === "SCAN_CHUNK_TRAILER") {
            if (e.length < 2)
              return;
            if (e[0] !== 13 || e[1] !== 10)
              throw new Error(
                "Invalid chunk trailer format. Expected CRLF after chunk data"
              );
            e = e.slice(2), t = "SCAN_CHUNK_SIZE";
          }
      }
    });
  }
}
const tt = (s, e) => ({
  ...s,
  websocket: {
    url: (t, r, n) => `ws://playground.internal/?${new URLSearchParams({
      host: r,
      port: n
    }).toString()}`,
    subprotocol: "binary",
    decorator: () => class extends rt {
      constructor(t, r) {
        super(t, r, {
          CAroot: e.CAroot,
          corsProxyUrl: e.corsProxyUrl
        });
      }
    }
  }
});
class rt {
  constructor(e, t, {
    CAroot: r,
    corsProxyUrl: n,
    outputType: i = "messages"
  } = {}) {
    this.CONNECTING = 0, this.OPEN = 1, this.CLOSING = 2, this.CLOSED = 3, this.readyState = this.CONNECTING, this.binaryType = "blob", this.bufferedAmount = 0, this.extensions = "", this.protocol = "ws", this.host = "", this.port = 0, this.listeners = /* @__PURE__ */ new Map(), this.clientUpstream = new TransformStream(), this.clientUpstreamWriter = this.clientUpstream.writable.getWriter(), this.clientDownstream = new TransformStream(), this.fetchInitiated = !1, this.bufferedBytesFromClient = new Uint8Array(0), this.url = e, this.options = t;
    const a = new URL(e);
    this.host = a.searchParams.get("host"), this.port = parseInt(a.searchParams.get("port"), 10), this.binaryType = "arraybuffer", this.corsProxyUrl = n, this.CAroot = r, i === "messages" && this.clientDownstream.readable.pipeTo(
      new WritableStream({
        write: (_) => {
          this.emit("message", { data: _ });
        },
        abort: () => {
          this.emit("error", new Error("ECONNREFUSED")), this.close();
        },
        close: () => {
          this.close();
        }
      })
    ).catch(() => {
    }), this.readyState = this.OPEN, this.emit("open");
  }
  on(e, t) {
    this.addEventListener(e, t);
  }
  once(e, t) {
    const r = (n) => {
      t(n), this.removeEventListener(e, r);
    };
    this.addEventListener(e, r);
  }
  addEventListener(e, t) {
    this.listeners.has(e) || this.listeners.set(e, /* @__PURE__ */ new Set()), this.listeners.get(e).add(t);
  }
  removeListener(e, t) {
    this.removeEventListener(e, t);
  }
  removeEventListener(e, t) {
    const r = this.listeners.get(e);
    r && r.delete(t);
  }
  emit(e, t = {}) {
    e === "message" ? this.onmessage(t) : e === "close" ? this.onclose(t) : e === "error" ? this.onerror(t) : e === "open" && this.onopen(t);
    const r = this.listeners.get(e);
    if (r)
      for (const n of r)
        n(t);
  }
  // Default event handlers that can be overridden by the user
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onclose(e) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onerror(e) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onmessage(e) {
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onopen(e) {
  }
  /**
   * Emscripten calls this method whenever the WASM module
   * writes bytes to the TCP socket.
   */
  send(e) {
    if (!(this.readyState === this.CLOSING || this.readyState === this.CLOSED) && (this.clientUpstreamWriter.write(new Uint8Array(e)), !this.fetchInitiated))
      switch (this.bufferedBytesFromClient = u([
        this.bufferedBytesFromClient,
        new Uint8Array(e)
      ]), st(this.port, this.bufferedBytesFromClient)) {
        case !1:
          return;
        case "other":
          this.emit("error", new Error("Unsupported protocol")), this.close();
          break;
        case "tls":
          this.fetchOverTLS(), this.fetchInitiated = !0;
          break;
        case "http":
          this.fetchOverHTTP(), this.fetchInitiated = !0;
          break;
      }
  }
  async fetchOverTLS() {
    if (!this.CAroot)
      throw new Error(
        "TLS protocol is only supported when the TCPOverFetchWebsocket is instantiated with a CAroot"
      );
    const e = await Ye(
      {
        subject: {
          commonName: this.host,
          organizationName: this.host,
          countryName: "US"
        },
        issuer: this.CAroot.tbsDescription.subject
      },
      this.CAroot.keyPair
    ), t = new ze();
    this.clientUpstream.readable.pipeTo(t.clientEnd.upstream.writable).catch(() => {
    }), t.clientEnd.downstream.readable.pipeTo(this.clientDownstream.writable).catch(() => {
    }), await t.TLSHandshake(e.keyPair.privateKey, [
      e.certificate,
      this.CAroot.certificate
    ]);
    const r = await L.parseHttpRequest(
      t.serverEnd.upstream.readable,
      this.host,
      "https"
    );
    try {
      await L.fetchRawResponseBytes(
        r,
        this.corsProxyUrl
      ).pipeTo(t.serverEnd.downstream.writable);
    } catch {
    }
  }
  async fetchOverHTTP() {
    const e = await L.parseHttpRequest(
      this.clientUpstream.readable,
      this.host,
      "http"
    );
    try {
      await L.fetchRawResponseBytes(
        e,
        this.corsProxyUrl
      ).pipeTo(this.clientDownstream.writable);
    } catch {
    }
  }
  close() {
    this.emit("message", { data: new Uint8Array(0) }), this.readyState = this.CLOSING, this.emit("close"), this.readyState = this.CLOSED;
  }
}
const nt = [
  "GET",
  "POST",
  "HEAD",
  "PATCH",
  "OPTIONS",
  "DELETE",
  "PUT",
  "TRACE"
];
function st(s, e) {
  if (e.length < 8)
    return !1;
  if (s === 443 && e[0] === C.Handshake && // TLS versions between 1.0 and 1.2
  e[1] === 3 && e[2] >= 1 && e[2] <= 3)
    return "tls";
  const r = new TextDecoder("latin1", {
    fatal: !0
  }).decode(e);
  return nt.some(
    (i) => r.startsWith(i + " ")
  ) ? "http" : "other";
}
class L {
  /**
   * Streams a HTTP response including the status line and headers.
   */
  static fetchRawResponseBytes(e, t) {
    return new ReadableStream({
      async start(r) {
        var _;
        let n;
        try {
          n = await Qe(
            e,
            void 0,
            t
          );
        } catch (c) {
          r.enqueue(
            new TextEncoder().encode(
              `HTTP/1.1 400 Bad Request\r
Content-Length: 0\r
\r
`
            )
          ), r.error(c);
          return;
        }
        r.enqueue(L.headersAsBytes(n));
        const i = (_ = n.body) == null ? void 0 : _.getReader();
        if (!i) {
          r.close();
          return;
        }
        const a = new TextEncoder();
        for (; ; ) {
          const { done: c, value: S } = await i.read();
          if (S && (r.enqueue(
            a.encode(`${S.length.toString(16)}\r
`)
          ), r.enqueue(S), r.enqueue(a.encode(`\r
`))), c) {
            r.enqueue(a.encode(`0\r
\r
`)), r.close();
            return;
          }
        }
      }
    });
  }
  static headersAsBytes(e) {
    const t = `HTTP/1.1 ${e.status} ${e.statusText}`, r = {};
    e.headers.forEach((a, _) => {
      r[_.toLowerCase()] = a;
    }), delete r["content-length"], r["transfer-encoding"] = "chunked";
    const n = [];
    for (const [a, _] of Object.entries(r))
      n.push(`${a}: ${_}`);
    const i = [t, ...n].join(`\r
`) + `\r
\r
`;
    return new TextEncoder().encode(i);
  }
  /**
   * Parses a raw, streamed HTTP request into a Request object
   * with known headers and a readable body stream.
   */
  static async parseHttpRequest(e, t, r) {
    let n = new Uint8Array(0), i = !1, a = -1;
    const _ = e.getReader();
    for (; a === -1; ) {
      const { done: x, value: P } = await _.read();
      if (x) {
        i = !0;
        break;
      }
      n = u([n, P]), a = it(
        n,
        new Uint8Array([13, 10, 13, 10])
      );
    }
    _.releaseLock();
    const c = n.slice(0, a), S = L.parseRequestHeaders(c), h = S.headers.get("Transfer-Encoding") !== null ? "chunked" : "content-length", l = S.headers.get("Content-Length") !== null ? parseInt(S.headers.get("Content-Length"), 10) : void 0, A = n.slice(
      a + 4
      /* Skip \r\n\r\n */
    );
    let f;
    if (S.method !== "GET") {
      const x = e.getReader();
      let P = A.length, k = A.slice(-6);
      const Ee = new TextEncoder().encode(`0\r
\r
`);
      f = new ReadableStream({
        async start(D) {
          A.length > 0 && D.enqueue(A), i && D.close();
        },
        async pull(D) {
          const { done: pe, value: g } = await x.read();
          if (P += (g == null ? void 0 : g.length) || 0, g && (D.enqueue(g), k = u([
            k,
            g || new Uint8Array()
          ]).slice(-5)), pe || h === "content-length" && l !== void 0 && P >= l || h === "chunked" && k.every(
            (we, ye) => we === Ee[ye]
          )) {
            D.close();
            return;
          }
        }
      }), h === "chunked" && (f = f.pipeThrough(
        new et()
      ));
    }
    const N = S.headers.get("Host") ?? t, z = new URL(S.path, r + "://" + N);
    return z.pathname = S.path, new Request(z.toString(), {
      method: S.method,
      headers: S.headers,
      body: f,
      // In Node.js, duplex: 'half' is required when
      // the body stream is provided.
      // @ts-expect-error
      duplex: "half"
    });
  }
  static parseRequestHeaders(e) {
    const t = new TextDecoder().decode(e), r = t.split(`
`)[0], [n, i] = r.split(" "), a = new Headers();
    for (const _ of t.split(`\r
`).slice(1)) {
      if (_ === "")
        break;
      const [c, S] = _.split(": ");
      a.set(c, S);
    }
    return { method: n, path: i, headers: a };
  }
}
function it(s, e) {
  const t = s.length, r = e.length, n = t - r;
  for (let i = 0; i <= n; i++) {
    let a = !0;
    for (let _ = 0; _ < r; _++)
      if (s[i + _] !== e[_]) {
        a = !1;
        break;
      }
    if (a)
      return i;
  }
  return -1;
}
async function at(s) {
  const e = "icudt74l.dat", t = (await import("./shared/icudt74l.js")).dataFilename, r = await (await fetch(t)).arrayBuffer();
  return {
    ...s,
    ENV: {
      ...s.ENV,
      ICU_DATA: "/internal/shared"
    },
    onRuntimeInitialized: (n) => {
      s.onRuntimeInitialized && s.onRuntimeInitialized(n), R.fileExists(
        n.FS,
        `${n.ENV.ICU_DATA}/${e}`
      ) || (n.FS.mkdirTree(n.ENV.ICU_DATA), n.FS.writeFile(
        `${n.ENV.ICU_DATA}/${e}`,
        new Uint8Array(r)
      ));
    }
  };
}
const _t = () => ({
  websocket: {
    decorator: (s) => class extends s {
      constructor() {
        try {
          super();
        } catch {
        }
      }
      send() {
        return null;
      }
    }
  }
});
async function gt(s, e = {}) {
  var i;
  let t = {
    ..._t(),
    ...e.emscriptenOptions || {}
  };
  e.tcpOverFetch && (t = tt(
    t,
    e.tcpOverFetch
  )), e.withICU && (t = at(t));
  const [r, n] = await Promise.all([
    Be(s),
    t
  ]);
  return (i = e.onPhpLoaderModuleLoaded) == null || i.call(e, r), await ge(r, n);
}
function Kt(s, e) {
  window.addEventListener("message", (t) => {
    t.source === s.contentWindow && (e && t.origin !== e || typeof t.data != "object" || t.data.type !== "relay" || window.parent.postMessage(t.data, "*"));
  }), window.addEventListener("message", (t) => {
    var r;
    t.source === window.parent && (typeof t.data != "object" || t.data.type !== "relay" || (r = s == null ? void 0 : s.contentWindow) == null || r.postMessage(t.data));
  });
}
async function It(s) {
  const e = new Worker(s, { type: "module" });
  return new Promise((t, r) => {
    e.onerror = (i) => {
      const a = new Error(
        `WebWorker failed to load at ${s}. ${i.message ? `Original error: ${i.message}` : ""}`
      );
      a.filename = i.filename, r(a);
    };
    function n(i) {
      i.data === "worker-script-started" && (t(e), e.removeEventListener("message", n));
    }
    e.addEventListener("message", n);
  });
}
function Dt(s, e = { initialSync: {} }) {
  return e = {
    ...e,
    initialSync: {
      ...e.initialSync,
      direction: e.initialSync.direction ?? "opfs-to-memfs"
    }
  }, async function(t, r, n) {
    return e.initialSync.direction === "opfs-to-memfs" ? (R.fileExists(r, n) && R.rmdir(r, n), R.mkdir(r, n), await ot(r, s, n)) : await Te(
      r,
      s,
      n,
      e.initialSync.onProgress
    ), St(t, s, n);
  };
}
async function ot(s, e, t) {
  R.mkdir(s, t);
  const r = new We({
    concurrency: 40
  }), n = [], i = [
    [e, t]
  ];
  for (; i.length > 0; ) {
    const [a, _] = i.pop();
    for await (const c of a.values()) {
      const S = r.run(async () => {
        const h = oe(
          _,
          c.name
        );
        if (c.kind === "directory") {
          try {
            s.mkdir(h);
          } catch (l) {
            if ((l == null ? void 0 : l.errno) !== 20)
              throw v.error(l), l;
          }
          i.push([c, h]);
        } else if (c.kind === "file") {
          const l = await c.getFile(), A = new Uint8Array(await l.arrayBuffer());
          s.createDataFile(
            _,
            c.name,
            A,
            !0,
            !0,
            !0
          );
        }
        n.splice(n.indexOf(S), 1);
      });
      n.push(S);
    }
    for (; i.length === 0 && n.length > 0; )
      await Promise.any(n);
  }
}
async function Te(s, e, t, r) {
  s.mkdirTree(t);
  const n = [];
  async function i(h, l) {
    await Promise.all(
      s.readdir(h).filter(
        (A) => A !== "." && A !== ".."
      ).map(async (A) => {
        const f = oe(h, A);
        if (!ct(s, f)) {
          n.push([l, f, A]);
          return;
        }
        const N = await l.getDirectoryHandle(A, {
          create: !0
        });
        return await i(f, N);
      })
    );
  }
  await i(t, e);
  let a = 0;
  const _ = r && lt(r, 100), c = 100, S = /* @__PURE__ */ new Set();
  try {
    for (const [h, l, A] of n) {
      const f = F(
        h,
        A,
        s,
        l
      ).then(() => {
        a++, S.delete(f), _ == null || _({
          files: a,
          total: n.length
        });
      });
      S.add(f), S.size >= c && (await Promise.race(S), _ == null || _({
        files: a,
        total: n.length
      }));
    }
  } finally {
    await Promise.allSettled(S);
  }
}
function ct(s, e) {
  return s.isDir(s.lookupPath(e, { follow: !0 }).node.mode);
}
async function F(s, e, t, r) {
  let n;
  try {
    n = t.readFile(r, {
      encoding: "binary"
    });
  } catch {
    return;
  }
  const i = await s.getFileHandle(e, { create: !0 }), a = i.createWritable !== void 0 ? (
    // Google Chrome, Firefox, probably more browsers
    await i.createWritable()
  ) : (
    // Safari
    await i.createSyncAccessHandle()
  );
  try {
    await a.truncate(0), await a.write(n);
  } finally {
    await a.close();
  }
}
function St(s, e, t) {
  const r = [], n = be(s, t, (_) => {
    r.push(_);
  }), i = new Ct(s, e, t);
  async function a() {
    const _ = await s.semaphore.acquire();
    try {
      for (; r.length; )
        await i.processEntry(r.shift());
    } finally {
      _();
    }
  }
  return s.addEventListener("request.end", a), function() {
    n(), s.removeEventListener("request.end", a);
  };
}
class Ct {
  constructor(e, t, r) {
    this.php = e, this.opfs = t, this.memfsRoot = ae(r);
  }
  toOpfsPath(e) {
    return ae(e.substring(this.memfsRoot.length));
  }
  async processEntry(e) {
    if (!e.path.startsWith(this.memfsRoot) || e.path === this.memfsRoot)
      return;
    const t = this.toOpfsPath(e.path), r = await _e(this.opfs, t), n = ht(t);
    if (n)
      try {
        if (e.operation === "DELETE")
          try {
            await r.removeEntry(n, {
              recursive: !0
            });
          } catch {
          }
        else if (e.operation === "CREATE")
          e.nodeType === "directory" ? await r.getDirectoryHandle(n, {
            create: !0
          }) : await r.getFileHandle(n, {
            create: !0
          });
        else if (e.operation === "WRITE")
          await F(
            r,
            n,
            this.php[q].FS,
            e.path
          );
        else if (e.operation === "RENAME" && e.toPath.startsWith(this.memfsRoot)) {
          const i = this.toOpfsPath(e.toPath), a = await _e(
            this.opfs,
            i
          );
          if (e.nodeType === "directory") {
            const _ = await a.getDirectoryHandle(
              n,
              {
                create: !0
              }
            );
            await Te(
              this.php[q].FS,
              _,
              e.toPath
            ), await r.removeEntry(n, {
              recursive: !0
            });
          } else {
            try {
              await r.removeEntry(n);
            } catch {
            }
            await F(
              a,
              Re(i),
              this.php[q].FS,
              e.toPath
            );
          }
        }
      } catch (i) {
        throw v.log({ entry: e, name: n }), v.error(i), i;
      }
  }
}
function ae(s) {
  return s.replace(/\/$/, "").replace(/\/\/+/g, "/");
}
function ht(s) {
  return s.substring(s.lastIndexOf("/") + 1);
}
async function _e(s, e) {
  const t = e.replace(/^\/+|\/+$/g, "").replace(/\/+/, "/");
  if (!t)
    return s;
  const r = t.split("/");
  let n = s;
  for (let i = 0; i < r.length - 1; i++) {
    const a = r[i];
    n = await n.getDirectoryHandle(a, { create: !0 });
  }
  return n;
}
function lt(s, e) {
  let t = 0, r, n;
  return function(...a) {
    n = a;
    const _ = Date.now() - t;
    if (r === void 0) {
      const c = Math.max(0, e - _);
      r = setTimeout(() => {
        r = void 0, t = Date.now(), s(...n);
      }, c);
    }
  };
}
export {
  yt as certificateToPEM,
  pt as consumeAPI,
  Dt as createDirectoryHandleMountHandler,
  wt as exposeAPI,
  Qe as fetchWithCorsProxy,
  Ye as generateCertificate,
  Be as getPHPLoaderModule,
  gt as loadWebRuntime,
  Lt as privateKeyToPEM,
  Kt as setupPostMessageRelay,
  It as spawnPHPWorkerThread
};
//# sourceMappingURL=index.js.map
