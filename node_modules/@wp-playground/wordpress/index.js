import { phpVars as _, joinPaths as r, phpVar as l } from "@php-wasm/util";
import { createMemoizedFetch as c, unzipFile as p } from "@wp-playground/common";
import { PHPRequestHandler as h, PHP as g, setPhpIniEntries as $, writeFiles as w, proxyFileSystem as m, rotatePHPRuntime as b, withPHPIniValues as y } from "@php-wasm/universal";
import { logger as k } from "@php-wasm/logger";
const P = `<?php

/**
 * Rewrites the wp-config.php file to ensure specific constants are defined
 * with specific values.
 * 
 * Example:
 * 
 * \`\`\`php
 * <?php
 * define('WP_DEBUG', true);
 * // The third define() argument is also supported:
 * define('SAVEQUERIES', false, true);
 * 
 * // Expression
 * define(true ? 'WP_DEBUG_LOG' : 'WP_DEBUG_LOG', 123);
 * 
 * // Guarded expressions shouldn't be wrapped twice
 * if(!defined(1 ? 'A' : 'B')) {
 *     define(1 ? 'A' : 'B', 0);
 * }
 * 
 * // More advanced expression
 * define((function() use($x) {
 *     return [$x, 'a'];
 * })(), 123);
 * \`\`\`
 * 
 * Rewritten with
 * 
 *     $constants = [
 *        'WP_DEBUG' => false,
 *        'WP_DEBUG_LOG' => true,
 *        'SAVEQUERIES' => true,
 *        'NEW_CONSTANT' => "new constant",
 *     ];
 * 
 * \`\`\`php
 * <?php
 * define('WP_DEBUG_LOG',true);
 * define('NEW_CONSTANT','new constant');
 * ?><?php
 * define('WP_DEBUG',false);
 * // The third define() argument is also supported:
 * define('SAVEQUERIES',true, true);
 * 
 * // Expression
 * if(!defined($const ? 'WP_DEBUG_LOG' : 'WP_DEBUG_LOG')) {
 *      define($const ? 'WP_DEBUG_LOG' : 'WP_DEBUG_LOG', 123);
 * }
 * 
 * // Guarded expressions shouldn't be wrapped twice
 * if(!defined(1 ? 'A' : 'B')) {
 *     define(1 ? 'A' : 'B', 0);
 * }
 * 
 * // More advanced expression
 * if(!defined((function() use($x) {
 *    return [$x, 'a'];
 * })())) {
 *     define((function() use($x) {
 *         return [$x, 'a'];
 *     })(), 123);
 * }
 * \`\`\`
 *
 * @param mixed $content              A PHP file content.
 * @param array $constants            An array of constants to define.
 * @param bool  $when_already_defined Optional. What to do if the constant is already defined.
 *                                    Possible values are:
 *                                      'rewrite' - Rewrite the constant, using the new value.
 *                                      'skip'    - Skip the definition, keeping the existing value.
 *                                    Default: 'rewrite'
 * @return string
 */
function rewrite_wp_config_to_define_constants($content, $constants = [], $when_already_defined = 'rewrite')
{
    $tokens = array_reverse(token_get_all($content));
    $output = [];
    $defined_expressions = [];

    // Look through all the tokens and find the define calls
    do {
        $buffer = [];
        $name_buffer = [];
        $value_buffer = [];
        $third_arg_buffer = [];

        // Capture everything until the define call into output.
        // Capturing the define call into a buffer.
        // Example:
        //     <?php echo 'a'; define  (
        //     ^^^^^^^^^^^^^^^^^^^^^^
        //           output   |buffer
        while ($token = array_pop($tokens)) {
            if (is_array($token) && $token[0] === T_STRING && (strtolower($token[1]) === 'define' || strtolower($token[1]) === 'defined')) {
                $buffer[] = $token;
                break;
            }
            $output[] = $token;
        }

        // Maybe we didn't find a define call and reached the end of the file?
        if (!count($tokens)) {
            break;
        }

        // Keep track of the "defined" expressions that are already accounted for
        if($token[1] === 'defined') {
            $output[] = $token;
            $defined_expression = [];
            $open_parenthesis = 0;
            // Capture everything up to the opening parenthesis, including the parenthesis
            // e.g. defined  (
            //           ^^^^
            while ($token = array_pop($tokens)) {
                $output[] = $token;
                if ($token === "(") {
                    ++$open_parenthesis;
                    break;
                }
            }

            // Capture everything up to the closing parenthesis, including the parenthesis
            // e.g. defined  (
            //           ^^^^
            while ($token = array_pop($tokens)) {
                $output[] = $token;
                if ($token === ")") {
                    --$open_parenthesis;
                }
                if ($open_parenthesis === 0) {
                    break;
                }
                $defined_expression[] = $token;
            }

            $defined_expressions[] = stringify_tokens(skip_whitespace($defined_expression));
            continue;
        }

        // Capture everything up to the opening parenthesis, including the parenthesis
        // e.g. define  (
        //           ^^^^
        while ($token = array_pop($tokens)) {
            $buffer[] = $token;
            if ($token === "(") {
                break;
            }
        }

        // Capture the first argument – it's the first expression after the opening
        // parenthesis and before the comma:
        // Examples:
        //     define("WP_DEBUG", true);
        //            ^^^^^^^^^^^
        //
        //     define(count([1,2]) > 2 ? 'WP_DEBUG' : 'FOO', true);
        //            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        $open_parenthesis = 0;
        while ($token = array_pop($tokens)) {
            $buffer[] = $token;
            if ($token === "(" || $token === "[" || $token === "{") {
                ++$open_parenthesis;
            } elseif ($token === ")" || $token === "]" || $token === "}") {
                --$open_parenthesis;
            } elseif ($token === "," && $open_parenthesis === 0) {
                break;
            }

            // Don't capture the comma as a part of the constant name
            $name_buffer[] = $token;
        }

        // Capture everything until the closing parenthesis
        //     define("WP_DEBUG", true);
        //                       ^^^^^^
        $open_parenthesis = 0;
        $is_second_argument = true;
        while ($token = array_pop($tokens)) {
            $buffer[] = $token;
            if ($token === ")" && $open_parenthesis === 0) {
                // Final parenthesis of the define call.
                break;
            } else if ($token === "(" || $token === "[" || $token === "{") {
                ++$open_parenthesis;
            } elseif ($token === ")" || $token === "]" || $token === "}") {
                --$open_parenthesis;
            } elseif ($token === "," && $open_parenthesis === 0) {
                // This define call has more than 2 arguments! The third one is the
                // boolean value indicating $is_case_insensitive. Let's continue capturing
                // to $third_arg_buffer.
                $is_second_argument = false;
            }
            if ($is_second_argument) {
                $value_buffer[] = $token;
            } else {
                $third_arg_buffer[] = $token;
            }
        }

        // Capture until the semicolon
        //     define("WP_DEBUG", true)  ;
        //                             ^^^
        while ($token = array_pop($tokens)) {
            $buffer[] = $token;
            if ($token === ";") {
                break;
            }
        }

        // Decide whether $name_buffer is a constant name or an expression
        $name_token = null;
        $name_token_index = $token;
        $name_is_literal = true;
        foreach ($name_buffer as $k => $token) {
            if (is_array($token)) {
                if ($token[0] === T_WHITESPACE || $token[0] === T_COMMENT || $token[0] === T_DOC_COMMENT) {
                    continue;
                } else if ($token[0] === T_STRING || $token[0] === T_CONSTANT_ENCAPSED_STRING) {
                    $name_token = $token;
                    $name_token_index = $k;
                } else {
                    $name_is_literal = false;
                    break;
                }
            } else if ($token !== "(" && $token !== ")") {
                $name_is_literal = false;
                break;
            }
        }

        // We can't handle expressions as constant names. Let's wrap that define
        // call in an if(!defined()) statement, just in case it collides with
        // a constant name.
        if (!$name_is_literal) {
            // Ensure the defined expression is not already accounted for
            foreach ($defined_expressions as $defined_expression) {
                if ($defined_expression === stringify_tokens(skip_whitespace($name_buffer))) {
                    $output = array_merge($output, $buffer);
                    continue 2;
                }
            }
            $output = array_merge(
                $output,
                ["if(!defined("],
                $name_buffer,
                [")) {\\n     "],
                ['define('],
                $name_buffer,
                [','],
                $value_buffer,
                $third_arg_buffer,
                [");"],
                ["\\n}\\n"]
            );
            continue;
        }

        // Yay, we have a literal constant name in the buffer now. Let's
        // get its value:
        $name = eval('return ' . $name_token[1] . ';');

        // If the constant name is not in the list of constants we're looking,
        // we can ignore it.
        if (!array_key_exists($name, $constants)) {
            $output = array_merge($output, $buffer);
            continue;
        }

        // If "$when_already_defined" is set to 'skip', ignore the definition, and
		// remove the constant from the list so it doesn't get added to the output.
        if ('skip' === $when_already_defined) {
            $output = array_merge($output, $buffer);
            unset($constants[$name]);
            continue;
        }

        // We now have a define() call that defines a constant we're looking for.
        // Let's rewrite its value to the one 
        $output = array_merge(
            $output,
            ['define('],
            $name_buffer,
            [','],
            [var_export($constants[$name], true)],
            $third_arg_buffer,
            [");"]
        );

        // Remove the constant from the list so we can process any remaining
        // constants later.
        unset($constants[$name]);
    } while (count($tokens));

    // Add any constants that weren't found in the file
    if (count($constants)) {
        $prepend = [
            "<?php \\n"
        ];
        foreach ($constants as $name => $value) {
            $prepend = array_merge(
                $prepend,
                [
                    "define(",
                    var_export($name, true),
                    ',',
                    var_export($value, true),
                    ");\\n"
                ]
            );
        }
        $prepend[] = "?>";
        $output = array_merge(
            $prepend,
            $output
        );
    }

    // Translate the output tokens back into a string
    return stringify_tokens($output);
}

function stringify_tokens($tokens) {
    $output = '';
    foreach ($tokens as $token) {
        if (is_array($token)) {
            $output .= $token[1];
        } else {
            $output .= $token;
        }
    }
    return $output;
}

function skip_whitespace($tokens) {
    $output = [];
    foreach ($tokens as $token) {
        if (is_array($token) && ($token[0] === T_WHITESPACE || $token[0] === T_COMMENT || $token[0] === T_DOC_COMMENT)) {
            continue;
        }
        $output[] = $token;
    }
    return $output;
}
`;
async function E(e, i, t, n = "rewrite") {
  const o = _({ wpConfigPath: i, constants: t, whenAlreadyDefined: n });
  if ((await e.run({
    code: `<?php ob_start(); ?>
			${P}
			$wp_config_path = ${o.wpConfigPath};
			$wp_config = file_get_contents($wp_config_path);
			$new_wp_config = rewrite_wp_config_to_define_constants($wp_config, ${o.constants}, ${o.whenAlreadyDefined});
			$return_value = file_put_contents($wp_config_path, $new_wp_config);
			ob_clean();
			echo false === $return_value ? '0' : '1';
			ob_end_flush();
		`
  })).text !== "1")
    throw new Error("Failed to rewrite constants in wp-config.php.");
}
async function T(e, i) {
  const t = r(i, "wp-config.php"), n = {
    DB_NAME: "wordpress"
  };
  !e.fileExists(t) && e.fileExists(r(i, "wp-config-sample.php")) && await e.writeFile(
    t,
    await e.readFileAsBuffer(
      r(i, "wp-config-sample.php")
    )
  ), await E(e, t, n, "skip");
}
async function N(e) {
  var o, d;
  async function i(a, u) {
    const s = new g(await e.createPhpRuntime());
    return e.sapiName && s.setSapiName(e.sapiName), a && (s.requestHandler = a), e.phpIniEntries && $(s, e.phpIniEntries), u ? (await L(s), await w(s, "/", e.createFiles || {}), await I(
      s,
      r(new URL(e.siteUrl).pathname, "phpinfo.php")
    )) : m(await a.getPrimaryPhp(), s, [
      "/tmp",
      a.documentRoot,
      "/internal/shared"
    ]), e.spawnHandler && await s.setSpawnHandler(
      e.spawnHandler(a.processManager)
    ), b({
      php: s,
      cwd: a.documentRoot,
      recreateRuntime: e.createPhpRuntime,
      maxRequests: 400
    }), s;
  }
  const t = new h({
    phpFactory: async ({ isPrimary: a }) => i(t, a),
    documentRoot: e.documentRoot || "/wordpress",
    absoluteUrl: e.siteUrl,
    rewriteRules: x,
    getFileNotFoundAction: e.getFileNotFoundAction ?? S,
    cookieStore: e.cookieStore
  }), n = await t.getPrimaryPhp();
  if ((o = e.hooks) != null && o.beforeWordPressFiles && await e.hooks.beforeWordPressFiles(n), e.wordPressZip && await W(n, await e.wordPressZip), e.constants)
    for (const a in e.constants)
      n.defineConstant(a, e.constants[a]);
  if (n.defineConstant("WP_HOME", e.siteUrl), n.defineConstant("WP_SITEURL", e.siteUrl), await T(n, t.documentRoot), (d = e.hooks) != null && d.beforeDatabaseSetup && await e.hooks.beforeDatabaseSetup(n), e.sqliteIntegrationPluginZip && await U(
    n,
    await e.sqliteIntegrationPluginZip
  ), await f(n) || await R(n), !await f(n))
    throw new Error("WordPress installation has failed.");
  return t;
}
async function f(e) {
  return (await e.run({
    code: `<?php
			ob_start();
			$wp_load = getenv('DOCUMENT_ROOT') . '/wp-load.php';
			if (!file_exists($wp_load)) {
				echo '-1';
				exit;
			}
			require $wp_load;
			ob_clean();
			echo is_blog_installed() ? '1' : '0';
			ob_end_flush();
		`,
    env: {
      DOCUMENT_ROOT: e.documentRoot
    }
  })).text === "1";
}
async function R(e) {
  await y(
    e,
    {
      disable_functions: "fsockopen",
      allow_url_fopen: "0"
    },
    async () => await e.request({
      url: "/wp-admin/install.php?step=2",
      method: "POST",
      body: {
        language: "en",
        prefix: "wp_",
        weblog_title: "My WordPress Website",
        user_name: "admin",
        admin_password: "password",
        // The installation wizard demands typing the same password twice
        admin_password2: "password",
        Submit: "Install WordPress",
        pw_weak: "1",
        admin_email: "admin@localhost.com"
      }
    })
  ), (await e.run({
    code: `<?php
			ob_start();
			$wp_load = getenv('DOCUMENT_ROOT') . '/wp-load.php';
			if (!file_exists($wp_load)) {
				echo '0';
				exit;
			}
			require $wp_load;
			$option_result = update_option(
				'permalink_structure',
				'/%year%/%monthnum%/%day%/%postname%/'
			);
			ob_clean();
			echo $option_result ? '1' : '0';
			ob_end_flush();
		`,
    env: {
      DOCUMENT_ROOT: e.documentRoot
    }
  })).text !== "1" && k.warn("Failed to default to pretty permalinks after WP install.");
}
function S(e) {
  return {
    type: "internal-redirect",
    uri: "/index.php"
  };
}
async function q(e) {
  const n = (await (await e.getPrimaryPhp()).run({
    code: `<?php
			require '${e.documentRoot}/wp-includes/version.php';
			echo $wp_version;
		`
  })).text;
  if (!n)
    throw new Error("Unable to read loaded WordPress version.");
  return v(n);
}
function v(e) {
  if (/-(alpha|beta|RC)\d*-\d+$/.test(e))
    return "nightly";
  if (/-(beta|RC)\d*$/.test(e))
    return "beta";
  const n = e.match(/^(\d+\.\d+)(?:\.\d+)?$/);
  return n !== null ? n[1] : e;
}
const x = [
  {
    match: /^\/(.*?)(\/wp-(content|admin|includes)\/.*)/g,
    replacement: "$2"
  }
];
async function L(e) {
  await e.mkdir("/internal/shared/mu-plugins"), await e.writeFile(
    "/internal/shared/preload/env.php",
    `<?php

        // Allow adding filters/actions prior to loading WordPress.
        // $function_to_add MUST be a string.
        function playground_add_filter( $tag, $function_to_add, $priority = 10, $accepted_args = 1 ) {
            global $wp_filter;
            $wp_filter[$tag][$priority][$function_to_add] = array('function' => $function_to_add, 'accepted_args' => $accepted_args);
        }
        function playground_add_action( $tag, $function_to_add, $priority = 10, $accepted_args = 1 ) {
            playground_add_filter( $tag, $function_to_add, $priority, $accepted_args );
        }

        // Load our mu-plugins after customer mu-plugins
        // NOTE: this means our mu-plugins can't use the muplugins_loaded action!
        playground_add_action( 'muplugins_loaded', 'playground_load_mu_plugins', 0 );
        function playground_load_mu_plugins() {
            // Load all PHP files from /internal/shared/mu-plugins, sorted by filename
            $mu_plugins_dir = '/internal/shared/mu-plugins';
            if(!is_dir($mu_plugins_dir)){
                return;
            }
            $mu_plugins = glob( $mu_plugins_dir . '/*.php' );
            sort( $mu_plugins );
            foreach ( $mu_plugins as $mu_plugin ) {
                require_once $mu_plugin;
            }
        }
    `
  ), await e.writeFile(
    "/internal/shared/mu-plugins/1-auto-login.php",
    `<?php
		/**
		 * Returns the username to auto-login as, if any.
		 * @return string|false
		 */
		function playground_get_username_for_auto_login() {
			/**
			 * Allow users to auto-login as a specific user on their first visit.
			 *
			 * Prevent the auto-login if it already happened by checking for the
			 * playground_auto_login_already_happened cookie.
			 * This is used to allow the user to logout.
			 */
			if ( defined('PLAYGROUND_AUTO_LOGIN_AS_USER') && !isset($_COOKIE['playground_auto_login_already_happened']) ) {
				return PLAYGROUND_AUTO_LOGIN_AS_USER;
			}
			/**
			 * Allow users to auto-login as a specific user by passing the
			 * playground_force_auto_login_as_user GET parameter.
			 */
			if ( defined('PLAYGROUND_FORCE_AUTO_LOGIN_ENABLED') && isset($_GET['playground_force_auto_login_as_user']) ) {
				return $_GET['playground_force_auto_login_as_user'];
			}
			return false;
		}

		/**
		 * Logs the user in on their first visit if the Playground runtime told us to.
		 */
		function playground_auto_login() {
			/**
			 * The redirect should only run if the current PHP request is
			 * a HTTP request. If it's a PHP CLI run, we can't login the user
			 * because logins require cookies which aren't available in the CLI.
			 *
			 * Currently all Playground requests use the "cli" SAPI name
			 * to ensure support for WP-CLI, so the best way to distinguish
			 * between a CLI run and an HTTP request is by checking if the
			 * $_SERVER['REQUEST_URI'] global is set.
			 *
			 * If $_SERVER['REQUEST_URI'] is not set, we assume it's a CLI run.
			 */
			if (empty($_SERVER['REQUEST_URI'])) {
				return;
			}
			$user_name = playground_get_username_for_auto_login();
			if ( false === $user_name ) {
				return;
			}
			if (wp_doing_ajax() || defined('REST_REQUEST')) {
				return;
			}
			if ( is_user_logged_in() ) {
				return;
			}
			$user = get_user_by('login', $user_name);
			if (!$user) {
				return;
			}

			/**
			 * We're about to set cookies and redirect. It will log the user in
			 * if the headers haven't been sent yet.
			 *
			 * However, if they have been sent already – e.g. there a PHP
			 * notice was printed, we'll exit the script with a bunch of errors
			 * on the screen and without the user being logged in. This
			 * will happen on every page load and will effectively make Playground
			 * unusable.
			 *
			 * Therefore, we just won't auto-login if headers have been sent. Maybe
			 * we'll be able to finish the operation in one of the future requests
			 * or maybe not, but at least we won't end up with a permanent white screen.
			 */
			if (headers_sent()) {
				_doing_it_wrong('playground_auto_login', 'Headers already sent, the Playground runtime will not auto-login the user', '1.0.0');
				return;
			}

			/**
			 * This approach is described in a comment on
			 * https://developer.wordpress.org/reference/functions/wp_set_current_user/
			 */
			wp_set_current_user( $user->ID, $user->user_login );
			wp_set_auth_cookie( $user->ID );
			do_action( 'wp_login', $user->user_login, $user );

			setcookie('playground_auto_login_already_happened', '1');

			/**
			 * Confirm that nothing in WordPress, plugins, or filters have finalized
			 * the headers sending phase. See the comment above for more context.
			 */
			if (headers_sent()) {
				_doing_it_wrong('playground_auto_login', 'Headers already sent, the Playground runtime will not auto-login the user', '1.0.0');
				return;
			}

			/**
			 * Reload page to ensure the user is logged in correctly.
			 * WordPress uses cookies to determine if the user is logged in,
			 * so we need to reload the page to ensure the cookies are set.
			 */
			$redirect_url = $_SERVER['REQUEST_URI'];
			/**
			 * Intentionally do not use wp_redirect() here. It removes
			 * %0A and %0D sequences from the URL, which we don't want.
			 * There are valid use-cases for encoded newlines in the query string,
			 * for example html-api-debugger accepts markup with newlines
			 * encoded as %0A via the query string.
			 */
			header( "Location: $redirect_url", true, 302 );
			exit;
		}
		/**
		 * Autologin users from the wp-login.php page.
		 *
		 * The wp hook isn't triggered on
		 **/
		add_action('init', 'playground_auto_login', 1);

		/**
		 * Disable the Site Admin Email Verification Screen for any session started
		 * via autologin.
		 */
		add_filter('admin_email_check_interval', function($interval) {
			if(false === playground_get_username_for_auto_login()) {
				return 0;
			}
			return $interval;
		});
		`
  ), await e.writeFile(
    "/internal/shared/mu-plugins/0-playground.php",
    `<?php
        // Needed because gethostbyname( 'wordpress.org' ) returns
        // a private network IP address for some reason.
        add_filter( 'allowed_redirect_hosts', function( $deprecated = '' ) {
            return array(
                'wordpress.org',
                'api.wordpress.org',
                'downloads.wordpress.org',
            );
        } );

		// Support pretty permalinks
        add_filter( 'got_url_rewrite', '__return_true' );

        // Create the fonts directory if missing
        if(!file_exists(WP_CONTENT_DIR . '/fonts')) {
            mkdir(WP_CONTENT_DIR . '/fonts');
        }

        $log_file = WP_CONTENT_DIR . '/debug.log';
        define('ERROR_LOG_FILE', $log_file);
        ini_set('error_log', $log_file);
        ?>`
  ), await e.writeFile(
    "/internal/shared/preload/error-handler.php",
    `<?php
		(function() {
			$playground_consts = [];
			if(file_exists('/internal/shared/consts.json')) {
				$playground_consts = @json_decode(file_get_contents('/internal/shared/consts.json'), true) ?: [];
				$playground_consts = array_keys($playground_consts);
			}
			set_error_handler(function($severity, $message, $file, $line) use($playground_consts) {
				/**
				 * Networking support in Playground registers a http_api_transports filter.
				 *
				 * This filter is deprecated, and no longer actively used, but is needed for wp_http_supports().
				 * @see https://core.trac.wordpress.org/ticket/37708
				 */
				if (
					strpos($message, "http_api_transports") !== false &&
					strpos($message, "since version 6.4.0 with no alternative available") !== false
				) {
					return;
				}
				/**
				 * Playground defines some constants upfront, and some of them may be redefined
				 * in wp-config.php. For example, SITE_URL or WP_DEBUG. This is expected and
				 * we want Playground constants to take priority without showing warnings like:
				 *
				 * Warning: Constant SITE_URL already defined in
				 */
				if (strpos($message, "already defined") !== false) {
					foreach($playground_consts as $const) {
						if(strpos($message, "Constant $const already defined") !== false) {
							return;
						}
					}
				}
				/**
				 * Don't complain about network errors when not connected to the network.
				 */
				if (
					(
						! defined('USE_FETCH_FOR_REQUESTS') ||
						! USE_FETCH_FOR_REQUESTS
					) &&
					strpos($message, "WordPress could not establish a secure connection to WordPress.org") !== false)
				{
					return;
				}
				return false;
			});
		})();`
  );
}
async function I(e, i = "/phpinfo.php") {
  await e.writeFile(
    "/internal/shared/preload/phpinfo.php",
    `<?php
    // Render PHPInfo if the requested page is /phpinfo.php
    if ( ${l(i)} === $_SERVER['REQUEST_URI'] ) {
        phpinfo();
        exit;
    }
    `
  );
}
async function U(e, i) {
  await e.isDir("/tmp/sqlite-database-integration") && await e.rmdir("/tmp/sqlite-database-integration", {
    recursive: !0
  }), await e.mkdir("/tmp/sqlite-database-integration"), await p(e, i, "/tmp/sqlite-database-integration");
  const t = "/internal/shared/sqlite-database-integration", n = `/tmp/sqlite-database-integration/${(await e.listFiles("/tmp/sqlite-database-integration"))[0]}`;
  await e.mv(n, t), e.defineConstant("WP_SQLITE_AST_DRIVER", !0), await e.defineConstant("SQLITE_MAIN_FILE", "1");
  const d = (await e.readFileAsText(
    r(t, "db.copy")
  )).replace(
    "'{SQLITE_IMPLEMENTATION_FOLDER_PATH}'",
    l(t)
  ).replace(
    "'{SQLITE_PLUGIN}'",
    l(r(t, "load.php"))
  ), a = r(await e.documentRoot, "wp-content/db.php"), u = `<?php
	// Do not preload this if WordPress comes with a custom db.php file.
	if(file_exists(${l(a)})) {
		return;
	}
	?>`, s = "/internal/shared/mu-plugins/sqlite-database-integration.php";
  await e.writeFile(s, u + d), await e.writeFile(
    "/internal/shared/preload/0-sqlite.php",
    u + `<?php

/**
 * Loads the SQLite integration plugin before WordPress is loaded
 * and without creating a drop-in "db.php" file.
 *
 * Technically, it creates a global $wpdb object whose only two
 * purposes are to:
 *
 * * Exist – because the require_wp_db() WordPress function won't
 *           connect to MySQL if $wpdb is already set.
 * * Load the SQLite integration plugin the first time it's used
 *   and replace the global $wpdb reference with the SQLite one.
 *
 * This lets Playground keep the WordPress installation clean and
 * solves dillemas like:
 *
 * * Should we include db.php in Playground exports?
 * * Should we remove db.php from Playground imports?
 * * How should we treat stale db.php from long-lived OPFS sites?
 *
 * @see https://github.com/WordPress/wordpress-playground/discussions/1379 for
 *      more context.
 */
class Playground_SQLite_Integration_Loader {
	public function __call($name, $arguments) {
		$this->load_sqlite_integration();
		if($GLOBALS['wpdb'] === $this) {
			throw new Exception('Infinite loop detected in $wpdb – SQLite integration plugin could not be loaded');
		}
		return call_user_func_array(
			array($GLOBALS['wpdb'], $name),
			$arguments
		);
	}
	public function __get($name) {
		$this->load_sqlite_integration();
		if($GLOBALS['wpdb'] === $this) {
			throw new Exception('Infinite loop detected in $wpdb – SQLite integration plugin could not be loaded');
		}
		return $GLOBALS['wpdb']->$name;
	}
	public function __set($name, $value) {
		$this->load_sqlite_integration();
		if($GLOBALS['wpdb'] === $this) {
			throw new Exception('Infinite loop detected in $wpdb – SQLite integration plugin could not be loaded');
		}
		$GLOBALS['wpdb']->$name = $value;
	}
    protected function load_sqlite_integration() {
        require_once ${l(s)};
    }
}
$wpdb = $GLOBALS['wpdb'] = new Playground_SQLite_Integration_Loader();

/**
 * WordPress is capable of using a preloaded global $wpdb. However, if
 * it cannot find the drop-in db.php plugin it still checks whether
 * the mysqli_connect() function exists even though it's not used.
 *
 * What WordPress demands, Playground shall provide.
 */
if(!function_exists('mysqli_connect')) {
	function mysqli_connect() {}
}

		`
  ), await e.writeFile(
    "/internal/shared/mu-plugins/sqlite-test.php",
    `<?php
		global $wpdb;
		if(!($wpdb instanceof WP_SQLite_DB)) {
			var_dump(isset($wpdb));
			die("SQLite integration not loaded " . get_class($wpdb));
		}
		`
  );
}
async function W(e, i) {
  e.mkdir("/tmp/unzipped-wordpress"), await p(e, i, "/tmp/unzipped-wordpress"), e.fileExists("/tmp/unzipped-wordpress/wordpress.zip") && await p(
    e,
    "/tmp/unzipped-wordpress/wordpress.zip",
    "/tmp/unzipped-wordpress"
  );
  let t = e.fileExists("/tmp/unzipped-wordpress/wordpress") ? "/tmp/unzipped-wordpress/wordpress" : e.fileExists("/tmp/unzipped-wordpress/build") ? "/tmp/unzipped-wordpress/build" : "/tmp/unzipped-wordpress";
  if (!e.fileExists(r(t, "wp-config-sample.php"))) {
    const n = e.listFiles(t);
    if (n.length) {
      const o = n[0];
      e.fileExists(
        r(t, o, "wp-config-sample.php")
      ) && (t = r(t, o));
    }
  }
  if (e.isDir(e.documentRoot) && O(e.documentRoot, e)) {
    for (const n of e.listFiles(t)) {
      const o = r(t, n), d = r(e.documentRoot, n);
      e.mv(o, d);
    }
    e.rmdir(t, { recursive: !0 });
  } else
    e.mv(t, e.documentRoot);
  !e.fileExists(r(e.documentRoot, "wp-config.php")) && e.fileExists(r(e.documentRoot, "wp-config-sample.php")) && e.writeFile(
    r(e.documentRoot, "wp-config.php"),
    e.readFileAsText(
      r(e.documentRoot, "/wp-config-sample.php")
    )
  );
}
function O(e, i) {
  const t = i.listFiles(e);
  return t.length === 0 || t.length === 1 && // TODO: use a constant from a site storage package
  t[0] === "playground-site-metadata.json";
}
const C = c(fetch);
async function B(e = "latest") {
  if (e.startsWith("https://") || e.startsWith("http://")) {
    const n = await crypto.subtle.digest(
      "SHA-1",
      new TextEncoder().encode(e)
    ), o = Array.from(new Uint8Array(n)).map((d) => d.toString(16).padStart(2, "0")).join("");
    return {
      releaseUrl: e,
      version: "custom-" + o.substring(0, 8),
      source: "inferred"
    };
  } else if (e === "trunk" || e === "nightly")
    return {
      releaseUrl: "https://wordpress.org/nightly-builds/wordpress-latest.zip",
      version: "nightly-" + (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
      source: "inferred"
    };
  let t = await (await C(
    "https://api.wordpress.org/core/version-check/1.7/?channel=beta"
  )).json();
  t = t.offers.filter(
    (n) => n.response === "autoupdate"
  );
  for (const n of t) {
    if (e === "beta" && n.version.includes("beta"))
      return {
        releaseUrl: n.download,
        version: n.version,
        source: "api"
      };
    if (e === "latest" && !n.version.includes("beta"))
      return {
        releaseUrl: n.download,
        version: n.version,
        source: "api"
      };
    if (n.version.substring(0, e.length) === e)
      return {
        releaseUrl: n.download,
        version: n.version,
        source: "api"
      };
  }
  return {
    releaseUrl: `https://wordpress.org/wordpress-${e}.zip`,
    version: e,
    source: "inferred"
  };
}
export {
  N as bootWordPress,
  E as defineWpConfigConstants,
  T as ensureWpConfig,
  S as getFileNotFoundActionForWordPress,
  q as getLoadedWordPressVersion,
  I as preloadPhpInfoRoute,
  U as preloadSqliteIntegration,
  B as resolveWordPressRelease,
  L as setupPlatformLevelMuPlugins,
  W as unzipWordPress,
  v as versionStringToLoadedWordPressVersion,
  x as wordPressRewriteRules
};
//# sourceMappingURL=index.js.map
