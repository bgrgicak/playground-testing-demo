import g from "fs";
import b, { basename as S } from "path";
import z from "express";
import { PHPResponse as C } from "@php-wasm/universal";
import { logger as c, errorLogPath as x } from "@php-wasm/logger";
import { runBlueprintSteps as D, compileBlueprint as L } from "@wp-playground/blueprints";
import { EmscriptenDownloadMonitor as A, ProgressTracker as U } from "@php-wasm/progress";
import { loadNodeRuntime as _, createNodeFsMountHandler as q } from "@php-wasm/node";
import { zipDirectory as M, RecommendedPHPVersion as T } from "@wp-playground/common";
import { resolveWordPressRelease as Z, bootWordPress as k } from "@wp-playground/wordpress";
import { rootCertificates as j } from "tls";
import P from "fs-extra";
import G from "os";
async function O(e) {
  const n = z(), s = await new Promise((l, i) => {
    const o = n.listen(e.port, () => {
      const p = o.address();
      p === null || typeof p == "string" ? i(new Error("Server address is not available")) : l(o);
    });
  });
  n.use("/", async (l, i) => {
    const o = await e.handleRequest({
      url: l.url,
      headers: V(l),
      method: l.method,
      body: await N(l)
    });
    i.statusCode = o.httpStatusCode;
    for (const p in o.headers)
      i.setHeader(p, o.headers[p]);
    i.end(o.bytes);
  });
  const m = s.address().port;
  return await e.onBind(s, m);
}
const N = async (e) => await new Promise((n) => {
  const s = [];
  e.on("data", (f) => {
    s.push(f);
  }), e.on("end", () => {
    n(new Uint8Array(Buffer.concat(s)));
  });
}), V = (e) => {
  const n = {};
  if (e.rawHeaders && e.rawHeaders.length)
    for (let s = 0; s < e.rawHeaders.length; s += 2)
      n[e.rawHeaders[s].toLowerCase()] = e.rawHeaders[s + 1];
  return n;
}, $ = b.join(G.homedir(), ".wordpress-playground");
async function Y(e) {
  return await W(
    "https://github.com/WordPress/sqlite-database-integration/archive/refs/heads/main.zip",
    "sqlite.zip",
    e
  );
}
async function W(e, n, s) {
  const f = b.join($, n);
  return P.existsSync(f) || (P.ensureDirSync($), await J(e, f, s)), H(f);
}
async function J(e, n, s) {
  const m = (await s.monitorFetch(fetch(e))).body.getReader(), l = `${n}.partial`, i = P.createWriteStream(l);
  for (; ; ) {
    const { done: o, value: p } = await m.read();
    if (p && i.write(p), o)
      break;
  }
  i.close(), i.closed || await new Promise((o, p) => {
    i.on("finish", (t) => {
      t ? (P.removeSync(l), p(t)) : (P.renameSync(l, n), o(null));
    });
  });
}
function H(e, n) {
  return new File([P.readFileSync(e)], n ?? S(e));
}
async function ce(e) {
  e.quiet && (c.handlers = []);
  async function n(t) {
    const { php: a, reap: d } = await o.processManager.acquirePHPInstance();
    try {
      await a.run({
        code: `<?php
				$zip = new ZipArchive();
				if(false === $zip->open('/tmp/build.zip', ZipArchive::CREATE | ZipArchive::OVERWRITE)) {
					throw new Exception('Failed to create ZIP');
				}
				$files = new RecursiveIteratorIterator(
					new RecursiveDirectoryIterator('/wordpress')
				);
				foreach ($files as $file) {
					echo $file . PHP_EOL;
					if (!$file->isFile()) {
						continue;
					}
					$zip->addFile($file->getPathname(), $file->getPathname());
				}
				$zip->close();

			`
      });
      const r = a.readFileAsBuffer("/tmp/build.zip");
      g.writeFileSync(t, r);
    } finally {
      d();
    }
  }
  function s(t, a) {
    const d = a.map((r) => {
      const [h, w] = r.split(":");
      return {
        hostPath: b.resolve(process.cwd(), h),
        vfsPath: w
      };
    });
    for (const r of d)
      t.mkdir(r.vfsPath), t.mount(r.vfsPath, q(r.hostPath));
  }
  function f() {
    let t;
    e.blueprint ? t = e.blueprint : t = {
      preferredVersions: {
        php: e.php ?? T,
        wp: e.wp ?? "latest"
      },
      login: e.login
    };
    const a = new U();
    let d = "", r = !1;
    return a.addEventListener("progress", (h) => {
      if (r)
        return;
      r = h.detail.progress === 100;
      const w = Math.floor(h.detail.progress);
      d = h.detail.caption || d || "Running the Blueprint";
      const v = `${d.trim()} â€“ ${w}%`;
      e.quiet || l(
        process.stdout,
        v,
        r
      );
    }), L(t, {
      progress: a
    });
  }
  let m = "";
  function l(t, a, d) {
    a !== m && (m = a, t.isTTY ? (t.cursorTo(0), t.write(a), t.clearLine(1), d && t.write(`
`)) : t.write(`${a}
`));
  }
  const i = f();
  let o, p = !1;
  return c.log("Starting a PHP server..."), O({
    port: e.port,
    onBind: async (t, a) => {
      const d = `http://127.0.0.1:${a}`;
      c.log(`Setting up WordPress ${e.wp}`);
      let r;
      const h = new A();
      if (!e.skipWordPressSetup) {
        let u = !1;
        h.addEventListener("progress", (y) => {
          if (u)
            return;
          const { loaded: I, total: F } = y.detail, B = Math.floor(
            Math.min(100, 100 * I / F)
          );
          u = B === 100, e.quiet || l(
            process.stdout,
            `Downloading WordPress ${B}%...`,
            u
          );
        }), r = await Z(e.wp);
      }
      c.log(
        `Resolved WordPress release URL: ${r?.releaseUrl}`
      );
      const w = r && b.join(
        $,
        `prebuilt-wp-content-for-wp-${r.version}.zip`
      ), v = r ? g.existsSync(w) ? H(w) : await W(
        r.releaseUrl,
        `${r.version}.zip`,
        h
      ) : void 0, E = {
        WP_DEBUG: !0,
        WP_DEBUG_LOG: !0,
        WP_DEBUG_DISPLAY: !1
      };
      c.log("Booting WordPress..."), o = await k({
        siteUrl: d,
        createPhpRuntime: async () => await _(i.versions.php),
        wordPressZip: v,
        sqliteIntegrationPluginZip: Y(h),
        sapiName: "cli",
        createFiles: {
          "/internal/shared/ca-bundle.crt": j.join(`
`)
        },
        constants: E,
        phpIniEntries: {
          "openssl.cafile": "/internal/shared/ca-bundle.crt",
          allow_url_fopen: "1",
          disable_functions: ""
        },
        hooks: {
          async beforeWordPressFiles(u) {
            e.mountBeforeInstall && s(u, e.mountBeforeInstall);
          }
        }
      }), c.log("Booted!");
      const R = await o.getPrimaryPhp();
      try {
        if (r && !e.mountBeforeInstall && !g.existsSync(w) && (c.log(
          "Caching preinstalled WordPress for the next boot..."
        ), g.writeFileSync(
          w,
          await M(R, "/wordpress")
        ), c.log("Cached!")), e.mount && s(R, e.mount), p = !0, i) {
          const { php: u, reap: y } = await o.processManager.acquirePHPInstance();
          try {
            c.log("Running the Blueprint..."), await D(i, u), c.log("Finished running the blueprint");
          } finally {
            y();
          }
        }
        return e.command === "build-snapshot" ? (await n(e.outfile), c.log(`WordPress exported to ${e.outfile}`), process.exit(0)) : e.command === "run-blueprint" ? (c.log("Blueprint executed"), process.exit(0)) : c.log(`WordPress is running on ${d}`), { requestHandler: o, server: t };
      } catch (u) {
        if (!e.debug)
          throw u;
        const y = R.readFileAsText(x);
        throw new Error(y, { cause: u });
      }
    },
    async handleRequest(t) {
      return p ? await o.request(t) : C.forHttpCode(
        502,
        "WordPress is not ready yet"
      );
    }
  });
}
export {
  ce as runCLI
};
//# sourceMappingURL=index.js.map
