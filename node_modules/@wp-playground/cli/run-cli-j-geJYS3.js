import { logger as d, errorLogPath as M } from "@php-wasm/logger";
import { loadNodeRuntime as z, createNodeFsMountHandler as A } from "@php-wasm/node";
import { ProgressTracker as L, EmscriptenDownloadMonitor as q } from "@php-wasm/progress";
import { PHPResponse as T } from "@php-wasm/universal";
import { isBlueprintBundle as U, compileBlueprint as Z, runBlueprintSteps as V } from "@wp-playground/blueprints";
import { RecommendedPHPVersion as j, zipDirectory as G } from "@wp-playground/common";
import { resolveWordPressRelease as O, bootWordPress as Y } from "@wp-playground/wordpress";
import m from "fs";
import b, { basename as g, join as B } from "path";
import { rootCertificates as J } from "tls";
import y from "fs-extra";
import K from "os";
import Q from "express";
function X(e) {
  const t = process.cwd(), n = [...e.mount || []], c = [...e.mountBeforeInstall || []];
  if (C(t)) {
    const r = g(t);
    n.push(`${t}:/wordpress/wp-content/plugins/${r}`);
  } else if (H(t)) {
    const r = g(t);
    n.push(`${t}:/wordpress/wp-content/themes/${r}`);
  } else if (I(t))
    n.push(...F(t));
  else if (R(t)) {
    const r = m.readdirSync(t), s = [];
    for (const l of r)
      l.startsWith("wp-content") || s.push(`${t}/${l}:/wordpress/${l}`);
    c.push(
      ...s,
      ...F(B(t, "wp-content"))
    );
  } else
    n.push(`${t}:/wordpress`);
  const p = e.blueprint || {};
  p.steps = [...p.steps || [], ...ee(t)];
  const a = e.skipWordPressSetup || R(t);
  return {
    ...e,
    blueprint: p,
    mount: n,
    mountBeforeInstall: c,
    skipWordPressSetup: a
  };
}
function R(e) {
  const t = m.readdirSync(e);
  return t.includes("wp-admin") && t.includes("wp-includes") && t.includes("wp-content");
}
function I(e) {
  const t = m.readdirSync(e);
  return t.includes("themes") || t.includes("plugins") || t.includes("mu-plugins") || t.includes("uploads");
}
function H(e) {
  if (!m.readdirSync(e).includes("style.css"))
    return !1;
  const n = m.readFileSync(B(e, "style.css"), "utf8");
  return !!/^(?:[ \t]*<\?php)?[ \t/*#@]*Theme Name:(.*)$/im.exec(n);
}
function C(e) {
  const t = m.readdirSync(e), n = /^(?:[ \t]*<\?php)?[ \t/*#@]*Plugin Name:(.*)$/im;
  return !!t.filter((p) => p.endsWith(".php")).find((p) => {
    const a = m.readFileSync(B(e, p), "utf8");
    return !!n.exec(a);
  });
}
function F(e) {
  return m.readdirSync(e).filter((n) => !n.startsWith("index.php")).map(
    (n) => `${e}/${n}:/wordpress/wp-content/${n}`
  );
}
function ee(e) {
  return C(e) ? [
    {
      step: "activatePlugin",
      pluginPath: `/wordpress/wp-content/plugins/${g(e)}`
    }
  ] : H(e) ? [
    {
      step: "activateTheme",
      themeFolderName: g(e)
    }
  ] : I(e) || R(e) ? [
    {
      step: "runPHP",
      code: `<?php
					require_once '/wordpress/wp-load.php';
					$theme = wp_get_theme();
					if (!$theme->exists()) {
						$themes = wp_get_themes();
						if (count($themes) > 0) {
							$themeName = array_keys($themes)[0];
							switch_theme($themeName);
						}
					}
				`
    }
  ] : [];
}
const W = b.join(K.homedir(), ".wordpress-playground");
async function te(e) {
  return await E(
    "https://github.com/Automattic/sqlite-database-integration/archive/refs/heads/develop.zip",
    "sqlite.zip",
    e
  );
}
async function E(e, t, n) {
  const c = b.join(W, t);
  return y.existsSync(c) || (y.ensureDirSync(W), await ne(e, c, n)), _(c);
}
async function ne(e, t, n) {
  const p = (await n.monitorFetch(fetch(e))).body.getReader(), a = `${t}.partial`, r = y.createWriteStream(a);
  for (; ; ) {
    const { done: s, value: l } = await p.read();
    if (l && r.write(l), s)
      break;
  }
  r.close(), r.closed || await new Promise((s, l) => {
    r.on("finish", () => {
      y.renameSync(a, t), s(null);
    }), r.on("error", (i) => {
      y.removeSync(a), l(i);
    });
  });
}
function _(e, t) {
  return new File([y.readFileSync(e)], g(e));
}
async function re(e) {
  const t = Q(), n = await new Promise((a, r) => {
    const s = t.listen(e.port, () => {
      const l = s.address();
      l === null || typeof l == "string" ? r(new Error("Server address is not available")) : a(s);
    });
  });
  t.use("/", async (a, r) => {
    const s = await e.handleRequest({
      url: a.url,
      headers: oe(a),
      method: a.method,
      body: await se(a)
    });
    r.statusCode = s.httpStatusCode;
    for (const l in s.headers)
      r.setHeader(l, s.headers[l]);
    r.end(s.bytes);
  });
  const p = n.address().port;
  return await e.onBind(n, p);
}
const se = async (e) => await new Promise((t) => {
  const n = [];
  e.on("data", (c) => {
    n.push(c);
  }), e.on("end", () => {
    t(new Uint8Array(Buffer.concat(n)));
  });
}), oe = (e) => {
  const t = {};
  if (e.rawHeaders && e.rawHeaders.length)
    for (let n = 0; n < e.rawHeaders.length; n += 2)
      t[e.rawHeaders[n].toLowerCase()] = e.rawHeaders[n + 1];
  return t;
};
async function $e(e) {
  e.autoMount && (e = X(e));
  async function t(i) {
    const { php: u, reap: f } = await s.processManager.acquirePHPInstance();
    try {
      await u.run({
        code: `<?php
				$zip = new ZipArchive();
				if(false === $zip->open('/tmp/build.zip', ZipArchive::CREATE | ZipArchive::OVERWRITE)) {
					throw new Exception('Failed to create ZIP');
				}
				$files = new RecursiveIteratorIterator(
					new RecursiveDirectoryIterator('/wordpress')
				);
				foreach ($files as $file) {
					echo $file . PHP_EOL;
					if (!$file->isFile()) {
						continue;
					}
					$zip->addFile($file->getPathname(), $file->getPathname());
				}
				$zip->close();

			`
      });
      const o = u.readFileAsBuffer("/tmp/build.zip");
      m.writeFileSync(i, o);
    } finally {
      f();
    }
  }
  function n(i, u) {
    const f = u.map((o) => {
      const [w, P] = o.split(":");
      return {
        hostPath: b.resolve(process.cwd(), w),
        vfsPath: P
      };
    });
    for (const o of f)
      i.mkdir(o.vfsPath), i.mount(o.vfsPath, A(o.hostPath));
  }
  async function c() {
    const i = U(e.blueprint) ? e.blueprint : {
      login: e.login,
      ...e.blueprint,
      preferredVersions: {
        php: e.php ?? e?.blueprint?.preferredVersions?.php ?? j,
        wp: e.wp ?? e?.blueprint?.preferredVersions?.wp ?? "latest",
        ...e.blueprint?.preferredVersions || {}
      }
    }, u = new L();
    let f = "", o = !1;
    return u.addEventListener("progress", (w) => {
      if (o)
        return;
      o = w.detail.progress === 100;
      const P = Math.floor(w.detail.progress);
      f = w.detail.caption || f || "Running the Blueprint";
      const v = `${f.trim()} â€“ ${P}%`;
      e.quiet || a(
        process.stdout,
        v,
        o
      );
    }), await Z(i, {
      progress: u
    });
  }
  let p = "";
  function a(i, u, f) {
    u !== p && (p = u, i.isTTY ? (i.cursorTo(0), i.write(u), i.clearLine(1), f && i.write(`
`)) : i.write(`${u}
`));
  }
  e.quiet && (d.handlers = []);
  const r = await c();
  let s, l = !1;
  return d.log("Starting a PHP server..."), re({
    port: e.port,
    onBind: async (i, u) => {
      const f = `http://127.0.0.1:${u}`;
      d.log(`Setting up WordPress ${e.wp}`);
      let o;
      const w = new q();
      if (!e.skipWordPressSetup) {
        let h = !1;
        w.addEventListener("progress", ($) => {
          if (h)
            return;
          const { loaded: k, total: D } = $.detail, x = Math.floor(
            Math.min(100, 100 * k / D)
          );
          h = x === 100, e.quiet || a(
            process.stdout,
            `Downloading WordPress ${x}%...`,
            h
          );
        }), o = await O(e.wp);
      }
      d.log(
        `Resolved WordPress release URL: ${o?.releaseUrl}`
      );
      const P = o && b.join(
        W,
        `prebuilt-wp-content-for-wp-${o.version}.zip`
      ), v = o ? m.existsSync(P) ? _(P) : await E(
        o.releaseUrl,
        `${o.version}.zip`,
        w
      ) : void 0, N = {
        WP_DEBUG: !0,
        WP_DEBUG_LOG: !0,
        WP_DEBUG_DISPLAY: !1
      };
      d.log("Booting WordPress..."), s = await Y({
        siteUrl: f,
        createPhpRuntime: async () => await z(r.versions.php, {
          followSymlinks: e.followSymlinks === !0
        }),
        wordPressZip: v,
        sqliteIntegrationPluginZip: e.skipSqliteSetup ? void 0 : te(w),
        sapiName: "cli",
        createFiles: {
          "/internal/shared/ca-bundle.crt": J.join(`
`)
        },
        constants: N,
        phpIniEntries: {
          "openssl.cafile": "/internal/shared/ca-bundle.crt",
          allow_url_fopen: "1",
          disable_functions: ""
        },
        hooks: {
          async beforeWordPressFiles(h) {
            e.mountBeforeInstall && n(h, e.mountBeforeInstall);
          }
        },
        cookieStore: !1
      }), d.log("Booted!");
      const S = await s.getPrimaryPhp();
      try {
        if (o && !e.mountBeforeInstall && !m.existsSync(P) && (d.log(
          "Caching preinstalled WordPress for the next boot..."
        ), m.writeFileSync(
          P,
          await G(S, "/wordpress")
        ), d.log("Cached!")), e.mount && n(S, e.mount), l = !0, r) {
          const { php: h, reap: $ } = await s.processManager.acquirePHPInstance();
          try {
            d.log("Running the Blueprint..."), await V(r, h), d.log("Finished running the blueprint");
          } finally {
            $();
          }
        }
        return e.command === "build-snapshot" ? (await t(e.outfile), d.log(`WordPress exported to ${e.outfile}`), process.exit(0)) : e.command === "run-blueprint" ? (d.log("Blueprint executed"), process.exit(0)) : d.log(`WordPress is running on ${f}`), { requestHandler: s, server: i };
      } catch (h) {
        if (!e.debug)
          throw h;
        const $ = S.readFileAsText(M);
        throw new Error($, { cause: h });
      }
    },
    async handleRequest(i) {
      return l ? await s.request(i) : T.forHttpCode(
        502,
        "WordPress is not ready yet"
      );
    }
  });
}
export {
  $e as r
};
//# sourceMappingURL=run-cli-j-geJYS3.js.map
