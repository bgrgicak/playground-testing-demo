import { logger as u, errorLogPath as z } from "@php-wasm/logger";
import { createNodeFsMountHandler as A, loadNodeRuntime as L } from "@php-wasm/node";
import { ProgressTracker as q, EmscriptenDownloadMonitor as T } from "@php-wasm/progress";
import { PHPResponse as U } from "@php-wasm/universal";
import { isBlueprintBundle as Z, compileBlueprint as V, runBlueprintSteps as j } from "@wp-playground/blueprints";
import { RecommendedPHPVersion as G, zipDirectory as O } from "@wp-playground/common";
import { resolveWordPressRelease as Y, bootWordPress as J } from "@wp-playground/wordpress";
import d, { existsSync as I } from "fs";
import $, { basename as g, join as W } from "path";
import { rootCertificates as K } from "tls";
import P from "fs-extra";
import Q from "os";
import X from "express";
function ee(e) {
  const t = process.cwd(), n = [...e.mount || []], o = [...e.mountBeforeInstall || []];
  if (C(t)) {
    const s = g(t);
    n.push({
      hostPath: t,
      vfsPath: `/wordpress/wp-content/plugins/${s}`
    });
  } else if (F(t)) {
    const s = g(t);
    n.push({
      hostPath: t,
      vfsPath: `/wordpress/wp-content/themes/${s}`
    });
  } else if (H(t))
    n.push(...B(t));
  else if (S(t)) {
    const s = d.readdirSync(t), l = [];
    for (const r of s)
      r.startsWith("wp-content") || l.push({
        hostPath: `${t}/${r}`,
        vfsPath: `/wordpress/${r}`
      });
    o.push(
      ...l,
      ...B(W(t, "wp-content"))
    );
  } else
    n.push({ hostPath: t, vfsPath: "/wordpress" });
  const i = e.blueprint || {};
  i.steps = [...i.steps || [], ...te(t)];
  const a = e.skipWordPressSetup || S(t);
  return {
    ...e,
    blueprint: i,
    mount: n,
    mountBeforeInstall: o,
    skipWordPressSetup: a
  };
}
function S(e) {
  const t = d.readdirSync(e);
  return t.includes("wp-admin") && t.includes("wp-includes") && t.includes("wp-content");
}
function H(e) {
  const t = d.readdirSync(e);
  return t.includes("themes") || t.includes("plugins") || t.includes("mu-plugins") || t.includes("uploads");
}
function F(e) {
  if (!d.readdirSync(e).includes("style.css"))
    return !1;
  const n = d.readFileSync(W(e, "style.css"), "utf8");
  return !!/^(?:[ \t]*<\?php)?[ \t/*#@]*Theme Name:(.*)$/im.exec(n);
}
function C(e) {
  const t = d.readdirSync(e), n = /^(?:[ \t]*<\?php)?[ \t/*#@]*Plugin Name:(.*)$/im;
  return !!t.filter((i) => i.endsWith(".php")).find((i) => {
    const a = d.readFileSync(W(e, i), "utf8");
    return !!n.exec(a);
  });
}
function B(e) {
  return d.readdirSync(e).filter((n) => !n.startsWith("index.php")).map((n) => ({
    hostPath: `${e}/${n}`,
    vfsPath: `/wordpress/wp-content/${n}`
  }));
}
function te(e) {
  return C(e) ? [
    {
      step: "activatePlugin",
      pluginPath: `/wordpress/wp-content/plugins/${g(e)}`
    }
  ] : F(e) ? [
    {
      step: "activateTheme",
      themeFolderName: g(e)
    }
  ] : H(e) || S(e) ? [
    {
      step: "runPHP",
      code: `<?php
					require_once '/wordpress/wp-load.php';
					$theme = wp_get_theme();
					if (!$theme->exists()) {
						$themes = wp_get_themes();
						if (count($themes) > 0) {
							$themeName = array_keys($themes)[0];
							switch_theme($themeName);
						}
					}
				`
    }
  ] : [];
}
const R = $.join(Q.homedir(), ".wordpress-playground");
async function ne(e) {
  return await M(
    "https://github.com/WordPress/sqlite-database-integration/archive/refs/heads/develop.zip",
    "sqlite.zip",
    e
  );
}
async function M(e, t, n) {
  const o = $.join(R, t);
  return P.existsSync(o) || (P.ensureDirSync(R), await re(e, o, n)), _(o);
}
async function re(e, t, n) {
  const i = (await n.monitorFetch(fetch(e))).body.getReader(), a = `${t}.partial`, s = P.createWriteStream(a);
  for (; ; ) {
    const { done: l, value: r } = await i.read();
    if (r && s.write(r), l)
      break;
  }
  s.close(), s.closed || await new Promise((l, r) => {
    s.on("finish", () => {
      P.renameSync(a, t), l(null);
    }), s.on("error", (p) => {
      P.removeSync(a), r(p);
    });
  });
}
function _(e, t) {
  return new File([P.readFileSync(e)], g(e));
}
async function se(e) {
  const t = X(), n = await new Promise((a, s) => {
    const l = t.listen(e.port, () => {
      const r = l.address();
      r === null || typeof r == "string" ? s(new Error("Server address is not available")) : a(l);
    });
  });
  t.use("/", async (a, s) => {
    const l = await e.handleRequest({
      url: a.url,
      headers: ie(a),
      method: a.method,
      body: await oe(a)
    });
    s.statusCode = l.httpStatusCode;
    for (const r in l.headers)
      s.setHeader(r, l.headers[r]);
    s.end(l.bytes);
  });
  const i = n.address().port;
  return await e.onBind(n, i);
}
const oe = async (e) => await new Promise((t) => {
  const n = [];
  e.on("data", (o) => {
    n.push(o);
  }), e.on("end", () => {
    t(new Uint8Array(Buffer.concat(n)));
  });
}), ie = (e) => {
  const t = {};
  if (e.rawHeaders && e.rawHeaders.length)
    for (let n = 0; n < e.rawHeaders.length; n += 2)
      t[e.rawHeaders[n].toLowerCase()] = e.rawHeaders[n + 1];
  return t;
};
function $e(e) {
  const t = [];
  for (const n of e) {
    const o = n.split(":");
    if (o.length !== 2)
      throw new Error(`Invalid mount format: ${n}.
				Expected format: /host/path:/vfs/path.
				If your path contains a colon, e.g. C:\\myplugin, use the --mount-dir option instead.
				Example: --mount-dir C:\\my-plugin /wordpress/wp-content/plugins/my-plugin`);
    const [i, a] = o;
    if (!I(i))
      throw new Error(`Host path does not exist: ${i}`);
    t.push({ hostPath: i, vfsPath: a });
  }
  return t;
}
function ve(e) {
  if (e.length % 2 !== 0)
    throw new Error("Invalid mount format. Expected: /host/path /vfs/path");
  const t = [];
  for (let n = 0; n < e.length; n += 2) {
    const o = e[n], i = e[n + 1];
    if (!I(o))
      throw new Error(`Host path does not exist: ${o}`);
    t.push({
      hostPath: $.resolve(process.cwd(), o),
      vfsPath: i
    });
  }
  return t;
}
function E(e, t) {
  for (const n of t)
    e.mkdir(n.vfsPath), e.mount(n.vfsPath, A(n.hostPath));
}
async function be(e) {
  e.autoMount && (e = ee(e));
  async function t(r) {
    const { php: p, reap: f } = await s.processManager.acquirePHPInstance();
    try {
      await p.run({
        code: `<?php
				$zip = new ZipArchive();
				if(false === $zip->open('/tmp/build.zip', ZipArchive::CREATE | ZipArchive::OVERWRITE)) {
					throw new Exception('Failed to create ZIP');
				}
				$files = new RecursiveIteratorIterator(
					new RecursiveDirectoryIterator('/wordpress')
				);
				foreach ($files as $file) {
					echo $file . PHP_EOL;
					if (!$file->isFile()) {
						continue;
					}
					$zip->addFile($file->getPathname(), $file->getPathname());
				}
				$zip->close();

			`
      });
      const c = p.readFileAsBuffer("/tmp/build.zip");
      d.writeFileSync(r, c);
    } finally {
      f();
    }
  }
  async function n() {
    const r = Z(e.blueprint) ? e.blueprint : {
      login: e.login,
      ...e.blueprint,
      preferredVersions: {
        php: e.php ?? e?.blueprint?.preferredVersions?.php ?? G,
        wp: e.wp ?? e?.blueprint?.preferredVersions?.wp ?? "latest",
        ...e.blueprint?.preferredVersions || {}
      }
    }, p = new q();
    let f = "", c = !1;
    return p.addEventListener("progress", (m) => {
      if (c)
        return;
      c = m.detail.progress === 100;
      const w = Math.floor(m.detail.progress);
      f = m.detail.caption || f || "Running the Blueprint";
      const v = `${f.trim()} â€“ ${w}%`;
      e.quiet || i(
        process.stdout,
        v,
        c
      );
    }), await V(r, {
      progress: p
    });
  }
  let o = "";
  function i(r, p, f) {
    p !== o && (o = p, r.isTTY ? (r.cursorTo(0), r.write(p), r.clearLine(1), f && r.write(`
`)) : r.write(`${p}
`));
  }
  e.quiet && (u.handlers = []);
  const a = await n();
  let s, l = !1;
  return u.log("Starting a PHP server..."), se({
    port: e.port,
    onBind: async (r, p) => {
      const f = `http://127.0.0.1:${p}`;
      u.log(`Setting up WordPress ${e.wp}`);
      let c;
      const m = new T();
      if (!e.skipWordPressSetup) {
        let h = !1;
        m.addEventListener("progress", (y) => {
          if (h)
            return;
          const { loaded: N, total: k } = y.detail, x = Math.floor(
            Math.min(100, 100 * N / k)
          );
          h = x === 100, e.quiet || i(
            process.stdout,
            `Downloading WordPress ${x}%...`,
            h
          );
        }), c = await Y(e.wp);
      }
      u.log(
        `Resolved WordPress release URL: ${c?.releaseUrl}`
      );
      const w = c && $.join(
        R,
        `prebuilt-wp-content-for-wp-${c.version}.zip`
      ), v = c ? d.existsSync(w) ? _(w) : await M(
        c.releaseUrl,
        `${c.version}.zip`,
        m
      ) : void 0, D = {
        WP_DEBUG: !0,
        WP_DEBUG_LOG: !0,
        WP_DEBUG_DISPLAY: !1
      };
      u.log("Booting WordPress..."), s = await J({
        siteUrl: f,
        createPhpRuntime: async () => await L(a.versions.php, {
          followSymlinks: e.followSymlinks === !0
        }),
        wordPressZip: v,
        sqliteIntegrationPluginZip: e.skipSqliteSetup ? void 0 : ne(m),
        sapiName: "cli",
        createFiles: {
          "/internal/shared/ca-bundle.crt": K.join(`
`)
        },
        constants: D,
        phpIniEntries: {
          "openssl.cafile": "/internal/shared/ca-bundle.crt",
          allow_url_fopen: "1",
          disable_functions: ""
        },
        hooks: {
          async beforeWordPressFiles(h) {
            e.mountBeforeInstall && E(h, e.mountBeforeInstall);
          }
        },
        cookieStore: !1
      }), u.log("Booted!");
      const b = await s.getPrimaryPhp();
      try {
        if (c && !e.mountBeforeInstall && !d.existsSync(w) && (u.log(
          "Caching preinstalled WordPress for the next boot..."
        ), d.writeFileSync(
          w,
          await O(b, "/wordpress")
        ), u.log("Cached!")), e.mount && E(b, e.mount), l = !0, a) {
          const { php: h, reap: y } = await s.processManager.acquirePHPInstance();
          try {
            u.log("Running the Blueprint..."), await j(a, h), u.log("Finished running the blueprint");
          } finally {
            y();
          }
        }
        return e.command === "build-snapshot" ? (await t(e.outfile), u.log(`WordPress exported to ${e.outfile}`), process.exit(0)) : e.command === "run-blueprint" ? (u.log("Blueprint executed"), process.exit(0)) : u.log(`WordPress is running on ${f}`), { requestHandler: s, server: r };
      } catch (h) {
        if (!e.debug)
          throw h;
        const y = b.readFileAsText(z);
        throw new Error(y, { cause: h });
      }
    },
    async handleRequest(r) {
      return l ? await s.request(r) : U.forHttpCode(
        502,
        "WordPress is not ready yet"
      );
    }
  });
}
export {
  ve as a,
  $e as p,
  be as r
};
//# sourceMappingURL=run-cli-_8y4VW5F.js.map
