import { SupportedPHPVersions as Ni } from "@php-wasm/universal";
import { RecommendedPHPVersion as Mi } from "@wp-playground/common";
import Wi from "yargs";
import { r as qi } from "./run-cli-j-geJYS3.js";
import Tt from "fs";
import Ft from "path";
import { Semaphore as Tn } from "@php-wasm/util";
import { resolveRemoteBlueprint as ji } from "@wp-playground/blueprints";
import { logger as Hi } from "@php-wasm/logger";
function Yi(n) {
  return /^latest$|^trunk$|^nightly$|^(?:(\d+)\.(\d+)(?:\.(\d+))?)((?:-beta(?:\d+)?)|(?:-RC(?:\d+)?))?$/.test(n);
}
new Tn({ concurrency: 15 });
new Tn({ concurrency: 10 });
class Fn extends Error {
  constructor(t) {
    super(t), this.caller = "";
  }
  toJSON() {
    return {
      code: this.code,
      data: this.data,
      caller: this.caller,
      message: this.message,
      stack: this.stack
    };
  }
  fromJSON(t) {
    const e = new Fn(t.message);
    return e.code = t.code, e.data = t.data, e.caller = t.caller, e.stack = t.stack, e;
  }
  get isIsomorphicGitError() {
    return !0;
  }
}
var Gi = {};
/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
(function(n) {
  (function(t) {
    t(typeof DO_NOT_EXPORT_CRC > "u" ? n : {});
  })(function(t) {
    t.version = "1.2.2";
    function e() {
      for (var b = 0, I = new Array(256), v = 0; v != 256; ++v)
        b = v, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, b = b & 1 ? -306674912 ^ b >>> 1 : b >>> 1, I[v] = b;
      return typeof Int32Array < "u" ? new Int32Array(I) : I;
    }
    var r = e();
    function a(b) {
      var I = 0, v = 0, k = 0, W = typeof Int32Array < "u" ? new Int32Array(4096) : new Array(4096);
      for (k = 0; k != 256; ++k) W[k] = b[k];
      for (k = 0; k != 256; ++k)
        for (v = b[k], I = 256 + k; I < 4096; I += 256) v = W[I] = v >>> 8 ^ b[v & 255];
      var O = [];
      for (k = 1; k != 16; ++k) O[k - 1] = typeof Int32Array < "u" ? W.subarray(k * 256, k * 256 + 256) : W.slice(k * 256, k * 256 + 256);
      return O;
    }
    var o = a(r), c = o[0], l = o[1], u = o[2], g = o[3], x = o[4], w = o[5], _ = o[6], A = o[7], P = o[8], h = o[9], p = o[10], m = o[11], E = o[12], R = o[13], D = o[14];
    function S(b, I) {
      for (var v = I ^ -1, k = 0, W = b.length; k < W; ) v = v >>> 8 ^ r[(v ^ b.charCodeAt(k++)) & 255];
      return ~v;
    }
    function T(b, I) {
      for (var v = I ^ -1, k = b.length - 15, W = 0; W < k; ) v = D[b[W++] ^ v & 255] ^ R[b[W++] ^ v >> 8 & 255] ^ E[b[W++] ^ v >> 16 & 255] ^ m[b[W++] ^ v >>> 24] ^ p[b[W++]] ^ h[b[W++]] ^ P[b[W++]] ^ A[b[W++]] ^ _[b[W++]] ^ w[b[W++]] ^ x[b[W++]] ^ g[b[W++]] ^ u[b[W++]] ^ l[b[W++]] ^ c[b[W++]] ^ r[b[W++]];
      for (k += 15; W < k; ) v = v >>> 8 ^ r[(v ^ b[W++]) & 255];
      return ~v;
    }
    function F(b, I) {
      for (var v = I ^ -1, k = 0, W = b.length, O = 0, Z = 0; k < W; )
        O = b.charCodeAt(k++), O < 128 ? v = v >>> 8 ^ r[(v ^ O) & 255] : O < 2048 ? (v = v >>> 8 ^ r[(v ^ (192 | O >> 6 & 31)) & 255], v = v >>> 8 ^ r[(v ^ (128 | O & 63)) & 255]) : O >= 55296 && O < 57344 ? (O = (O & 1023) + 64, Z = b.charCodeAt(k++) & 1023, v = v >>> 8 ^ r[(v ^ (240 | O >> 8 & 7)) & 255], v = v >>> 8 ^ r[(v ^ (128 | O >> 2 & 63)) & 255], v = v >>> 8 ^ r[(v ^ (128 | Z >> 6 & 15 | (O & 3) << 4)) & 255], v = v >>> 8 ^ r[(v ^ (128 | Z & 63)) & 255]) : (v = v >>> 8 ^ r[(v ^ (224 | O >> 12 & 15)) & 255], v = v >>> 8 ^ r[(v ^ (128 | O >> 6 & 63)) & 255], v = v >>> 8 ^ r[(v ^ (128 | O & 63)) & 255]);
      return ~v;
    }
    t.table = r, t.bstr = S, t.buf = T, t.str = F;
  });
})(Gi);
var jr = {}, Jt = {};
Jt.byteLength = Ki;
Jt.toByteArray = $i;
Jt.fromByteArray = Qi;
var Pe = [], Fe = [], Vi = typeof Uint8Array < "u" ? Uint8Array : Array, nn = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var st = 0, Zi = nn.length; st < Zi; ++st)
  Pe[st] = nn[st], Fe[nn.charCodeAt(st)] = st;
Fe[45] = 62;
Fe[95] = 63;
function Hr(n) {
  var t = n.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var e = n.indexOf("=");
  e === -1 && (e = t);
  var r = e === t ? 0 : 4 - e % 4;
  return [e, r];
}
function Ki(n) {
  var t = Hr(n), e = t[0], r = t[1];
  return (e + r) * 3 / 4 - r;
}
function Xi(n, t, e) {
  return (t + e) * 3 / 4 - e;
}
function $i(n) {
  var t, e = Hr(n), r = e[0], a = e[1], o = new Vi(Xi(n, r, a)), c = 0, l = a > 0 ? r - 4 : r, u;
  for (u = 0; u < l; u += 4)
    t = Fe[n.charCodeAt(u)] << 18 | Fe[n.charCodeAt(u + 1)] << 12 | Fe[n.charCodeAt(u + 2)] << 6 | Fe[n.charCodeAt(u + 3)], o[c++] = t >> 16 & 255, o[c++] = t >> 8 & 255, o[c++] = t & 255;
  return a === 2 && (t = Fe[n.charCodeAt(u)] << 2 | Fe[n.charCodeAt(u + 1)] >> 4, o[c++] = t & 255), a === 1 && (t = Fe[n.charCodeAt(u)] << 10 | Fe[n.charCodeAt(u + 1)] << 4 | Fe[n.charCodeAt(u + 2)] >> 2, o[c++] = t >> 8 & 255, o[c++] = t & 255), o;
}
function Ji(n) {
  return Pe[n >> 18 & 63] + Pe[n >> 12 & 63] + Pe[n >> 6 & 63] + Pe[n & 63];
}
function zi(n, t, e) {
  for (var r, a = [], o = t; o < e; o += 3)
    r = (n[o] << 16 & 16711680) + (n[o + 1] << 8 & 65280) + (n[o + 2] & 255), a.push(Ji(r));
  return a.join("");
}
function Qi(n) {
  for (var t, e = n.length, r = e % 3, a = [], o = 16383, c = 0, l = e - r; c < l; c += o)
    a.push(zi(n, c, c + o > l ? l : c + o));
  return r === 1 ? (t = n[e - 1], a.push(
    Pe[t >> 2] + Pe[t << 4 & 63] + "=="
  )) : r === 2 && (t = (n[e - 2] << 8) + n[e - 1], a.push(
    Pe[t >> 10] + Pe[t >> 4 & 63] + Pe[t << 2 & 63] + "="
  )), a.join("");
}
var Rn = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Rn.read = function(n, t, e, r, a) {
  var o, c, l = a * 8 - r - 1, u = (1 << l) - 1, g = u >> 1, x = -7, w = e ? a - 1 : 0, _ = e ? -1 : 1, A = n[t + w];
  for (w += _, o = A & (1 << -x) - 1, A >>= -x, x += l; x > 0; o = o * 256 + n[t + w], w += _, x -= 8)
    ;
  for (c = o & (1 << -x) - 1, o >>= -x, x += r; x > 0; c = c * 256 + n[t + w], w += _, x -= 8)
    ;
  if (o === 0)
    o = 1 - g;
  else {
    if (o === u)
      return c ? NaN : (A ? -1 : 1) * (1 / 0);
    c = c + Math.pow(2, r), o = o - g;
  }
  return (A ? -1 : 1) * c * Math.pow(2, o - r);
};
Rn.write = function(n, t, e, r, a, o) {
  var c, l, u, g = o * 8 - a - 1, x = (1 << g) - 1, w = x >> 1, _ = a === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, A = r ? 0 : o - 1, P = r ? 1 : -1, h = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (l = isNaN(t) ? 1 : 0, c = x) : (c = Math.floor(Math.log(t) / Math.LN2), t * (u = Math.pow(2, -c)) < 1 && (c--, u *= 2), c + w >= 1 ? t += _ / u : t += _ * Math.pow(2, 1 - w), t * u >= 2 && (c++, u /= 2), c + w >= x ? (l = 0, c = x) : c + w >= 1 ? (l = (t * u - 1) * Math.pow(2, a), c = c + w) : (l = t * Math.pow(2, w - 1) * Math.pow(2, a), c = 0)); a >= 8; n[e + A] = l & 255, A += P, l /= 256, a -= 8)
    ;
  for (c = c << a | l, g += a; g > 0; n[e + A] = c & 255, A += P, c /= 256, g -= 8)
    ;
  n[e + A - P] |= h * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(n) {
  var t = Jt, e = Rn, r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  n.Buffer = l, n.SlowBuffer = E, n.INSPECT_MAX_BYTES = 50;
  var a = 2147483647;
  n.kMaxLength = a, l.TYPED_ARRAY_SUPPORT = o(), !l.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function o() {
    try {
      var f = new Uint8Array(1), i = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(i, Uint8Array.prototype), Object.setPrototypeOf(f, i), f.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(l.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (l.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(l.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (l.isBuffer(this))
        return this.byteOffset;
    }
  });
  function c(f) {
    if (f > a)
      throw new RangeError('The value "' + f + '" is invalid for option "size"');
    var i = new Uint8Array(f);
    return Object.setPrototypeOf(i, l.prototype), i;
  }
  function l(f, i, s) {
    if (typeof f == "number") {
      if (typeof i == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return w(f);
    }
    return u(f, i, s);
  }
  l.poolSize = 8192;
  function u(f, i, s) {
    if (typeof f == "string")
      return _(f, i);
    if (ArrayBuffer.isView(f))
      return P(f);
    if (f == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof f
      );
    if (fe(f, ArrayBuffer) || f && fe(f.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (fe(f, SharedArrayBuffer) || f && fe(f.buffer, SharedArrayBuffer)))
      return h(f, i, s);
    if (typeof f == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    var d = f.valueOf && f.valueOf();
    if (d != null && d !== f)
      return l.from(d, i, s);
    var y = p(f);
    if (y) return y;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof f[Symbol.toPrimitive] == "function")
      return l.from(
        f[Symbol.toPrimitive]("string"),
        i,
        s
      );
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof f
    );
  }
  l.from = function(f, i, s) {
    return u(f, i, s);
  }, Object.setPrototypeOf(l.prototype, Uint8Array.prototype), Object.setPrototypeOf(l, Uint8Array);
  function g(f) {
    if (typeof f != "number")
      throw new TypeError('"size" argument must be of type number');
    if (f < 0)
      throw new RangeError('The value "' + f + '" is invalid for option "size"');
  }
  function x(f, i, s) {
    return g(f), f <= 0 ? c(f) : i !== void 0 ? typeof s == "string" ? c(f).fill(i, s) : c(f).fill(i) : c(f);
  }
  l.alloc = function(f, i, s) {
    return x(f, i, s);
  };
  function w(f) {
    return g(f), c(f < 0 ? 0 : m(f) | 0);
  }
  l.allocUnsafe = function(f) {
    return w(f);
  }, l.allocUnsafeSlow = function(f) {
    return w(f);
  };
  function _(f, i) {
    if ((typeof i != "string" || i === "") && (i = "utf8"), !l.isEncoding(i))
      throw new TypeError("Unknown encoding: " + i);
    var s = R(f, i) | 0, d = c(s), y = d.write(f, i);
    return y !== s && (d = d.slice(0, y)), d;
  }
  function A(f) {
    for (var i = f.length < 0 ? 0 : m(f.length) | 0, s = c(i), d = 0; d < i; d += 1)
      s[d] = f[d] & 255;
    return s;
  }
  function P(f) {
    if (fe(f, Uint8Array)) {
      var i = new Uint8Array(f);
      return h(i.buffer, i.byteOffset, i.byteLength);
    }
    return A(f);
  }
  function h(f, i, s) {
    if (i < 0 || f.byteLength < i)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (f.byteLength < i + (s || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var d;
    return i === void 0 && s === void 0 ? d = new Uint8Array(f) : s === void 0 ? d = new Uint8Array(f, i) : d = new Uint8Array(f, i, s), Object.setPrototypeOf(d, l.prototype), d;
  }
  function p(f) {
    if (l.isBuffer(f)) {
      var i = m(f.length) | 0, s = c(i);
      return s.length === 0 || f.copy(s, 0, 0, i), s;
    }
    if (f.length !== void 0)
      return typeof f.length != "number" || We(f.length) ? c(0) : A(f);
    if (f.type === "Buffer" && Array.isArray(f.data))
      return A(f.data);
  }
  function m(f) {
    if (f >= a)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a.toString(16) + " bytes");
    return f | 0;
  }
  function E(f) {
    return +f != f && (f = 0), l.alloc(+f);
  }
  l.isBuffer = function(i) {
    return i != null && i._isBuffer === !0 && i !== l.prototype;
  }, l.compare = function(i, s) {
    if (fe(i, Uint8Array) && (i = l.from(i, i.offset, i.byteLength)), fe(s, Uint8Array) && (s = l.from(s, s.offset, s.byteLength)), !l.isBuffer(i) || !l.isBuffer(s))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (i === s) return 0;
    for (var d = i.length, y = s.length, L = 0, N = Math.min(d, y); L < N; ++L)
      if (i[L] !== s[L]) {
        d = i[L], y = s[L];
        break;
      }
    return d < y ? -1 : y < d ? 1 : 0;
  }, l.isEncoding = function(i) {
    switch (String(i).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, l.concat = function(i, s) {
    if (!Array.isArray(i))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (i.length === 0)
      return l.alloc(0);
    var d;
    if (s === void 0)
      for (s = 0, d = 0; d < i.length; ++d)
        s += i[d].length;
    var y = l.allocUnsafe(s), L = 0;
    for (d = 0; d < i.length; ++d) {
      var N = i[d];
      if (fe(N, Uint8Array))
        L + N.length > y.length ? l.from(N).copy(y, L) : Uint8Array.prototype.set.call(
          y,
          N,
          L
        );
      else if (l.isBuffer(N))
        N.copy(y, L);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      L += N.length;
    }
    return y;
  };
  function R(f, i) {
    if (l.isBuffer(f))
      return f.length;
    if (ArrayBuffer.isView(f) || fe(f, ArrayBuffer))
      return f.byteLength;
    if (typeof f != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof f
      );
    var s = f.length, d = arguments.length > 2 && arguments[2] === !0;
    if (!d && s === 0) return 0;
    for (var y = !1; ; )
      switch (i) {
        case "ascii":
        case "latin1":
        case "binary":
          return s;
        case "utf8":
        case "utf-8":
          return Me(f).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return s * 2;
        case "hex":
          return s >>> 1;
        case "base64":
          return ze(f).length;
        default:
          if (y)
            return d ? -1 : Me(f).length;
          i = ("" + i).toLowerCase(), y = !0;
      }
  }
  l.byteLength = R;
  function D(f, i, s) {
    var d = !1;
    if ((i === void 0 || i < 0) && (i = 0), i > this.length || ((s === void 0 || s > this.length) && (s = this.length), s <= 0) || (s >>>= 0, i >>>= 0, s <= i))
      return "";
    for (f || (f = "utf8"); ; )
      switch (f) {
        case "hex":
          return oe(this, i, s);
        case "utf8":
        case "utf-8":
          return Z(this, i, s);
        case "ascii":
          return K(this, i, s);
        case "latin1":
        case "binary":
          return X(this, i, s);
        case "base64":
          return O(this, i, s);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return G(this, i, s);
        default:
          if (d) throw new TypeError("Unknown encoding: " + f);
          f = (f + "").toLowerCase(), d = !0;
      }
  }
  l.prototype._isBuffer = !0;
  function S(f, i, s) {
    var d = f[i];
    f[i] = f[s], f[s] = d;
  }
  l.prototype.swap16 = function() {
    var i = this.length;
    if (i % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var s = 0; s < i; s += 2)
      S(this, s, s + 1);
    return this;
  }, l.prototype.swap32 = function() {
    var i = this.length;
    if (i % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var s = 0; s < i; s += 4)
      S(this, s, s + 3), S(this, s + 1, s + 2);
    return this;
  }, l.prototype.swap64 = function() {
    var i = this.length;
    if (i % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var s = 0; s < i; s += 8)
      S(this, s, s + 7), S(this, s + 1, s + 6), S(this, s + 2, s + 5), S(this, s + 3, s + 4);
    return this;
  }, l.prototype.toString = function() {
    var i = this.length;
    return i === 0 ? "" : arguments.length === 0 ? Z(this, 0, i) : D.apply(this, arguments);
  }, l.prototype.toLocaleString = l.prototype.toString, l.prototype.equals = function(i) {
    if (!l.isBuffer(i)) throw new TypeError("Argument must be a Buffer");
    return this === i ? !0 : l.compare(this, i) === 0;
  }, l.prototype.inspect = function() {
    var i = "", s = n.INSPECT_MAX_BYTES;
    return i = this.toString("hex", 0, s).replace(/(.{2})/g, "$1 ").trim(), this.length > s && (i += " ... "), "<Buffer " + i + ">";
  }, r && (l.prototype[r] = l.prototype.inspect), l.prototype.compare = function(i, s, d, y, L) {
    if (fe(i, Uint8Array) && (i = l.from(i, i.offset, i.byteLength)), !l.isBuffer(i))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof i
      );
    if (s === void 0 && (s = 0), d === void 0 && (d = i ? i.length : 0), y === void 0 && (y = 0), L === void 0 && (L = this.length), s < 0 || d > i.length || y < 0 || L > this.length)
      throw new RangeError("out of range index");
    if (y >= L && s >= d)
      return 0;
    if (y >= L)
      return -1;
    if (s >= d)
      return 1;
    if (s >>>= 0, d >>>= 0, y >>>= 0, L >>>= 0, this === i) return 0;
    for (var N = L - y, $ = d - s, ne = Math.min(N, $), re = this.slice(y, L), pe = i.slice(s, d), te = 0; te < ne; ++te)
      if (re[te] !== pe[te]) {
        N = re[te], $ = pe[te];
        break;
      }
    return N < $ ? -1 : $ < N ? 1 : 0;
  };
  function T(f, i, s, d, y) {
    if (f.length === 0) return -1;
    if (typeof s == "string" ? (d = s, s = 0) : s > 2147483647 ? s = 2147483647 : s < -2147483648 && (s = -2147483648), s = +s, We(s) && (s = y ? 0 : f.length - 1), s < 0 && (s = f.length + s), s >= f.length) {
      if (y) return -1;
      s = f.length - 1;
    } else if (s < 0)
      if (y) s = 0;
      else return -1;
    if (typeof i == "string" && (i = l.from(i, d)), l.isBuffer(i))
      return i.length === 0 ? -1 : F(f, i, s, d, y);
    if (typeof i == "number")
      return i = i & 255, typeof Uint8Array.prototype.indexOf == "function" ? y ? Uint8Array.prototype.indexOf.call(f, i, s) : Uint8Array.prototype.lastIndexOf.call(f, i, s) : F(f, [i], s, d, y);
    throw new TypeError("val must be string, number or Buffer");
  }
  function F(f, i, s, d, y) {
    var L = 1, N = f.length, $ = i.length;
    if (d !== void 0 && (d = String(d).toLowerCase(), d === "ucs2" || d === "ucs-2" || d === "utf16le" || d === "utf-16le")) {
      if (f.length < 2 || i.length < 2)
        return -1;
      L = 2, N /= 2, $ /= 2, s /= 2;
    }
    function ne(At, mt) {
      return L === 1 ? At[mt] : At.readUInt16BE(mt * L);
    }
    var re;
    if (y) {
      var pe = -1;
      for (re = s; re < N; re++)
        if (ne(f, re) === ne(i, pe === -1 ? 0 : re - pe)) {
          if (pe === -1 && (pe = re), re - pe + 1 === $) return pe * L;
        } else
          pe !== -1 && (re -= re - pe), pe = -1;
    } else
      for (s + $ > N && (s = N - $), re = s; re >= 0; re--) {
        for (var te = !0, He = 0; He < $; He++)
          if (ne(f, re + He) !== ne(i, He)) {
            te = !1;
            break;
          }
        if (te) return re;
      }
    return -1;
  }
  l.prototype.includes = function(i, s, d) {
    return this.indexOf(i, s, d) !== -1;
  }, l.prototype.indexOf = function(i, s, d) {
    return T(this, i, s, d, !0);
  }, l.prototype.lastIndexOf = function(i, s, d) {
    return T(this, i, s, d, !1);
  };
  function b(f, i, s, d) {
    s = Number(s) || 0;
    var y = f.length - s;
    d ? (d = Number(d), d > y && (d = y)) : d = y;
    var L = i.length;
    d > L / 2 && (d = L / 2);
    for (var N = 0; N < d; ++N) {
      var $ = parseInt(i.substr(N * 2, 2), 16);
      if (We($)) return N;
      f[s + N] = $;
    }
    return N;
  }
  function I(f, i, s, d) {
    return we(Me(i, f.length - s), f, s, d);
  }
  function v(f, i, s, d) {
    return we(it(i), f, s, d);
  }
  function k(f, i, s, d) {
    return we(ze(i), f, s, d);
  }
  function W(f, i, s, d) {
    return we(Je(i, f.length - s), f, s, d);
  }
  l.prototype.write = function(i, s, d, y) {
    if (s === void 0)
      y = "utf8", d = this.length, s = 0;
    else if (d === void 0 && typeof s == "string")
      y = s, d = this.length, s = 0;
    else if (isFinite(s))
      s = s >>> 0, isFinite(d) ? (d = d >>> 0, y === void 0 && (y = "utf8")) : (y = d, d = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    var L = this.length - s;
    if ((d === void 0 || d > L) && (d = L), i.length > 0 && (d < 0 || s < 0) || s > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    y || (y = "utf8");
    for (var N = !1; ; )
      switch (y) {
        case "hex":
          return b(this, i, s, d);
        case "utf8":
        case "utf-8":
          return I(this, i, s, d);
        case "ascii":
        case "latin1":
        case "binary":
          return v(this, i, s, d);
        case "base64":
          return k(this, i, s, d);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return W(this, i, s, d);
        default:
          if (N) throw new TypeError("Unknown encoding: " + y);
          y = ("" + y).toLowerCase(), N = !0;
      }
  }, l.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function O(f, i, s) {
    return i === 0 && s === f.length ? t.fromByteArray(f) : t.fromByteArray(f.slice(i, s));
  }
  function Z(f, i, s) {
    s = Math.min(f.length, s);
    for (var d = [], y = i; y < s; ) {
      var L = f[y], N = null, $ = L > 239 ? 4 : L > 223 ? 3 : L > 191 ? 2 : 1;
      if (y + $ <= s) {
        var ne, re, pe, te;
        switch ($) {
          case 1:
            L < 128 && (N = L);
            break;
          case 2:
            ne = f[y + 1], (ne & 192) === 128 && (te = (L & 31) << 6 | ne & 63, te > 127 && (N = te));
            break;
          case 3:
            ne = f[y + 1], re = f[y + 2], (ne & 192) === 128 && (re & 192) === 128 && (te = (L & 15) << 12 | (ne & 63) << 6 | re & 63, te > 2047 && (te < 55296 || te > 57343) && (N = te));
            break;
          case 4:
            ne = f[y + 1], re = f[y + 2], pe = f[y + 3], (ne & 192) === 128 && (re & 192) === 128 && (pe & 192) === 128 && (te = (L & 15) << 18 | (ne & 63) << 12 | (re & 63) << 6 | pe & 63, te > 65535 && te < 1114112 && (N = te));
        }
      }
      N === null ? (N = 65533, $ = 1) : N > 65535 && (N -= 65536, d.push(N >>> 10 & 1023 | 55296), N = 56320 | N & 1023), d.push(N), y += $;
    }
    return j(d);
  }
  var H = 4096;
  function j(f) {
    var i = f.length;
    if (i <= H)
      return String.fromCharCode.apply(String, f);
    for (var s = "", d = 0; d < i; )
      s += String.fromCharCode.apply(
        String,
        f.slice(d, d += H)
      );
    return s;
  }
  function K(f, i, s) {
    var d = "";
    s = Math.min(f.length, s);
    for (var y = i; y < s; ++y)
      d += String.fromCharCode(f[y] & 127);
    return d;
  }
  function X(f, i, s) {
    var d = "";
    s = Math.min(f.length, s);
    for (var y = i; y < s; ++y)
      d += String.fromCharCode(f[y]);
    return d;
  }
  function oe(f, i, s) {
    var d = f.length;
    (!i || i < 0) && (i = 0), (!s || s < 0 || s > d) && (s = d);
    for (var y = "", L = i; L < s; ++L)
      y += ue[f[L]];
    return y;
  }
  function G(f, i, s) {
    for (var d = f.slice(i, s), y = "", L = 0; L < d.length - 1; L += 2)
      y += String.fromCharCode(d[L] + d[L + 1] * 256);
    return y;
  }
  l.prototype.slice = function(i, s) {
    var d = this.length;
    i = ~~i, s = s === void 0 ? d : ~~s, i < 0 ? (i += d, i < 0 && (i = 0)) : i > d && (i = d), s < 0 ? (s += d, s < 0 && (s = 0)) : s > d && (s = d), s < i && (s = i);
    var y = this.subarray(i, s);
    return Object.setPrototypeOf(y, l.prototype), y;
  };
  function z(f, i, s) {
    if (f % 1 !== 0 || f < 0) throw new RangeError("offset is not uint");
    if (f + i > s) throw new RangeError("Trying to access beyond buffer length");
  }
  l.prototype.readUintLE = l.prototype.readUIntLE = function(i, s, d) {
    i = i >>> 0, s = s >>> 0, d || z(i, s, this.length);
    for (var y = this[i], L = 1, N = 0; ++N < s && (L *= 256); )
      y += this[i + N] * L;
    return y;
  }, l.prototype.readUintBE = l.prototype.readUIntBE = function(i, s, d) {
    i = i >>> 0, s = s >>> 0, d || z(i, s, this.length);
    for (var y = this[i + --s], L = 1; s > 0 && (L *= 256); )
      y += this[i + --s] * L;
    return y;
  }, l.prototype.readUint8 = l.prototype.readUInt8 = function(i, s) {
    return i = i >>> 0, s || z(i, 1, this.length), this[i];
  }, l.prototype.readUint16LE = l.prototype.readUInt16LE = function(i, s) {
    return i = i >>> 0, s || z(i, 2, this.length), this[i] | this[i + 1] << 8;
  }, l.prototype.readUint16BE = l.prototype.readUInt16BE = function(i, s) {
    return i = i >>> 0, s || z(i, 2, this.length), this[i] << 8 | this[i + 1];
  }, l.prototype.readUint32LE = l.prototype.readUInt32LE = function(i, s) {
    return i = i >>> 0, s || z(i, 4, this.length), (this[i] | this[i + 1] << 8 | this[i + 2] << 16) + this[i + 3] * 16777216;
  }, l.prototype.readUint32BE = l.prototype.readUInt32BE = function(i, s) {
    return i = i >>> 0, s || z(i, 4, this.length), this[i] * 16777216 + (this[i + 1] << 16 | this[i + 2] << 8 | this[i + 3]);
  }, l.prototype.readIntLE = function(i, s, d) {
    i = i >>> 0, s = s >>> 0, d || z(i, s, this.length);
    for (var y = this[i], L = 1, N = 0; ++N < s && (L *= 256); )
      y += this[i + N] * L;
    return L *= 128, y >= L && (y -= Math.pow(2, 8 * s)), y;
  }, l.prototype.readIntBE = function(i, s, d) {
    i = i >>> 0, s = s >>> 0, d || z(i, s, this.length);
    for (var y = s, L = 1, N = this[i + --y]; y > 0 && (L *= 256); )
      N += this[i + --y] * L;
    return L *= 128, N >= L && (N -= Math.pow(2, 8 * s)), N;
  }, l.prototype.readInt8 = function(i, s) {
    return i = i >>> 0, s || z(i, 1, this.length), this[i] & 128 ? (255 - this[i] + 1) * -1 : this[i];
  }, l.prototype.readInt16LE = function(i, s) {
    i = i >>> 0, s || z(i, 2, this.length);
    var d = this[i] | this[i + 1] << 8;
    return d & 32768 ? d | 4294901760 : d;
  }, l.prototype.readInt16BE = function(i, s) {
    i = i >>> 0, s || z(i, 2, this.length);
    var d = this[i + 1] | this[i] << 8;
    return d & 32768 ? d | 4294901760 : d;
  }, l.prototype.readInt32LE = function(i, s) {
    return i = i >>> 0, s || z(i, 4, this.length), this[i] | this[i + 1] << 8 | this[i + 2] << 16 | this[i + 3] << 24;
  }, l.prototype.readInt32BE = function(i, s) {
    return i = i >>> 0, s || z(i, 4, this.length), this[i] << 24 | this[i + 1] << 16 | this[i + 2] << 8 | this[i + 3];
  }, l.prototype.readFloatLE = function(i, s) {
    return i = i >>> 0, s || z(i, 4, this.length), e.read(this, i, !0, 23, 4);
  }, l.prototype.readFloatBE = function(i, s) {
    return i = i >>> 0, s || z(i, 4, this.length), e.read(this, i, !1, 23, 4);
  }, l.prototype.readDoubleLE = function(i, s) {
    return i = i >>> 0, s || z(i, 8, this.length), e.read(this, i, !0, 52, 8);
  }, l.prototype.readDoubleBE = function(i, s) {
    return i = i >>> 0, s || z(i, 8, this.length), e.read(this, i, !1, 52, 8);
  };
  function Y(f, i, s, d, y, L) {
    if (!l.isBuffer(f)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (i > y || i < L) throw new RangeError('"value" argument is out of bounds');
    if (s + d > f.length) throw new RangeError("Index out of range");
  }
  l.prototype.writeUintLE = l.prototype.writeUIntLE = function(i, s, d, y) {
    if (i = +i, s = s >>> 0, d = d >>> 0, !y) {
      var L = Math.pow(2, 8 * d) - 1;
      Y(this, i, s, d, L, 0);
    }
    var N = 1, $ = 0;
    for (this[s] = i & 255; ++$ < d && (N *= 256); )
      this[s + $] = i / N & 255;
    return s + d;
  }, l.prototype.writeUintBE = l.prototype.writeUIntBE = function(i, s, d, y) {
    if (i = +i, s = s >>> 0, d = d >>> 0, !y) {
      var L = Math.pow(2, 8 * d) - 1;
      Y(this, i, s, d, L, 0);
    }
    var N = d - 1, $ = 1;
    for (this[s + N] = i & 255; --N >= 0 && ($ *= 256); )
      this[s + N] = i / $ & 255;
    return s + d;
  }, l.prototype.writeUint8 = l.prototype.writeUInt8 = function(i, s, d) {
    return i = +i, s = s >>> 0, d || Y(this, i, s, 1, 255, 0), this[s] = i & 255, s + 1;
  }, l.prototype.writeUint16LE = l.prototype.writeUInt16LE = function(i, s, d) {
    return i = +i, s = s >>> 0, d || Y(this, i, s, 2, 65535, 0), this[s] = i & 255, this[s + 1] = i >>> 8, s + 2;
  }, l.prototype.writeUint16BE = l.prototype.writeUInt16BE = function(i, s, d) {
    return i = +i, s = s >>> 0, d || Y(this, i, s, 2, 65535, 0), this[s] = i >>> 8, this[s + 1] = i & 255, s + 2;
  }, l.prototype.writeUint32LE = l.prototype.writeUInt32LE = function(i, s, d) {
    return i = +i, s = s >>> 0, d || Y(this, i, s, 4, 4294967295, 0), this[s + 3] = i >>> 24, this[s + 2] = i >>> 16, this[s + 1] = i >>> 8, this[s] = i & 255, s + 4;
  }, l.prototype.writeUint32BE = l.prototype.writeUInt32BE = function(i, s, d) {
    return i = +i, s = s >>> 0, d || Y(this, i, s, 4, 4294967295, 0), this[s] = i >>> 24, this[s + 1] = i >>> 16, this[s + 2] = i >>> 8, this[s + 3] = i & 255, s + 4;
  }, l.prototype.writeIntLE = function(i, s, d, y) {
    if (i = +i, s = s >>> 0, !y) {
      var L = Math.pow(2, 8 * d - 1);
      Y(this, i, s, d, L - 1, -L);
    }
    var N = 0, $ = 1, ne = 0;
    for (this[s] = i & 255; ++N < d && ($ *= 256); )
      i < 0 && ne === 0 && this[s + N - 1] !== 0 && (ne = 1), this[s + N] = (i / $ >> 0) - ne & 255;
    return s + d;
  }, l.prototype.writeIntBE = function(i, s, d, y) {
    if (i = +i, s = s >>> 0, !y) {
      var L = Math.pow(2, 8 * d - 1);
      Y(this, i, s, d, L - 1, -L);
    }
    var N = d - 1, $ = 1, ne = 0;
    for (this[s + N] = i & 255; --N >= 0 && ($ *= 256); )
      i < 0 && ne === 0 && this[s + N + 1] !== 0 && (ne = 1), this[s + N] = (i / $ >> 0) - ne & 255;
    return s + d;
  }, l.prototype.writeInt8 = function(i, s, d) {
    return i = +i, s = s >>> 0, d || Y(this, i, s, 1, 127, -128), i < 0 && (i = 255 + i + 1), this[s] = i & 255, s + 1;
  }, l.prototype.writeInt16LE = function(i, s, d) {
    return i = +i, s = s >>> 0, d || Y(this, i, s, 2, 32767, -32768), this[s] = i & 255, this[s + 1] = i >>> 8, s + 2;
  }, l.prototype.writeInt16BE = function(i, s, d) {
    return i = +i, s = s >>> 0, d || Y(this, i, s, 2, 32767, -32768), this[s] = i >>> 8, this[s + 1] = i & 255, s + 2;
  }, l.prototype.writeInt32LE = function(i, s, d) {
    return i = +i, s = s >>> 0, d || Y(this, i, s, 4, 2147483647, -2147483648), this[s] = i & 255, this[s + 1] = i >>> 8, this[s + 2] = i >>> 16, this[s + 3] = i >>> 24, s + 4;
  }, l.prototype.writeInt32BE = function(i, s, d) {
    return i = +i, s = s >>> 0, d || Y(this, i, s, 4, 2147483647, -2147483648), i < 0 && (i = 4294967295 + i + 1), this[s] = i >>> 24, this[s + 1] = i >>> 16, this[s + 2] = i >>> 8, this[s + 3] = i & 255, s + 4;
  };
  function ee(f, i, s, d, y, L) {
    if (s + d > f.length) throw new RangeError("Index out of range");
    if (s < 0) throw new RangeError("Index out of range");
  }
  function Ce(f, i, s, d, y) {
    return i = +i, s = s >>> 0, y || ee(f, i, s, 4), e.write(f, i, s, d, 23, 4), s + 4;
  }
  l.prototype.writeFloatLE = function(i, s, d) {
    return Ce(this, i, s, !0, d);
  }, l.prototype.writeFloatBE = function(i, s, d) {
    return Ce(this, i, s, !1, d);
  };
  function de(f, i, s, d, y) {
    return i = +i, s = s >>> 0, y || ee(f, i, s, 8), e.write(f, i, s, d, 52, 8), s + 8;
  }
  l.prototype.writeDoubleLE = function(i, s, d) {
    return de(this, i, s, !0, d);
  }, l.prototype.writeDoubleBE = function(i, s, d) {
    return de(this, i, s, !1, d);
  }, l.prototype.copy = function(i, s, d, y) {
    if (!l.isBuffer(i)) throw new TypeError("argument should be a Buffer");
    if (d || (d = 0), !y && y !== 0 && (y = this.length), s >= i.length && (s = i.length), s || (s = 0), y > 0 && y < d && (y = d), y === d || i.length === 0 || this.length === 0) return 0;
    if (s < 0)
      throw new RangeError("targetStart out of bounds");
    if (d < 0 || d >= this.length) throw new RangeError("Index out of range");
    if (y < 0) throw new RangeError("sourceEnd out of bounds");
    y > this.length && (y = this.length), i.length - s < y - d && (y = i.length - s + d);
    var L = y - d;
    return this === i && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(s, d, y) : Uint8Array.prototype.set.call(
      i,
      this.subarray(d, y),
      s
    ), L;
  }, l.prototype.fill = function(i, s, d, y) {
    if (typeof i == "string") {
      if (typeof s == "string" ? (y = s, s = 0, d = this.length) : typeof d == "string" && (y = d, d = this.length), y !== void 0 && typeof y != "string")
        throw new TypeError("encoding must be a string");
      if (typeof y == "string" && !l.isEncoding(y))
        throw new TypeError("Unknown encoding: " + y);
      if (i.length === 1) {
        var L = i.charCodeAt(0);
        (y === "utf8" && L < 128 || y === "latin1") && (i = L);
      }
    } else typeof i == "number" ? i = i & 255 : typeof i == "boolean" && (i = Number(i));
    if (s < 0 || this.length < s || this.length < d)
      throw new RangeError("Out of range index");
    if (d <= s)
      return this;
    s = s >>> 0, d = d === void 0 ? this.length : d >>> 0, i || (i = 0);
    var N;
    if (typeof i == "number")
      for (N = s; N < d; ++N)
        this[N] = i;
    else {
      var $ = l.isBuffer(i) ? i : l.from(i, y), ne = $.length;
      if (ne === 0)
        throw new TypeError('The value "' + i + '" is invalid for argument "value"');
      for (N = 0; N < d - s; ++N)
        this[N + s] = $[N % ne];
    }
    return this;
  };
  var le = /[^+/0-9A-Za-z-_]/g;
  function pt(f) {
    if (f = f.split("=")[0], f = f.trim().replace(le, ""), f.length < 2) return "";
    for (; f.length % 4 !== 0; )
      f = f + "=";
    return f;
  }
  function Me(f, i) {
    i = i || 1 / 0;
    for (var s, d = f.length, y = null, L = [], N = 0; N < d; ++N) {
      if (s = f.charCodeAt(N), s > 55295 && s < 57344) {
        if (!y) {
          if (s > 56319) {
            (i -= 3) > -1 && L.push(239, 191, 189);
            continue;
          } else if (N + 1 === d) {
            (i -= 3) > -1 && L.push(239, 191, 189);
            continue;
          }
          y = s;
          continue;
        }
        if (s < 56320) {
          (i -= 3) > -1 && L.push(239, 191, 189), y = s;
          continue;
        }
        s = (y - 55296 << 10 | s - 56320) + 65536;
      } else y && (i -= 3) > -1 && L.push(239, 191, 189);
      if (y = null, s < 128) {
        if ((i -= 1) < 0) break;
        L.push(s);
      } else if (s < 2048) {
        if ((i -= 2) < 0) break;
        L.push(
          s >> 6 | 192,
          s & 63 | 128
        );
      } else if (s < 65536) {
        if ((i -= 3) < 0) break;
        L.push(
          s >> 12 | 224,
          s >> 6 & 63 | 128,
          s & 63 | 128
        );
      } else if (s < 1114112) {
        if ((i -= 4) < 0) break;
        L.push(
          s >> 18 | 240,
          s >> 12 & 63 | 128,
          s >> 6 & 63 | 128,
          s & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return L;
  }
  function it(f) {
    for (var i = [], s = 0; s < f.length; ++s)
      i.push(f.charCodeAt(s) & 255);
    return i;
  }
  function Je(f, i) {
    for (var s, d, y, L = [], N = 0; N < f.length && !((i -= 2) < 0); ++N)
      s = f.charCodeAt(N), d = s >> 8, y = s % 256, L.push(y), L.push(d);
    return L;
  }
  function ze(f) {
    return t.toByteArray(pt(f));
  }
  function we(f, i, s, d) {
    for (var y = 0; y < d && !(y + s >= i.length || y >= f.length); ++y)
      i[y + s] = f[y];
    return y;
  }
  function fe(f, i) {
    return f instanceof i || f != null && f.constructor != null && f.constructor.name != null && f.constructor.name === i.name;
  }
  function We(f) {
    return f !== f;
  }
  var ue = function() {
    for (var f = "0123456789abcdef", i = new Array(256), s = 0; s < 16; ++s)
      for (var d = s * 16, y = 0; y < 16; ++y)
        i[d + y] = f[s] + f[y];
    return i;
  }();
})(jr);
class Cn extends Fn {
  /**
   * @param {string} oid
   * @param {'blob'|'commit'|'tag'|'tree'} actual
   * @param {'blob'|'commit'|'tag'|'tree'} expected
   * @param {string} [filepath]
   */
  constructor(t, e, r, a) {
    super(
      `Object ${t} ${a ? `at ${a}` : ""}was anticipated to be a ${r} but it is a ${e}.`
    ), this.code = this.name = Cn.code, this.data = { oid: t, actual: e, expected: r, filepath: a };
  }
}
Cn.code = "ObjectTypeError";
typeof window < "u" && (window.Buffer = jr.Buffer);
const Yr = function() {
  return typeof process < "u" && process.release?.name === "node" ? "NODE" : typeof window < "u" ? "WEB" : (
    // @ts-ignore
    typeof WorkerGlobalScope < "u" && // @ts-ignore
    self instanceof WorkerGlobalScope ? "WORKER" : "NODE"
  );
}();
if (Yr === "NODE") {
  let n = function(e) {
    return new Promise(function(r, a) {
      e.onload = e.onerror = function(o) {
        e.onload = e.onerror = null, o.type === "load" ? r(e.result) : a(new Error("Failed to read the blob/file"));
      };
    });
  }, t = function() {
    const e = new Uint8Array([1, 2, 3, 4]), a = new File([e], "test").stream();
    try {
      return a.getReader({ mode: "byob" }), !0;
    } catch {
      return !1;
    }
  };
  if (typeof File > "u") {
    class e extends Blob {
      constructor(a, o, c) {
        super(a);
        let l;
        c?.lastModified && (l = /* @__PURE__ */ new Date()), (!l || isNaN(l.getFullYear())) && (l = /* @__PURE__ */ new Date()), this.lastModifiedDate = l, this.lastModified = l.getMilliseconds(), this.name = o || "";
      }
    }
    global.File = e;
  }
  typeof Blob.prototype.arrayBuffer > "u" && (Blob.prototype.arrayBuffer = function() {
    const r = new FileReader();
    return r.readAsArrayBuffer(this), n(r);
  }), typeof Blob.prototype.text > "u" && (Blob.prototype.text = function() {
    const r = new FileReader();
    return r.readAsText(this), n(r);
  }), (typeof Blob.prototype.stream > "u" || !t()) && (Blob.prototype.stream = function() {
    let e = 0;
    const r = this;
    return new ReadableStream({
      type: "bytes",
      // 0.5 MB seems like a reasonable chunk size, let's adjust
      // this if needed.
      autoAllocateChunkSize: 512 * 1024,
      async pull(a) {
        const o = a.byobRequest.view, l = await r.slice(
          e,
          e + o.byteLength
        ).arrayBuffer(), u = new Uint8Array(l);
        new Uint8Array(o.buffer).set(u);
        const g = u.byteLength;
        a.byobRequest.respond(g), e += g, e >= r.size && a.close();
      }
    });
  });
}
if (Yr === "NODE" && typeof CustomEvent > "u") {
  class n extends Event {
    constructor(e, r = {}) {
      super(e, r), this.detail = r.detail;
    }
    initCustomEvent() {
    }
  }
  globalThis.CustomEvent = n;
}
function es(...n) {
  const t = new Uint8Array(
    n.reduce((r, a) => r + a.length, 0)
  );
  let e = 0;
  for (const r of n)
    t.set(r, e), e += r.length;
  return t;
}
function ts(n) {
  {
    let t = new Uint8Array();
    return new TransformStream({
      transform(e) {
        t = es(t, e);
      },
      flush(e) {
        e.enqueue(t);
      }
    });
  }
}
async function ns(n, t) {
  return await n.pipeThrough(ts()).getReader().read().then(({ value: e }) => e);
}
class Yt extends File {
  /**
   * Creates a new StreamedFile instance.
   *
   * @param readableStream The readable stream containing the file data.
   * @param name The name of the file.
   * @param options An object containing options such as the MIME type and file size.
   */
  constructor(t, e, r) {
    super([], e, { type: r?.type }), this.readableStream = t, this.filesize = r?.filesize;
  }
  /**
   * Overrides the slice() method of the File class.
   *
   * @returns A Blob representing a portion of the file.
   */
  slice() {
    throw new Error("slice() is not possible on a StreamedFile");
  }
  /**
   * Returns the readable stream associated with the file.
   *
   * @returns The readable stream.
   */
  stream() {
    return this.readableStream;
  }
  /**
   * Loads the file data into memory and then returns it as a string.
   *
   * @returns File data as text.
   */
  async text() {
    return new TextDecoder().decode(await this.arrayBuffer());
  }
  /**
   * Loads the file data into memory and then returns it as an ArrayBuffer.
   *
   * @returns File data as an ArrayBuffer.
   */
  async arrayBuffer() {
    return await ns(this.stream());
  }
}
ReadableStream.prototype[Symbol.asyncIterator] || (ReadableStream.prototype[Symbol.asyncIterator] = async function* () {
  const n = this.getReader();
  try {
    for (; ; ) {
      const { done: t, value: e } = await n.read();
      if (t)
        return;
      yield e;
    }
  } finally {
    n.releaseLock();
  }
}, ReadableStream.prototype.iterate = // @ts-ignore
ReadableStream.prototype[Symbol.asyncIterator]);
new Tn({ concurrency: 10 });
const bt = 15, gn = 30, bn = 19, rs = 29, Gt = 256, In = Gt + 1 + rs, Mn = 2 * In + 1, ht = 256, is = 7, Wn = 16, qn = 17, jn = 18, rn = 8 * 2, Vt = -1, ss = 1, Rt = 2, as = 0, lt = 0, Hn = 1, os = 3, Ee = 4, Le = 0, Gr = 1, Ct = 2, Ue = -2, cs = -3, at = -5;
function zt(n) {
  return Qt(n.map(([t, e]) => new Array(t).fill(e, 0, t)));
}
function Qt(n) {
  return n.reduce((t, e) => t.concat(Array.isArray(e) ? Qt(e) : e), []);
}
const Yn = [0, 1, 2, 3].concat(...zt([
  [2, 4],
  [2, 5],
  [4, 6],
  [4, 7],
  [8, 8],
  [8, 9],
  [16, 10],
  [16, 11],
  [32, 12],
  [32, 13],
  [64, 14],
  [64, 15],
  [2, 0],
  [1, 16],
  [1, 17],
  [2, 18],
  [2, 19],
  [4, 20],
  [4, 21],
  [8, 22],
  [8, 23],
  [16, 24],
  [16, 25],
  [32, 26],
  [32, 27],
  [64, 28],
  [64, 29]
]));
function ie() {
  const n = this;
  function t(a) {
    const o = n.dyn_tree, c = n.stat_desc.static_tree, l = n.stat_desc.extra_bits, u = n.stat_desc.extra_base, g = n.stat_desc.max_length;
    let x, w, _, A, P, h, p = 0;
    for (A = 0; A <= bt; A++)
      a.bl_count[A] = 0;
    for (o[a.heap[a.heap_max] * 2 + 1] = 0, x = a.heap_max + 1; x < Mn; x++)
      w = a.heap[x], A = o[o[w * 2 + 1] * 2 + 1] + 1, A > g && (A = g, p++), o[w * 2 + 1] = A, !(w > n.max_code) && (a.bl_count[A]++, P = 0, w >= u && (P = l[w - u]), h = o[w * 2], a.opt_len += h * (A + P), c && (a.static_len += h * (c[w * 2 + 1] + P)));
    if (p !== 0) {
      do {
        for (A = g - 1; a.bl_count[A] === 0; )
          A--;
        a.bl_count[A]--, a.bl_count[A + 1] += 2, a.bl_count[g]--, p -= 2;
      } while (p > 0);
      for (A = g; A !== 0; A--)
        for (w = a.bl_count[A]; w !== 0; )
          _ = a.heap[--x], !(_ > n.max_code) && (o[_ * 2 + 1] != A && (a.opt_len += (A - o[_ * 2 + 1]) * o[_ * 2], o[_ * 2 + 1] = A), w--);
    }
  }
  function e(a, o) {
    let c = 0;
    do
      c |= a & 1, a >>>= 1, c <<= 1;
    while (--o > 0);
    return c >>> 1;
  }
  function r(a, o, c) {
    const l = [];
    let u = 0, g, x, w;
    for (g = 1; g <= bt; g++)
      l[g] = u = u + c[g - 1] << 1;
    for (x = 0; x <= o; x++)
      w = a[x * 2 + 1], w !== 0 && (a[x * 2] = e(l[w]++, w));
  }
  n.build_tree = function(a) {
    const o = n.dyn_tree, c = n.stat_desc.static_tree, l = n.stat_desc.elems;
    let u, g, x = -1, w;
    for (a.heap_len = 0, a.heap_max = Mn, u = 0; u < l; u++)
      o[u * 2] !== 0 ? (a.heap[++a.heap_len] = x = u, a.depth[u] = 0) : o[u * 2 + 1] = 0;
    for (; a.heap_len < 2; )
      w = a.heap[++a.heap_len] = x < 2 ? ++x : 0, o[w * 2] = 1, a.depth[w] = 0, a.opt_len--, c && (a.static_len -= c[w * 2 + 1]);
    for (n.max_code = x, u = Math.floor(a.heap_len / 2); u >= 1; u--)
      a.pqdownheap(o, u);
    w = l;
    do
      u = a.heap[1], a.heap[1] = a.heap[a.heap_len--], a.pqdownheap(o, 1), g = a.heap[1], a.heap[--a.heap_max] = u, a.heap[--a.heap_max] = g, o[w * 2] = o[u * 2] + o[g * 2], a.depth[w] = Math.max(a.depth[u], a.depth[g]) + 1, o[u * 2 + 1] = o[g * 2 + 1] = w, a.heap[1] = w++, a.pqdownheap(o, 1);
    while (a.heap_len >= 2);
    a.heap[--a.heap_max] = a.heap[1], t(a), r(o, n.max_code, a.bl_count);
  };
}
ie._length_code = [0, 1, 2, 3, 4, 5, 6, 7].concat(...zt([
  [2, 8],
  [2, 9],
  [2, 10],
  [2, 11],
  [4, 12],
  [4, 13],
  [4, 14],
  [4, 15],
  [8, 16],
  [8, 17],
  [8, 18],
  [8, 19],
  [16, 20],
  [16, 21],
  [16, 22],
  [16, 23],
  [32, 24],
  [32, 25],
  [32, 26],
  [31, 27],
  [1, 28]
]));
ie.base_length = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0];
ie.base_dist = [
  0,
  1,
  2,
  3,
  4,
  6,
  8,
  12,
  16,
  24,
  32,
  48,
  64,
  96,
  128,
  192,
  256,
  384,
  512,
  768,
  1024,
  1536,
  2048,
  3072,
  4096,
  6144,
  8192,
  12288,
  16384,
  24576
];
ie.d_code = function(n) {
  return n < 256 ? Yn[n] : Yn[256 + (n >>> 7)];
};
ie.extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
ie.extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
ie.extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
ie.bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
function xe(n, t, e, r, a) {
  const o = this;
  o.static_tree = n, o.extra_bits = t, o.extra_base = e, o.elems = r, o.max_length = a;
}
const ls = [
  12,
  140,
  76,
  204,
  44,
  172,
  108,
  236,
  28,
  156,
  92,
  220,
  60,
  188,
  124,
  252,
  2,
  130,
  66,
  194,
  34,
  162,
  98,
  226,
  18,
  146,
  82,
  210,
  50,
  178,
  114,
  242,
  10,
  138,
  74,
  202,
  42,
  170,
  106,
  234,
  26,
  154,
  90,
  218,
  58,
  186,
  122,
  250,
  6,
  134,
  70,
  198,
  38,
  166,
  102,
  230,
  22,
  150,
  86,
  214,
  54,
  182,
  118,
  246,
  14,
  142,
  78,
  206,
  46,
  174,
  110,
  238,
  30,
  158,
  94,
  222,
  62,
  190,
  126,
  254,
  1,
  129,
  65,
  193,
  33,
  161,
  97,
  225,
  17,
  145,
  81,
  209,
  49,
  177,
  113,
  241,
  9,
  137,
  73,
  201,
  41,
  169,
  105,
  233,
  25,
  153,
  89,
  217,
  57,
  185,
  121,
  249,
  5,
  133,
  69,
  197,
  37,
  165,
  101,
  229,
  21,
  149,
  85,
  213,
  53,
  181,
  117,
  245,
  13,
  141,
  77,
  205,
  45,
  173,
  109,
  237,
  29,
  157,
  93,
  221,
  61,
  189,
  125,
  253,
  19,
  275,
  147,
  403,
  83,
  339,
  211,
  467,
  51,
  307,
  179,
  435,
  115,
  371,
  243,
  499,
  11,
  267,
  139,
  395,
  75,
  331,
  203,
  459,
  43,
  299,
  171,
  427,
  107,
  363,
  235,
  491,
  27,
  283,
  155,
  411,
  91,
  347,
  219,
  475,
  59,
  315,
  187,
  443,
  123,
  379,
  251,
  507,
  7,
  263,
  135,
  391,
  71,
  327,
  199,
  455,
  39,
  295,
  167,
  423,
  103,
  359,
  231,
  487,
  23,
  279,
  151,
  407,
  87,
  343,
  215,
  471,
  55,
  311,
  183,
  439,
  119,
  375,
  247,
  503,
  15,
  271,
  143,
  399,
  79,
  335,
  207,
  463,
  47,
  303,
  175,
  431,
  111,
  367,
  239,
  495,
  31,
  287,
  159,
  415,
  95,
  351,
  223,
  479,
  63,
  319,
  191,
  447,
  127,
  383,
  255,
  511,
  0,
  64,
  32,
  96,
  16,
  80,
  48,
  112,
  8,
  72,
  40,
  104,
  24,
  88,
  56,
  120,
  4,
  68,
  36,
  100,
  20,
  84,
  52,
  116,
  3,
  131,
  67,
  195,
  35,
  163,
  99,
  227
], fs = zt([[144, 8], [112, 9], [24, 7], [8, 8]]);
xe.static_ltree = Qt(ls.map((n, t) => [n, fs[t]]));
const us = [0, 16, 8, 24, 4, 20, 12, 28, 2, 18, 10, 26, 6, 22, 14, 30, 1, 17, 9, 25, 5, 21, 13, 29, 3, 19, 11, 27, 7, 23], ds = zt([[30, 5]]);
xe.static_dtree = Qt(us.map((n, t) => [n, ds[t]]));
xe.static_l_desc = new xe(xe.static_ltree, ie.extra_lbits, Gt + 1, In, bt);
xe.static_d_desc = new xe(xe.static_dtree, ie.extra_dbits, 0, gn, bt);
xe.static_bl_desc = new xe(null, ie.extra_blbits, 0, bn, is);
const ps = 9, ms = 8;
function Oe(n, t, e, r, a) {
  const o = this;
  o.good_length = n, o.max_lazy = t, o.nice_length = e, o.max_chain = r, o.func = a;
}
const Vr = 0, Mt = 1, et = 2, De = [
  new Oe(0, 0, 0, 0, Vr),
  new Oe(4, 4, 8, 4, Mt),
  new Oe(4, 5, 16, 8, Mt),
  new Oe(4, 6, 32, 32, Mt),
  new Oe(4, 4, 16, 16, et),
  new Oe(8, 16, 32, 32, et),
  new Oe(8, 16, 128, 128, et),
  new Oe(8, 32, 128, 256, et),
  new Oe(32, 128, 258, 1024, et),
  new Oe(32, 258, 258, 4096, et)
], It = [
  "need dictionary",
  // Z_NEED_DICT
  // 2
  "stream end",
  // Z_STREAM_END 1
  "",
  // Z_OK 0
  "",
  // Z_ERRNO (-1)
  "stream error",
  // Z_STREAM_ERROR (-2)
  "data error",
  // Z_DATA_ERROR (-3)
  "",
  // Z_MEM_ERROR (-4)
  "buffer error",
  // Z_BUF_ERROR (-5)
  "",
  // Z_VERSION_ERROR (-6)
  ""
], Te = 0, Dt = 1, xt = 2, Lt = 3, hs = 32, sn = 42, Ut = 113, wt = 666, an = 8, xs = 0, on = 1, ws = 2, ae = 3, Wt = 258, Se = Wt + ae + 1;
function Gn(n, t, e, r) {
  const a = n[t * 2], o = n[e * 2];
  return a < o || a == o && r[t] <= r[e];
}
function _s() {
  const n = this;
  let t, e, r, a, o, c, l, u, g, x, w, _, A, P, h, p, m, E, R, D, S, T, F, b, I, v, k, W, O, Z, H, j, K;
  const X = new ie(), oe = new ie(), G = new ie();
  n.depth = [];
  let z, Y, ee, Ce, de, le;
  n.bl_count = [], n.heap = [], H = [], j = [], K = [];
  function pt() {
    g = 2 * o, w[A - 1] = 0;
    for (let C = 0; C < A - 1; C++)
      w[C] = 0;
    v = De[k].max_lazy, O = De[k].good_length, Z = De[k].nice_length, I = De[k].max_chain, S = 0, m = 0, F = 0, E = b = ae - 1, D = 0, _ = 0;
  }
  function Me() {
    let C;
    for (C = 0; C < In; C++)
      H[C * 2] = 0;
    for (C = 0; C < gn; C++)
      j[C * 2] = 0;
    for (C = 0; C < bn; C++)
      K[C * 2] = 0;
    H[ht * 2] = 1, n.opt_len = n.static_len = 0, Y = ee = 0;
  }
  function it() {
    X.dyn_tree = H, X.stat_desc = xe.static_l_desc, oe.dyn_tree = j, oe.stat_desc = xe.static_d_desc, G.dyn_tree = K, G.stat_desc = xe.static_bl_desc, de = 0, le = 0, Ce = 8, Me();
  }
  n.pqdownheap = function(C, B) {
    const U = n.heap, M = U[B];
    let q = B << 1;
    for (; q <= n.heap_len && (q < n.heap_len && Gn(C, U[q + 1], U[q], n.depth) && q++, !Gn(C, M, U[q], n.depth)); )
      U[B] = U[q], B = q, q <<= 1;
    U[B] = M;
  };
  function Je(C, B) {
    let U = -1, M, q = C[0 * 2 + 1], V = 0, J = 7, ge = 4;
    q === 0 && (J = 138, ge = 3), C[(B + 1) * 2 + 1] = 65535;
    for (let Ie = 0; Ie <= B; Ie++)
      M = q, q = C[(Ie + 1) * 2 + 1], !(++V < J && M == q) && (V < ge ? K[M * 2] += V : M !== 0 ? (M != U && K[M * 2]++, K[Wn * 2]++) : V <= 10 ? K[qn * 2]++ : K[jn * 2]++, V = 0, U = M, q === 0 ? (J = 138, ge = 3) : M == q ? (J = 6, ge = 3) : (J = 7, ge = 4));
  }
  function ze() {
    let C;
    for (Je(H, X.max_code), Je(j, oe.max_code), G.build_tree(n), C = bn - 1; C >= 3 && K[ie.bl_order[C] * 2 + 1] === 0; C--)
      ;
    return n.opt_len += 3 * (C + 1) + 5 + 5 + 4, C;
  }
  function we(C) {
    n.pending_buf[n.pending++] = C;
  }
  function fe(C) {
    we(C & 255), we(C >>> 8 & 255);
  }
  function We(C) {
    we(C >> 8 & 255), we(C & 255 & 255);
  }
  function ue(C, B) {
    let U;
    const M = B;
    le > rn - M ? (U = C, de |= U << le & 65535, fe(de), de = U >>> rn - le, le += M - rn) : (de |= C << le & 65535, le += M);
  }
  function f(C, B) {
    const U = C * 2;
    ue(B[U] & 65535, B[U + 1] & 65535);
  }
  function i(C, B) {
    let U, M = -1, q, V = C[0 * 2 + 1], J = 0, ge = 7, Ie = 4;
    for (V === 0 && (ge = 138, Ie = 3), U = 0; U <= B; U++)
      if (q = V, V = C[(U + 1) * 2 + 1], !(++J < ge && q == V)) {
        if (J < Ie)
          do
            f(q, K);
          while (--J !== 0);
        else q !== 0 ? (q != M && (f(q, K), J--), f(Wn, K), ue(J - 3, 2)) : J <= 10 ? (f(qn, K), ue(J - 3, 3)) : (f(jn, K), ue(J - 11, 7));
        J = 0, M = q, V === 0 ? (ge = 138, Ie = 3) : q == V ? (ge = 6, Ie = 3) : (ge = 7, Ie = 4);
      }
  }
  function s(C, B, U) {
    let M;
    for (ue(C - 257, 5), ue(B - 1, 5), ue(U - 4, 4), M = 0; M < U; M++)
      ue(K[ie.bl_order[M] * 2 + 1], 3);
    i(H, C - 1), i(j, B - 1);
  }
  function d() {
    le == 16 ? (fe(de), de = 0, le = 0) : le >= 8 && (we(de & 255), de >>>= 8, le -= 8);
  }
  function y() {
    ue(on << 1, 3), f(ht, xe.static_ltree), d(), 1 + Ce + 10 - le < 9 && (ue(on << 1, 3), f(ht, xe.static_ltree), d()), Ce = 7;
  }
  function L(C, B) {
    let U, M, q;
    if (n.dist_buf[Y] = C, n.lc_buf[Y] = B & 255, Y++, C === 0 ? H[B * 2]++ : (ee++, C--, H[(ie._length_code[B] + Gt + 1) * 2]++, j[ie.d_code(C) * 2]++), !(Y & 8191) && k > 2) {
      for (U = Y * 8, M = S - m, q = 0; q < gn; q++)
        U += j[q * 2] * (5 + ie.extra_dbits[q]);
      if (U >>>= 3, ee < Math.floor(Y / 2) && U < Math.floor(M / 2))
        return !0;
    }
    return Y == z - 1;
  }
  function N(C, B) {
    let U, M, q = 0, V, J;
    if (Y !== 0)
      do
        U = n.dist_buf[q], M = n.lc_buf[q], q++, U === 0 ? f(M, C) : (V = ie._length_code[M], f(V + Gt + 1, C), J = ie.extra_lbits[V], J !== 0 && (M -= ie.base_length[V], ue(M, J)), U--, V = ie.d_code(U), f(V, B), J = ie.extra_dbits[V], J !== 0 && (U -= ie.base_dist[V], ue(U, J)));
      while (q < Y);
    f(ht, C), Ce = C[ht * 2 + 1];
  }
  function $() {
    le > 8 ? fe(de) : le > 0 && we(de & 255), de = 0, le = 0;
  }
  function ne(C, B, U) {
    $(), Ce = 8, fe(B), fe(~B), n.pending_buf.set(u.subarray(C, C + B), n.pending), n.pending += B;
  }
  function re(C, B, U) {
    ue((xs << 1) + (U ? 1 : 0), 3), ne(C, B);
  }
  function pe(C, B, U) {
    let M, q, V = 0;
    k > 0 ? (X.build_tree(n), oe.build_tree(n), V = ze(), M = n.opt_len + 3 + 7 >>> 3, q = n.static_len + 3 + 7 >>> 3, q <= M && (M = q)) : M = q = B + 5, B + 4 <= M && C != -1 ? re(C, B, U) : q == M ? (ue((on << 1) + (U ? 1 : 0), 3), N(xe.static_ltree, xe.static_dtree)) : (ue((ws << 1) + (U ? 1 : 0), 3), s(X.max_code + 1, oe.max_code + 1, V + 1), N(H, j)), Me(), U && $();
  }
  function te(C) {
    pe(m >= 0 ? m : -1, S - m, C), m = S, t.flush_pending();
  }
  function He() {
    let C, B, U, M;
    do {
      if (M = g - F - S, M === 0 && S === 0 && F === 0)
        M = o;
      else if (M == -1)
        M--;
      else if (S >= o + o - Se) {
        u.set(u.subarray(o, o + o), 0), T -= o, S -= o, m -= o, C = A, U = C;
        do
          B = w[--U] & 65535, w[U] = B >= o ? B - o : 0;
        while (--C !== 0);
        C = o, U = C;
        do
          B = x[--U] & 65535, x[U] = B >= o ? B - o : 0;
        while (--C !== 0);
        M += o;
      }
      if (t.avail_in === 0)
        return;
      C = t.read_buf(u, S + F, M), F += C, F >= ae && (_ = u[S] & 255, _ = (_ << p ^ u[S + 1] & 255) & h);
    } while (F < Se && t.avail_in !== 0);
  }
  function At(C) {
    let B = 65535, U;
    for (B > r - 5 && (B = r - 5); ; ) {
      if (F <= 1) {
        if (He(), F === 0 && C == lt)
          return Te;
        if (F === 0)
          break;
      }
      if (S += F, F = 0, U = m + B, (S === 0 || S >= U) && (F = S - U, S = U, te(!1), t.avail_out === 0) || S - m >= o - Se && (te(!1), t.avail_out === 0))
        return Te;
    }
    return te(C == Ee), t.avail_out === 0 ? C == Ee ? xt : Te : C == Ee ? Lt : Dt;
  }
  function mt(C) {
    let B = I, U = S, M, q, V = b;
    const J = S > o - Se ? S - (o - Se) : 0;
    let ge = Z;
    const Ie = l, tn = S + Wt;
    let Bn = u[U + V - 1], Nn = u[U + V];
    b >= O && (B >>= 2), ge > F && (ge = F);
    do
      if (M = C, !(u[M + V] != Nn || u[M + V - 1] != Bn || u[M] != u[U] || u[++M] != u[U + 1])) {
        U += 2, M++;
        do
          ;
        while (u[++U] == u[++M] && u[++U] == u[++M] && u[++U] == u[++M] && u[++U] == u[++M] && u[++U] == u[++M] && u[++U] == u[++M] && u[++U] == u[++M] && u[++U] == u[++M] && U < tn);
        if (q = Wt - (tn - U), U = tn - Wt, q > V) {
          if (T = C, V = q, q >= ge)
            break;
          Bn = u[U + V - 1], Nn = u[U + V];
        }
      }
    while ((C = x[C & Ie] & 65535) > J && --B !== 0);
    return V <= F ? V : F;
  }
  function Oi(C) {
    let B = 0, U;
    for (; ; ) {
      if (F < Se) {
        if (He(), F < Se && C == lt)
          return Te;
        if (F === 0)
          break;
      }
      if (F >= ae && (_ = (_ << p ^ u[S + (ae - 1)] & 255) & h, B = w[_] & 65535, x[S & l] = w[_], w[_] = S), B !== 0 && (S - B & 65535) <= o - Se && W != Rt && (E = mt(B)), E >= ae)
        if (U = L(S - T, E - ae), F -= E, E <= v && F >= ae) {
          E--;
          do
            S++, _ = (_ << p ^ u[S + (ae - 1)] & 255) & h, B = w[_] & 65535, x[S & l] = w[_], w[_] = S;
          while (--E !== 0);
          S++;
        } else
          S += E, E = 0, _ = u[S] & 255, _ = (_ << p ^ u[S + 1] & 255) & h;
      else
        U = L(0, u[S] & 255), F--, S++;
      if (U && (te(!1), t.avail_out === 0))
        return Te;
    }
    return te(C == Ee), t.avail_out === 0 ? C == Ee ? xt : Te : C == Ee ? Lt : Dt;
  }
  function Pi(C) {
    let B = 0, U, M;
    for (; ; ) {
      if (F < Se) {
        if (He(), F < Se && C == lt)
          return Te;
        if (F === 0)
          break;
      }
      if (F >= ae && (_ = (_ << p ^ u[S + (ae - 1)] & 255) & h, B = w[_] & 65535, x[S & l] = w[_], w[_] = S), b = E, R = T, E = ae - 1, B !== 0 && b < v && (S - B & 65535) <= o - Se && (W != Rt && (E = mt(B)), E <= 5 && (W == ss || E == ae && S - T > 4096) && (E = ae - 1)), b >= ae && E <= b) {
        M = S + F - ae, U = L(S - 1 - R, b - ae), F -= b - 1, b -= 2;
        do
          ++S <= M && (_ = (_ << p ^ u[S + (ae - 1)] & 255) & h, B = w[_] & 65535, x[S & l] = w[_], w[_] = S);
        while (--b !== 0);
        if (D = 0, E = ae - 1, S++, U && (te(!1), t.avail_out === 0))
          return Te;
      } else if (D !== 0) {
        if (U = L(0, u[S - 1] & 255), U && te(!1), S++, F--, t.avail_out === 0)
          return Te;
      } else
        D = 1, S++, F--;
    }
    return D !== 0 && (U = L(0, u[S - 1] & 255), D = 0), te(C == Ee), t.avail_out === 0 ? C == Ee ? xt : Te : C == Ee ? Lt : Dt;
  }
  function Bi(C) {
    return C.total_in = C.total_out = 0, C.msg = null, n.pending = 0, n.pending_out = 0, e = Ut, a = lt, it(), pt(), Le;
  }
  n.deflateInit = function(C, B, U, M, q, V) {
    return M || (M = an), q || (q = ms), V || (V = as), C.msg = null, B == Vt && (B = 6), q < 1 || q > ps || M != an || U < 9 || U > 15 || B < 0 || B > 9 || V < 0 || V > Rt ? Ue : (C.dstate = n, c = U, o = 1 << c, l = o - 1, P = q + 7, A = 1 << P, h = A - 1, p = Math.floor((P + ae - 1) / ae), u = new Uint8Array(o * 2), x = [], w = [], z = 1 << q + 6, n.pending_buf = new Uint8Array(z * 4), r = z * 4, n.dist_buf = new Uint16Array(z), n.lc_buf = new Uint8Array(z), k = B, W = V, Bi(C));
  }, n.deflateEnd = function() {
    return e != sn && e != Ut && e != wt ? Ue : (n.lc_buf = null, n.dist_buf = null, n.pending_buf = null, w = null, x = null, u = null, n.dstate = null, e == Ut ? cs : Le);
  }, n.deflateParams = function(C, B, U) {
    let M = Le;
    return B == Vt && (B = 6), B < 0 || B > 9 || U < 0 || U > Rt ? Ue : (De[k].func != De[B].func && C.total_in !== 0 && (M = C.deflate(Hn)), k != B && (k = B, v = De[k].max_lazy, O = De[k].good_length, Z = De[k].nice_length, I = De[k].max_chain), W = U, M);
  }, n.deflateSetDictionary = function(C, B, U) {
    let M = U, q, V = 0;
    if (!B || e != sn)
      return Ue;
    if (M < ae)
      return Le;
    for (M > o - Se && (M = o - Se, V = U - M), u.set(B.subarray(V, V + M), 0), S = M, m = M, _ = u[0] & 255, _ = (_ << p ^ u[1] & 255) & h, q = 0; q <= M - ae; q++)
      _ = (_ << p ^ u[q + (ae - 1)] & 255) & h, x[q & l] = w[_], w[_] = q;
    return Le;
  }, n.deflate = function(C, B) {
    let U, M, q, V, J;
    if (B > Ee || B < 0)
      return Ue;
    if (!C.next_out || !C.next_in && C.avail_in !== 0 || e == wt && B != Ee)
      return C.msg = It[Ct - Ue], Ue;
    if (C.avail_out === 0)
      return C.msg = It[Ct - at], at;
    if (t = C, V = a, a = B, e == sn && (M = an + (c - 8 << 4) << 8, q = (k - 1 & 255) >> 1, q > 3 && (q = 3), M |= q << 6, S !== 0 && (M |= hs), M += 31 - M % 31, e = Ut, We(M)), n.pending !== 0) {
      if (t.flush_pending(), t.avail_out === 0)
        return a = -1, Le;
    } else if (t.avail_in === 0 && B <= V && B != Ee)
      return t.msg = It[Ct - at], at;
    if (e == wt && t.avail_in !== 0)
      return C.msg = It[Ct - at], at;
    if (t.avail_in !== 0 || F !== 0 || B != lt && e != wt) {
      switch (J = -1, De[k].func) {
        case Vr:
          J = At(B);
          break;
        case Mt:
          J = Oi(B);
          break;
        case et:
          J = Pi(B);
          break;
      }
      if ((J == xt || J == Lt) && (e = wt), J == Te || J == xt)
        return t.avail_out === 0 && (a = -1), Le;
      if (J == Dt) {
        if (B == Hn)
          y();
        else if (re(0, 0, !1), B == os)
          for (U = 0; U < A; U++)
            w[U] = 0;
        if (t.flush_pending(), t.avail_out === 0)
          return a = -1, Le;
      }
    }
    return B != Ee ? Le : Gr;
  };
}
function Zr() {
  const n = this;
  n.next_in_index = 0, n.next_out_index = 0, n.avail_in = 0, n.total_in = 0, n.avail_out = 0, n.total_out = 0;
}
Zr.prototype = {
  deflateInit(n, t) {
    const e = this;
    return e.dstate = new _s(), t || (t = bt), e.dstate.deflateInit(e, n, t);
  },
  deflate(n) {
    const t = this;
    return t.dstate ? t.dstate.deflate(t, n) : Ue;
  },
  deflateEnd() {
    const n = this;
    if (!n.dstate)
      return Ue;
    const t = n.dstate.deflateEnd();
    return n.dstate = null, t;
  },
  deflateParams(n, t) {
    const e = this;
    return e.dstate ? e.dstate.deflateParams(e, n, t) : Ue;
  },
  deflateSetDictionary(n, t) {
    const e = this;
    return e.dstate ? e.dstate.deflateSetDictionary(e, n, t) : Ue;
  },
  // Read a new buffer from the current input stream, update the
  // total number of bytes read. All deflate() input goes through
  // this function so some applications may wish to modify it to avoid
  // allocating a large strm->next_in buffer and copying from it.
  // (See also flush_pending()).
  read_buf(n, t, e) {
    const r = this;
    let a = r.avail_in;
    return a > e && (a = e), a === 0 ? 0 : (r.avail_in -= a, n.set(r.next_in.subarray(r.next_in_index, r.next_in_index + a), t), r.next_in_index += a, r.total_in += a, a);
  },
  // Flush as much pending output as possible. All deflate() output goes
  // through this function so some applications may wish to modify it
  // to avoid allocating a large strm->next_out buffer and copying into it.
  // (See also read_buf()).
  flush_pending() {
    const n = this;
    let t = n.dstate.pending;
    t > n.avail_out && (t = n.avail_out), t !== 0 && (n.next_out.set(n.dstate.pending_buf.subarray(n.dstate.pending_out, n.dstate.pending_out + t), n.next_out_index), n.next_out_index += t, n.dstate.pending_out += t, n.total_out += t, n.avail_out -= t, n.dstate.pending -= t, n.dstate.pending === 0 && (n.dstate.pending_out = 0));
  }
};
function gs(n) {
  const t = this, e = new Zr(), r = bs(n && n.chunkSize ? n.chunkSize : 64 * 1024), a = lt, o = new Uint8Array(r);
  let c = n ? n.level : Vt;
  typeof c > "u" && (c = Vt), e.deflateInit(c), e.next_out = o, t.append = function(l, u) {
    let g, x, w = 0, _ = 0, A = 0;
    const P = [];
    if (l.length) {
      e.next_in_index = 0, e.next_in = l, e.avail_in = l.length;
      do {
        if (e.next_out_index = 0, e.avail_out = r, g = e.deflate(a), g != Le)
          throw new Error("deflating: " + e.msg);
        e.next_out_index && (e.next_out_index == r ? P.push(new Uint8Array(o)) : P.push(o.subarray(0, e.next_out_index))), A += e.next_out_index, u && e.next_in_index > 0 && e.next_in_index != w && (u(e.next_in_index), w = e.next_in_index);
      } while (e.avail_in > 0 || e.avail_out === 0);
      return P.length > 1 ? (x = new Uint8Array(A), P.forEach(function(h) {
        x.set(h, _), _ += h.length;
      })) : x = P[0] ? new Uint8Array(P[0]) : new Uint8Array(), x;
    }
  }, t.flush = function() {
    let l, u, g = 0, x = 0;
    const w = [];
    do {
      if (e.next_out_index = 0, e.avail_out = r, l = e.deflate(Ee), l != Gr && l != Le)
        throw new Error("deflating: " + e.msg);
      r - e.avail_out > 0 && w.push(o.slice(0, e.next_out_index)), x += e.next_out_index;
    } while (e.avail_in > 0 || e.avail_out === 0);
    return e.deflateEnd(), u = new Uint8Array(x), w.forEach(function(_) {
      u.set(_, g), g += _.length;
    }), u;
  };
}
function bs(n) {
  return n + 5 * (Math.floor(n / 16383) + 1);
}
const ys = 15, Q = 0, qe = 1, vs = 2, ke = -2, se = -3, Vn = -4, je = -5, Ae = [
  0,
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255,
  511,
  1023,
  2047,
  4095,
  8191,
  16383,
  32767,
  65535
], Kr = 1440, Es = 0, ks = 4, Ss = 9, As = 5, Ts = [
  96,
  7,
  256,
  0,
  8,
  80,
  0,
  8,
  16,
  84,
  8,
  115,
  82,
  7,
  31,
  0,
  8,
  112,
  0,
  8,
  48,
  0,
  9,
  192,
  80,
  7,
  10,
  0,
  8,
  96,
  0,
  8,
  32,
  0,
  9,
  160,
  0,
  8,
  0,
  0,
  8,
  128,
  0,
  8,
  64,
  0,
  9,
  224,
  80,
  7,
  6,
  0,
  8,
  88,
  0,
  8,
  24,
  0,
  9,
  144,
  83,
  7,
  59,
  0,
  8,
  120,
  0,
  8,
  56,
  0,
  9,
  208,
  81,
  7,
  17,
  0,
  8,
  104,
  0,
  8,
  40,
  0,
  9,
  176,
  0,
  8,
  8,
  0,
  8,
  136,
  0,
  8,
  72,
  0,
  9,
  240,
  80,
  7,
  4,
  0,
  8,
  84,
  0,
  8,
  20,
  85,
  8,
  227,
  83,
  7,
  43,
  0,
  8,
  116,
  0,
  8,
  52,
  0,
  9,
  200,
  81,
  7,
  13,
  0,
  8,
  100,
  0,
  8,
  36,
  0,
  9,
  168,
  0,
  8,
  4,
  0,
  8,
  132,
  0,
  8,
  68,
  0,
  9,
  232,
  80,
  7,
  8,
  0,
  8,
  92,
  0,
  8,
  28,
  0,
  9,
  152,
  84,
  7,
  83,
  0,
  8,
  124,
  0,
  8,
  60,
  0,
  9,
  216,
  82,
  7,
  23,
  0,
  8,
  108,
  0,
  8,
  44,
  0,
  9,
  184,
  0,
  8,
  12,
  0,
  8,
  140,
  0,
  8,
  76,
  0,
  9,
  248,
  80,
  7,
  3,
  0,
  8,
  82,
  0,
  8,
  18,
  85,
  8,
  163,
  83,
  7,
  35,
  0,
  8,
  114,
  0,
  8,
  50,
  0,
  9,
  196,
  81,
  7,
  11,
  0,
  8,
  98,
  0,
  8,
  34,
  0,
  9,
  164,
  0,
  8,
  2,
  0,
  8,
  130,
  0,
  8,
  66,
  0,
  9,
  228,
  80,
  7,
  7,
  0,
  8,
  90,
  0,
  8,
  26,
  0,
  9,
  148,
  84,
  7,
  67,
  0,
  8,
  122,
  0,
  8,
  58,
  0,
  9,
  212,
  82,
  7,
  19,
  0,
  8,
  106,
  0,
  8,
  42,
  0,
  9,
  180,
  0,
  8,
  10,
  0,
  8,
  138,
  0,
  8,
  74,
  0,
  9,
  244,
  80,
  7,
  5,
  0,
  8,
  86,
  0,
  8,
  22,
  192,
  8,
  0,
  83,
  7,
  51,
  0,
  8,
  118,
  0,
  8,
  54,
  0,
  9,
  204,
  81,
  7,
  15,
  0,
  8,
  102,
  0,
  8,
  38,
  0,
  9,
  172,
  0,
  8,
  6,
  0,
  8,
  134,
  0,
  8,
  70,
  0,
  9,
  236,
  80,
  7,
  9,
  0,
  8,
  94,
  0,
  8,
  30,
  0,
  9,
  156,
  84,
  7,
  99,
  0,
  8,
  126,
  0,
  8,
  62,
  0,
  9,
  220,
  82,
  7,
  27,
  0,
  8,
  110,
  0,
  8,
  46,
  0,
  9,
  188,
  0,
  8,
  14,
  0,
  8,
  142,
  0,
  8,
  78,
  0,
  9,
  252,
  96,
  7,
  256,
  0,
  8,
  81,
  0,
  8,
  17,
  85,
  8,
  131,
  82,
  7,
  31,
  0,
  8,
  113,
  0,
  8,
  49,
  0,
  9,
  194,
  80,
  7,
  10,
  0,
  8,
  97,
  0,
  8,
  33,
  0,
  9,
  162,
  0,
  8,
  1,
  0,
  8,
  129,
  0,
  8,
  65,
  0,
  9,
  226,
  80,
  7,
  6,
  0,
  8,
  89,
  0,
  8,
  25,
  0,
  9,
  146,
  83,
  7,
  59,
  0,
  8,
  121,
  0,
  8,
  57,
  0,
  9,
  210,
  81,
  7,
  17,
  0,
  8,
  105,
  0,
  8,
  41,
  0,
  9,
  178,
  0,
  8,
  9,
  0,
  8,
  137,
  0,
  8,
  73,
  0,
  9,
  242,
  80,
  7,
  4,
  0,
  8,
  85,
  0,
  8,
  21,
  80,
  8,
  258,
  83,
  7,
  43,
  0,
  8,
  117,
  0,
  8,
  53,
  0,
  9,
  202,
  81,
  7,
  13,
  0,
  8,
  101,
  0,
  8,
  37,
  0,
  9,
  170,
  0,
  8,
  5,
  0,
  8,
  133,
  0,
  8,
  69,
  0,
  9,
  234,
  80,
  7,
  8,
  0,
  8,
  93,
  0,
  8,
  29,
  0,
  9,
  154,
  84,
  7,
  83,
  0,
  8,
  125,
  0,
  8,
  61,
  0,
  9,
  218,
  82,
  7,
  23,
  0,
  8,
  109,
  0,
  8,
  45,
  0,
  9,
  186,
  0,
  8,
  13,
  0,
  8,
  141,
  0,
  8,
  77,
  0,
  9,
  250,
  80,
  7,
  3,
  0,
  8,
  83,
  0,
  8,
  19,
  85,
  8,
  195,
  83,
  7,
  35,
  0,
  8,
  115,
  0,
  8,
  51,
  0,
  9,
  198,
  81,
  7,
  11,
  0,
  8,
  99,
  0,
  8,
  35,
  0,
  9,
  166,
  0,
  8,
  3,
  0,
  8,
  131,
  0,
  8,
  67,
  0,
  9,
  230,
  80,
  7,
  7,
  0,
  8,
  91,
  0,
  8,
  27,
  0,
  9,
  150,
  84,
  7,
  67,
  0,
  8,
  123,
  0,
  8,
  59,
  0,
  9,
  214,
  82,
  7,
  19,
  0,
  8,
  107,
  0,
  8,
  43,
  0,
  9,
  182,
  0,
  8,
  11,
  0,
  8,
  139,
  0,
  8,
  75,
  0,
  9,
  246,
  80,
  7,
  5,
  0,
  8,
  87,
  0,
  8,
  23,
  192,
  8,
  0,
  83,
  7,
  51,
  0,
  8,
  119,
  0,
  8,
  55,
  0,
  9,
  206,
  81,
  7,
  15,
  0,
  8,
  103,
  0,
  8,
  39,
  0,
  9,
  174,
  0,
  8,
  7,
  0,
  8,
  135,
  0,
  8,
  71,
  0,
  9,
  238,
  80,
  7,
  9,
  0,
  8,
  95,
  0,
  8,
  31,
  0,
  9,
  158,
  84,
  7,
  99,
  0,
  8,
  127,
  0,
  8,
  63,
  0,
  9,
  222,
  82,
  7,
  27,
  0,
  8,
  111,
  0,
  8,
  47,
  0,
  9,
  190,
  0,
  8,
  15,
  0,
  8,
  143,
  0,
  8,
  79,
  0,
  9,
  254,
  96,
  7,
  256,
  0,
  8,
  80,
  0,
  8,
  16,
  84,
  8,
  115,
  82,
  7,
  31,
  0,
  8,
  112,
  0,
  8,
  48,
  0,
  9,
  193,
  80,
  7,
  10,
  0,
  8,
  96,
  0,
  8,
  32,
  0,
  9,
  161,
  0,
  8,
  0,
  0,
  8,
  128,
  0,
  8,
  64,
  0,
  9,
  225,
  80,
  7,
  6,
  0,
  8,
  88,
  0,
  8,
  24,
  0,
  9,
  145,
  83,
  7,
  59,
  0,
  8,
  120,
  0,
  8,
  56,
  0,
  9,
  209,
  81,
  7,
  17,
  0,
  8,
  104,
  0,
  8,
  40,
  0,
  9,
  177,
  0,
  8,
  8,
  0,
  8,
  136,
  0,
  8,
  72,
  0,
  9,
  241,
  80,
  7,
  4,
  0,
  8,
  84,
  0,
  8,
  20,
  85,
  8,
  227,
  83,
  7,
  43,
  0,
  8,
  116,
  0,
  8,
  52,
  0,
  9,
  201,
  81,
  7,
  13,
  0,
  8,
  100,
  0,
  8,
  36,
  0,
  9,
  169,
  0,
  8,
  4,
  0,
  8,
  132,
  0,
  8,
  68,
  0,
  9,
  233,
  80,
  7,
  8,
  0,
  8,
  92,
  0,
  8,
  28,
  0,
  9,
  153,
  84,
  7,
  83,
  0,
  8,
  124,
  0,
  8,
  60,
  0,
  9,
  217,
  82,
  7,
  23,
  0,
  8,
  108,
  0,
  8,
  44,
  0,
  9,
  185,
  0,
  8,
  12,
  0,
  8,
  140,
  0,
  8,
  76,
  0,
  9,
  249,
  80,
  7,
  3,
  0,
  8,
  82,
  0,
  8,
  18,
  85,
  8,
  163,
  83,
  7,
  35,
  0,
  8,
  114,
  0,
  8,
  50,
  0,
  9,
  197,
  81,
  7,
  11,
  0,
  8,
  98,
  0,
  8,
  34,
  0,
  9,
  165,
  0,
  8,
  2,
  0,
  8,
  130,
  0,
  8,
  66,
  0,
  9,
  229,
  80,
  7,
  7,
  0,
  8,
  90,
  0,
  8,
  26,
  0,
  9,
  149,
  84,
  7,
  67,
  0,
  8,
  122,
  0,
  8,
  58,
  0,
  9,
  213,
  82,
  7,
  19,
  0,
  8,
  106,
  0,
  8,
  42,
  0,
  9,
  181,
  0,
  8,
  10,
  0,
  8,
  138,
  0,
  8,
  74,
  0,
  9,
  245,
  80,
  7,
  5,
  0,
  8,
  86,
  0,
  8,
  22,
  192,
  8,
  0,
  83,
  7,
  51,
  0,
  8,
  118,
  0,
  8,
  54,
  0,
  9,
  205,
  81,
  7,
  15,
  0,
  8,
  102,
  0,
  8,
  38,
  0,
  9,
  173,
  0,
  8,
  6,
  0,
  8,
  134,
  0,
  8,
  70,
  0,
  9,
  237,
  80,
  7,
  9,
  0,
  8,
  94,
  0,
  8,
  30,
  0,
  9,
  157,
  84,
  7,
  99,
  0,
  8,
  126,
  0,
  8,
  62,
  0,
  9,
  221,
  82,
  7,
  27,
  0,
  8,
  110,
  0,
  8,
  46,
  0,
  9,
  189,
  0,
  8,
  14,
  0,
  8,
  142,
  0,
  8,
  78,
  0,
  9,
  253,
  96,
  7,
  256,
  0,
  8,
  81,
  0,
  8,
  17,
  85,
  8,
  131,
  82,
  7,
  31,
  0,
  8,
  113,
  0,
  8,
  49,
  0,
  9,
  195,
  80,
  7,
  10,
  0,
  8,
  97,
  0,
  8,
  33,
  0,
  9,
  163,
  0,
  8,
  1,
  0,
  8,
  129,
  0,
  8,
  65,
  0,
  9,
  227,
  80,
  7,
  6,
  0,
  8,
  89,
  0,
  8,
  25,
  0,
  9,
  147,
  83,
  7,
  59,
  0,
  8,
  121,
  0,
  8,
  57,
  0,
  9,
  211,
  81,
  7,
  17,
  0,
  8,
  105,
  0,
  8,
  41,
  0,
  9,
  179,
  0,
  8,
  9,
  0,
  8,
  137,
  0,
  8,
  73,
  0,
  9,
  243,
  80,
  7,
  4,
  0,
  8,
  85,
  0,
  8,
  21,
  80,
  8,
  258,
  83,
  7,
  43,
  0,
  8,
  117,
  0,
  8,
  53,
  0,
  9,
  203,
  81,
  7,
  13,
  0,
  8,
  101,
  0,
  8,
  37,
  0,
  9,
  171,
  0,
  8,
  5,
  0,
  8,
  133,
  0,
  8,
  69,
  0,
  9,
  235,
  80,
  7,
  8,
  0,
  8,
  93,
  0,
  8,
  29,
  0,
  9,
  155,
  84,
  7,
  83,
  0,
  8,
  125,
  0,
  8,
  61,
  0,
  9,
  219,
  82,
  7,
  23,
  0,
  8,
  109,
  0,
  8,
  45,
  0,
  9,
  187,
  0,
  8,
  13,
  0,
  8,
  141,
  0,
  8,
  77,
  0,
  9,
  251,
  80,
  7,
  3,
  0,
  8,
  83,
  0,
  8,
  19,
  85,
  8,
  195,
  83,
  7,
  35,
  0,
  8,
  115,
  0,
  8,
  51,
  0,
  9,
  199,
  81,
  7,
  11,
  0,
  8,
  99,
  0,
  8,
  35,
  0,
  9,
  167,
  0,
  8,
  3,
  0,
  8,
  131,
  0,
  8,
  67,
  0,
  9,
  231,
  80,
  7,
  7,
  0,
  8,
  91,
  0,
  8,
  27,
  0,
  9,
  151,
  84,
  7,
  67,
  0,
  8,
  123,
  0,
  8,
  59,
  0,
  9,
  215,
  82,
  7,
  19,
  0,
  8,
  107,
  0,
  8,
  43,
  0,
  9,
  183,
  0,
  8,
  11,
  0,
  8,
  139,
  0,
  8,
  75,
  0,
  9,
  247,
  80,
  7,
  5,
  0,
  8,
  87,
  0,
  8,
  23,
  192,
  8,
  0,
  83,
  7,
  51,
  0,
  8,
  119,
  0,
  8,
  55,
  0,
  9,
  207,
  81,
  7,
  15,
  0,
  8,
  103,
  0,
  8,
  39,
  0,
  9,
  175,
  0,
  8,
  7,
  0,
  8,
  135,
  0,
  8,
  71,
  0,
  9,
  239,
  80,
  7,
  9,
  0,
  8,
  95,
  0,
  8,
  31,
  0,
  9,
  159,
  84,
  7,
  99,
  0,
  8,
  127,
  0,
  8,
  63,
  0,
  9,
  223,
  82,
  7,
  27,
  0,
  8,
  111,
  0,
  8,
  47,
  0,
  9,
  191,
  0,
  8,
  15,
  0,
  8,
  143,
  0,
  8,
  79,
  0,
  9,
  255
], Fs = [
  80,
  5,
  1,
  87,
  5,
  257,
  83,
  5,
  17,
  91,
  5,
  4097,
  81,
  5,
  5,
  89,
  5,
  1025,
  85,
  5,
  65,
  93,
  5,
  16385,
  80,
  5,
  3,
  88,
  5,
  513,
  84,
  5,
  33,
  92,
  5,
  8193,
  82,
  5,
  9,
  90,
  5,
  2049,
  86,
  5,
  129,
  192,
  5,
  24577,
  80,
  5,
  2,
  87,
  5,
  385,
  83,
  5,
  25,
  91,
  5,
  6145,
  81,
  5,
  7,
  89,
  5,
  1537,
  85,
  5,
  97,
  93,
  5,
  24577,
  80,
  5,
  4,
  88,
  5,
  769,
  84,
  5,
  49,
  92,
  5,
  12289,
  82,
  5,
  13,
  90,
  5,
  3073,
  86,
  5,
  193,
  192,
  5,
  24577
], Rs = [
  // Copy lengths for literal codes 257..285
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
], Cs = [
  // Extra bits for literal codes 257..285
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  112,
  112
  // 112==invalid
], Is = [
  // Copy offsets for distance codes 0..29
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577
], Ds = [
  // Extra bits for distance codes
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13
], Ye = 15;
function yn() {
  const n = this;
  let t, e, r, a, o, c;
  function l(g, x, w, _, A, P, h, p, m, E, R) {
    let D, S, T, F, b, I, v, k, W, O, Z, H, j, K, X;
    O = 0, b = w;
    do
      r[g[x + O]]++, O++, b--;
    while (b !== 0);
    if (r[0] == w)
      return h[0] = -1, p[0] = 0, Q;
    for (k = p[0], I = 1; I <= Ye && r[I] === 0; I++)
      ;
    for (v = I, k < I && (k = I), b = Ye; b !== 0 && r[b] === 0; b--)
      ;
    for (T = b, k > b && (k = b), p[0] = k, K = 1 << I; I < b; I++, K <<= 1)
      if ((K -= r[I]) < 0)
        return se;
    if ((K -= r[b]) < 0)
      return se;
    for (r[b] += K, c[1] = I = 0, O = 1, j = 2; --b !== 0; )
      c[j] = I += r[O], j++, O++;
    b = 0, O = 0;
    do
      (I = g[x + O]) !== 0 && (R[c[I]++] = b), O++;
    while (++b < w);
    for (w = c[T], c[0] = b = 0, O = 0, F = -1, H = -k, o[0] = 0, Z = 0, X = 0; v <= T; v++)
      for (D = r[v]; D-- !== 0; ) {
        for (; v > H + k; ) {
          if (F++, H += k, X = T - H, X = X > k ? k : X, (S = 1 << (I = v - H)) > D + 1 && (S -= D + 1, j = v, I < X))
            for (; ++I < X && !((S <<= 1) <= r[++j]); )
              S -= r[j];
          if (X = 1 << I, E[0] + X > Kr)
            return se;
          o[F] = Z = /* hp+ */
          E[0], E[0] += X, F !== 0 ? (c[F] = b, a[0] = /* (byte) */
          I, a[1] = /* (byte) */
          k, I = b >>> H - k, a[2] = /* (int) */
          Z - o[F - 1] - I, m.set(a, (o[F - 1] + I) * 3)) : h[0] = Z;
        }
        for (a[1] = /* (byte) */
        v - H, O >= w ? a[0] = 192 : R[O] < _ ? (a[0] = /* (byte) */
        R[O] < 256 ? 0 : 96, a[2] = R[O++]) : (a[0] = /* (byte) */
        P[R[O] - _] + 16 + 64, a[2] = A[R[O++] - _]), S = 1 << v - H, I = b >>> H; I < X; I += S)
          m.set(a, (Z + I) * 3);
        for (I = 1 << v - 1; b & I; I >>>= 1)
          b ^= I;
        for (b ^= I, W = (1 << H) - 1; (b & W) != c[F]; )
          F--, H -= k, W = (1 << H) - 1;
      }
    return K !== 0 && T != 1 ? je : Q;
  }
  function u(g) {
    let x;
    for (t || (t = [], e = [], r = new Int32Array(Ye + 1), a = [], o = new Int32Array(Ye), c = new Int32Array(Ye + 1)), e.length < g && (e = []), x = 0; x < g; x++)
      e[x] = 0;
    for (x = 0; x < Ye + 1; x++)
      r[x] = 0;
    for (x = 0; x < 3; x++)
      a[x] = 0;
    o.set(r.subarray(0, Ye), 0), c.set(r.subarray(0, Ye + 1), 0);
  }
  n.inflate_trees_bits = function(g, x, w, _, A) {
    let P;
    return u(19), t[0] = 0, P = l(g, 0, 19, 19, null, null, w, x, _, t, e), P == se ? A.msg = "oversubscribed dynamic bit lengths tree" : (P == je || x[0] === 0) && (A.msg = "incomplete dynamic bit lengths tree", P = se), P;
  }, n.inflate_trees_dynamic = function(g, x, w, _, A, P, h, p, m) {
    let E;
    return u(288), t[0] = 0, E = l(w, 0, g, 257, Rs, Cs, P, _, p, t, e), E != Q || _[0] === 0 ? (E == se ? m.msg = "oversubscribed literal/length tree" : E != Vn && (m.msg = "incomplete literal/length tree", E = se), E) : (u(288), E = l(w, g, x, 0, Is, Ds, h, A, p, t, e), E != Q || A[0] === 0 && g > 257 ? (E == se ? m.msg = "oversubscribed distance tree" : E == je ? (m.msg = "incomplete distance tree", E = se) : E != Vn && (m.msg = "empty distance tree with lengths", E = se), E) : Q);
  };
}
yn.inflate_trees_fixed = function(n, t, e, r) {
  return n[0] = Ss, t[0] = As, e[0] = Ts, r[0] = Fs, Q;
};
const Ot = 0, Zn = 1, Kn = 2, Xn = 3, $n = 4, Jn = 5, zn = 6, cn = 7, Qn = 8, Pt = 9;
function Ls() {
  const n = this;
  let t, e = 0, r, a = 0, o = 0, c = 0, l = 0, u = 0, g = 0, x = 0, w, _ = 0, A, P = 0;
  function h(p, m, E, R, D, S, T, F) {
    let b, I, v, k, W, O, Z, H, j, K, X, oe, G, z, Y, ee;
    Z = F.next_in_index, H = F.avail_in, W = T.bitb, O = T.bitk, j = T.write, K = j < T.read ? T.read - j - 1 : T.end - j, X = Ae[p], oe = Ae[m];
    do {
      for (; O < 20; )
        H--, W |= (F.read_byte(Z++) & 255) << O, O += 8;
      if (b = W & X, I = E, v = R, ee = (v + b) * 3, (k = I[ee]) === 0) {
        W >>= I[ee + 1], O -= I[ee + 1], T.win[j++] = /* (byte) */
        I[ee + 2], K--;
        continue;
      }
      do {
        if (W >>= I[ee + 1], O -= I[ee + 1], k & 16) {
          for (k &= 15, G = I[ee + 2] + /* (int) */
          (W & Ae[k]), W >>= k, O -= k; O < 15; )
            H--, W |= (F.read_byte(Z++) & 255) << O, O += 8;
          b = W & oe, I = D, v = S, ee = (v + b) * 3, k = I[ee];
          do
            if (W >>= I[ee + 1], O -= I[ee + 1], k & 16) {
              for (k &= 15; O < k; )
                H--, W |= (F.read_byte(Z++) & 255) << O, O += 8;
              if (z = I[ee + 2] + (W & Ae[k]), W >>= k, O -= k, K -= G, j >= z)
                Y = j - z, j - Y > 0 && 2 > j - Y ? (T.win[j++] = T.win[Y++], T.win[j++] = T.win[Y++], G -= 2) : (T.win.set(T.win.subarray(Y, Y + 2), j), j += 2, Y += 2, G -= 2);
              else {
                Y = j - z;
                do
                  Y += T.end;
                while (Y < 0);
                if (k = T.end - Y, G > k) {
                  if (G -= k, j - Y > 0 && k > j - Y)
                    do
                      T.win[j++] = T.win[Y++];
                    while (--k !== 0);
                  else
                    T.win.set(T.win.subarray(Y, Y + k), j), j += k, Y += k, k = 0;
                  Y = 0;
                }
              }
              if (j - Y > 0 && G > j - Y)
                do
                  T.win[j++] = T.win[Y++];
                while (--G !== 0);
              else
                T.win.set(T.win.subarray(Y, Y + G), j), j += G, Y += G, G = 0;
              break;
            } else if (!(k & 64))
              b += I[ee + 2], b += W & Ae[k], ee = (v + b) * 3, k = I[ee];
            else
              return F.msg = "invalid distance code", G = F.avail_in - H, G = O >> 3 < G ? O >> 3 : G, H += G, Z -= G, O -= G << 3, T.bitb = W, T.bitk = O, F.avail_in = H, F.total_in += Z - F.next_in_index, F.next_in_index = Z, T.write = j, se;
          while (!0);
          break;
        }
        if (k & 64)
          return k & 32 ? (G = F.avail_in - H, G = O >> 3 < G ? O >> 3 : G, H += G, Z -= G, O -= G << 3, T.bitb = W, T.bitk = O, F.avail_in = H, F.total_in += Z - F.next_in_index, F.next_in_index = Z, T.write = j, qe) : (F.msg = "invalid literal/length code", G = F.avail_in - H, G = O >> 3 < G ? O >> 3 : G, H += G, Z -= G, O -= G << 3, T.bitb = W, T.bitk = O, F.avail_in = H, F.total_in += Z - F.next_in_index, F.next_in_index = Z, T.write = j, se);
        if (b += I[ee + 2], b += W & Ae[k], ee = (v + b) * 3, (k = I[ee]) === 0) {
          W >>= I[ee + 1], O -= I[ee + 1], T.win[j++] = /* (byte) */
          I[ee + 2], K--;
          break;
        }
      } while (!0);
    } while (K >= 258 && H >= 10);
    return G = F.avail_in - H, G = O >> 3 < G ? O >> 3 : G, H += G, Z -= G, O -= G << 3, T.bitb = W, T.bitk = O, F.avail_in = H, F.total_in += Z - F.next_in_index, F.next_in_index = Z, T.write = j, Q;
  }
  n.init = function(p, m, E, R, D, S) {
    t = Ot, g = /* (byte) */
    p, x = /* (byte) */
    m, w = E, _ = R, A = D, P = S, r = null;
  }, n.proc = function(p, m, E) {
    let R, D, S, T = 0, F = 0, b = 0, I, v, k, W;
    for (b = m.next_in_index, I = m.avail_in, T = p.bitb, F = p.bitk, v = p.write, k = v < p.read ? p.read - v - 1 : p.end - v; ; )
      switch (t) {
        case Ot:
          if (k >= 258 && I >= 10 && (p.bitb = T, p.bitk = F, m.avail_in = I, m.total_in += b - m.next_in_index, m.next_in_index = b, p.write = v, E = h(g, x, w, _, A, P, p, m), b = m.next_in_index, I = m.avail_in, T = p.bitb, F = p.bitk, v = p.write, k = v < p.read ? p.read - v - 1 : p.end - v, E != Q)) {
            t = E == qe ? cn : Pt;
            break;
          }
          o = g, r = w, a = _, t = Zn;
        case Zn:
          for (R = o; F < R; ) {
            if (I !== 0)
              E = Q;
            else
              return p.bitb = T, p.bitk = F, m.avail_in = I, m.total_in += b - m.next_in_index, m.next_in_index = b, p.write = v, p.inflate_flush(m, E);
            I--, T |= (m.read_byte(b++) & 255) << F, F += 8;
          }
          if (D = (a + (T & Ae[R])) * 3, T >>>= r[D + 1], F -= r[D + 1], S = r[D], S === 0) {
            c = r[D + 2], t = zn;
            break;
          }
          if (S & 16) {
            l = S & 15, e = r[D + 2], t = Kn;
            break;
          }
          if (!(S & 64)) {
            o = S, a = D / 3 + r[D + 2];
            break;
          }
          if (S & 32) {
            t = cn;
            break;
          }
          return t = Pt, m.msg = "invalid literal/length code", E = se, p.bitb = T, p.bitk = F, m.avail_in = I, m.total_in += b - m.next_in_index, m.next_in_index = b, p.write = v, p.inflate_flush(m, E);
        case Kn:
          for (R = l; F < R; ) {
            if (I !== 0)
              E = Q;
            else
              return p.bitb = T, p.bitk = F, m.avail_in = I, m.total_in += b - m.next_in_index, m.next_in_index = b, p.write = v, p.inflate_flush(m, E);
            I--, T |= (m.read_byte(b++) & 255) << F, F += 8;
          }
          e += T & Ae[R], T >>= R, F -= R, o = x, r = A, a = P, t = Xn;
        case Xn:
          for (R = o; F < R; ) {
            if (I !== 0)
              E = Q;
            else
              return p.bitb = T, p.bitk = F, m.avail_in = I, m.total_in += b - m.next_in_index, m.next_in_index = b, p.write = v, p.inflate_flush(m, E);
            I--, T |= (m.read_byte(b++) & 255) << F, F += 8;
          }
          if (D = (a + (T & Ae[R])) * 3, T >>= r[D + 1], F -= r[D + 1], S = r[D], S & 16) {
            l = S & 15, u = r[D + 2], t = $n;
            break;
          }
          if (!(S & 64)) {
            o = S, a = D / 3 + r[D + 2];
            break;
          }
          return t = Pt, m.msg = "invalid distance code", E = se, p.bitb = T, p.bitk = F, m.avail_in = I, m.total_in += b - m.next_in_index, m.next_in_index = b, p.write = v, p.inflate_flush(m, E);
        case $n:
          for (R = l; F < R; ) {
            if (I !== 0)
              E = Q;
            else
              return p.bitb = T, p.bitk = F, m.avail_in = I, m.total_in += b - m.next_in_index, m.next_in_index = b, p.write = v, p.inflate_flush(m, E);
            I--, T |= (m.read_byte(b++) & 255) << F, F += 8;
          }
          u += T & Ae[R], T >>= R, F -= R, t = Jn;
        case Jn:
          for (W = v - u; W < 0; )
            W += p.end;
          for (; e !== 0; ) {
            if (k === 0 && (v == p.end && p.read !== 0 && (v = 0, k = v < p.read ? p.read - v - 1 : p.end - v), k === 0 && (p.write = v, E = p.inflate_flush(m, E), v = p.write, k = v < p.read ? p.read - v - 1 : p.end - v, v == p.end && p.read !== 0 && (v = 0, k = v < p.read ? p.read - v - 1 : p.end - v), k === 0)))
              return p.bitb = T, p.bitk = F, m.avail_in = I, m.total_in += b - m.next_in_index, m.next_in_index = b, p.write = v, p.inflate_flush(m, E);
            p.win[v++] = p.win[W++], k--, W == p.end && (W = 0), e--;
          }
          t = Ot;
          break;
        case zn:
          if (k === 0 && (v == p.end && p.read !== 0 && (v = 0, k = v < p.read ? p.read - v - 1 : p.end - v), k === 0 && (p.write = v, E = p.inflate_flush(m, E), v = p.write, k = v < p.read ? p.read - v - 1 : p.end - v, v == p.end && p.read !== 0 && (v = 0, k = v < p.read ? p.read - v - 1 : p.end - v), k === 0)))
            return p.bitb = T, p.bitk = F, m.avail_in = I, m.total_in += b - m.next_in_index, m.next_in_index = b, p.write = v, p.inflate_flush(m, E);
          E = Q, p.win[v++] = /* (byte) */
          c, k--, t = Ot;
          break;
        case cn:
          if (F > 7 && (F -= 8, I++, b--), p.write = v, E = p.inflate_flush(m, E), v = p.write, k = v < p.read ? p.read - v - 1 : p.end - v, p.read != p.write)
            return p.bitb = T, p.bitk = F, m.avail_in = I, m.total_in += b - m.next_in_index, m.next_in_index = b, p.write = v, p.inflate_flush(m, E);
          t = Qn;
        case Qn:
          return E = qe, p.bitb = T, p.bitk = F, m.avail_in = I, m.total_in += b - m.next_in_index, m.next_in_index = b, p.write = v, p.inflate_flush(m, E);
        case Pt:
          return E = se, p.bitb = T, p.bitk = F, m.avail_in = I, m.total_in += b - m.next_in_index, m.next_in_index = b, p.write = v, p.inflate_flush(m, E);
        default:
          return E = ke, p.bitb = T, p.bitk = F, m.avail_in = I, m.total_in += b - m.next_in_index, m.next_in_index = b, p.write = v, p.inflate_flush(m, E);
      }
  }, n.free = function() {
  };
}
const er = [
  // Order of the bit length code lengths
  16,
  17,
  18,
  0,
  8,
  7,
  9,
  6,
  10,
  5,
  11,
  4,
  12,
  3,
  13,
  2,
  14,
  1,
  15
], ot = 0, ln = 1, tr = 2, nr = 3, rr = 4, ir = 5, Bt = 6, Nt = 7, sr = 8, Qe = 9;
function Us(n, t) {
  const e = this;
  let r = ot, a = 0, o = 0, c = 0, l;
  const u = [0], g = [0], x = new Ls();
  let w = 0, _ = new Int32Array(Kr * 3);
  const A = 0, P = new yn();
  e.bitk = 0, e.bitb = 0, e.win = new Uint8Array(t), e.end = t, e.read = 0, e.write = 0, e.reset = function(h, p) {
    p && (p[0] = A), r == Bt && x.free(h), r = ot, e.bitk = 0, e.bitb = 0, e.read = e.write = 0;
  }, e.reset(n, null), e.inflate_flush = function(h, p) {
    let m, E, R;
    return E = h.next_out_index, R = e.read, m = /* (int) */
    (R <= e.write ? e.write : e.end) - R, m > h.avail_out && (m = h.avail_out), m !== 0 && p == je && (p = Q), h.avail_out -= m, h.total_out += m, h.next_out.set(e.win.subarray(R, R + m), E), E += m, R += m, R == e.end && (R = 0, e.write == e.end && (e.write = 0), m = e.write - R, m > h.avail_out && (m = h.avail_out), m !== 0 && p == je && (p = Q), h.avail_out -= m, h.total_out += m, h.next_out.set(e.win.subarray(R, R + m), E), E += m, R += m), h.next_out_index = E, e.read = R, p;
  }, e.proc = function(h, p) {
    let m, E, R, D, S, T, F, b;
    for (D = h.next_in_index, S = h.avail_in, E = e.bitb, R = e.bitk, T = e.write, F = /* (int) */
    T < e.read ? e.read - T - 1 : e.end - T; ; ) {
      let I, v, k, W, O, Z, H, j;
      switch (r) {
        case ot:
          for (; R < 3; ) {
            if (S !== 0)
              p = Q;
            else
              return e.bitb = E, e.bitk = R, h.avail_in = S, h.total_in += D - h.next_in_index, h.next_in_index = D, e.write = T, e.inflate_flush(h, p);
            S--, E |= (h.read_byte(D++) & 255) << R, R += 8;
          }
          switch (m = /* (int) */
          E & 7, w = m & 1, m >>> 1) {
            case 0:
              E >>>= 3, R -= 3, m = R & 7, E >>>= m, R -= m, r = ln;
              break;
            case 1:
              I = [], v = [], k = [[]], W = [[]], yn.inflate_trees_fixed(I, v, k, W), x.init(I[0], v[0], k[0], 0, W[0], 0), E >>>= 3, R -= 3, r = Bt;
              break;
            case 2:
              E >>>= 3, R -= 3, r = nr;
              break;
            case 3:
              return E >>>= 3, R -= 3, r = Qe, h.msg = "invalid block type", p = se, e.bitb = E, e.bitk = R, h.avail_in = S, h.total_in += D - h.next_in_index, h.next_in_index = D, e.write = T, e.inflate_flush(h, p);
          }
          break;
        case ln:
          for (; R < 32; ) {
            if (S !== 0)
              p = Q;
            else
              return e.bitb = E, e.bitk = R, h.avail_in = S, h.total_in += D - h.next_in_index, h.next_in_index = D, e.write = T, e.inflate_flush(h, p);
            S--, E |= (h.read_byte(D++) & 255) << R, R += 8;
          }
          if ((~E >>> 16 & 65535) != (E & 65535))
            return r = Qe, h.msg = "invalid stored block lengths", p = se, e.bitb = E, e.bitk = R, h.avail_in = S, h.total_in += D - h.next_in_index, h.next_in_index = D, e.write = T, e.inflate_flush(h, p);
          a = E & 65535, E = R = 0, r = a !== 0 ? tr : w !== 0 ? Nt : ot;
          break;
        case tr:
          if (S === 0 || F === 0 && (T == e.end && e.read !== 0 && (T = 0, F = /* (int) */
          T < e.read ? e.read - T - 1 : e.end - T), F === 0 && (e.write = T, p = e.inflate_flush(h, p), T = e.write, F = /* (int) */
          T < e.read ? e.read - T - 1 : e.end - T, T == e.end && e.read !== 0 && (T = 0, F = /* (int) */
          T < e.read ? e.read - T - 1 : e.end - T), F === 0)))
            return e.bitb = E, e.bitk = R, h.avail_in = S, h.total_in += D - h.next_in_index, h.next_in_index = D, e.write = T, e.inflate_flush(h, p);
          if (p = Q, m = a, m > S && (m = S), m > F && (m = F), e.win.set(h.read_buf(D, m), T), D += m, S -= m, T += m, F -= m, (a -= m) !== 0)
            break;
          r = w !== 0 ? Nt : ot;
          break;
        case nr:
          for (; R < 14; ) {
            if (S !== 0)
              p = Q;
            else
              return e.bitb = E, e.bitk = R, h.avail_in = S, h.total_in += D - h.next_in_index, h.next_in_index = D, e.write = T, e.inflate_flush(h, p);
            S--, E |= (h.read_byte(D++) & 255) << R, R += 8;
          }
          if (o = m = E & 16383, (m & 31) > 29 || (m >> 5 & 31) > 29)
            return r = Qe, h.msg = "too many length or distance symbols", p = se, e.bitb = E, e.bitk = R, h.avail_in = S, h.total_in += D - h.next_in_index, h.next_in_index = D, e.write = T, e.inflate_flush(h, p);
          if (m = 258 + (m & 31) + (m >> 5 & 31), !l || l.length < m)
            l = [];
          else
            for (b = 0; b < m; b++)
              l[b] = 0;
          E >>>= 14, R -= 14, c = 0, r = rr;
        case rr:
          for (; c < 4 + (o >>> 10); ) {
            for (; R < 3; ) {
              if (S !== 0)
                p = Q;
              else
                return e.bitb = E, e.bitk = R, h.avail_in = S, h.total_in += D - h.next_in_index, h.next_in_index = D, e.write = T, e.inflate_flush(h, p);
              S--, E |= (h.read_byte(D++) & 255) << R, R += 8;
            }
            l[er[c++]] = E & 7, E >>>= 3, R -= 3;
          }
          for (; c < 19; )
            l[er[c++]] = 0;
          if (u[0] = 7, m = P.inflate_trees_bits(l, u, g, _, h), m != Q)
            return p = m, p == se && (l = null, r = Qe), e.bitb = E, e.bitk = R, h.avail_in = S, h.total_in += D - h.next_in_index, h.next_in_index = D, e.write = T, e.inflate_flush(h, p);
          c = 0, r = ir;
        case ir:
          for (; m = o, !(c >= 258 + (m & 31) + (m >> 5 & 31)); ) {
            let K, X;
            for (m = u[0]; R < m; ) {
              if (S !== 0)
                p = Q;
              else
                return e.bitb = E, e.bitk = R, h.avail_in = S, h.total_in += D - h.next_in_index, h.next_in_index = D, e.write = T, e.inflate_flush(h, p);
              S--, E |= (h.read_byte(D++) & 255) << R, R += 8;
            }
            if (m = _[(g[0] + (E & Ae[m])) * 3 + 1], X = _[(g[0] + (E & Ae[m])) * 3 + 2], X < 16)
              E >>>= m, R -= m, l[c++] = X;
            else {
              for (b = X == 18 ? 7 : X - 14, K = X == 18 ? 11 : 3; R < m + b; ) {
                if (S !== 0)
                  p = Q;
                else
                  return e.bitb = E, e.bitk = R, h.avail_in = S, h.total_in += D - h.next_in_index, h.next_in_index = D, e.write = T, e.inflate_flush(h, p);
                S--, E |= (h.read_byte(D++) & 255) << R, R += 8;
              }
              if (E >>>= m, R -= m, K += E & Ae[b], E >>>= b, R -= b, b = c, m = o, b + K > 258 + (m & 31) + (m >> 5 & 31) || X == 16 && b < 1)
                return l = null, r = Qe, h.msg = "invalid bit length repeat", p = se, e.bitb = E, e.bitk = R, h.avail_in = S, h.total_in += D - h.next_in_index, h.next_in_index = D, e.write = T, e.inflate_flush(h, p);
              X = X == 16 ? l[b - 1] : 0;
              do
                l[b++] = X;
              while (--K !== 0);
              c = b;
            }
          }
          if (g[0] = -1, O = [], Z = [], H = [], j = [], O[0] = 9, Z[0] = 6, m = o, m = P.inflate_trees_dynamic(257 + (m & 31), 1 + (m >> 5 & 31), l, O, Z, H, j, _, h), m != Q)
            return m == se && (l = null, r = Qe), p = m, e.bitb = E, e.bitk = R, h.avail_in = S, h.total_in += D - h.next_in_index, h.next_in_index = D, e.write = T, e.inflate_flush(h, p);
          x.init(O[0], Z[0], _, H[0], _, j[0]), r = Bt;
        case Bt:
          if (e.bitb = E, e.bitk = R, h.avail_in = S, h.total_in += D - h.next_in_index, h.next_in_index = D, e.write = T, (p = x.proc(e, h, p)) != qe)
            return e.inflate_flush(h, p);
          if (p = Q, x.free(h), D = h.next_in_index, S = h.avail_in, E = e.bitb, R = e.bitk, T = e.write, F = /* (int) */
          T < e.read ? e.read - T - 1 : e.end - T, w === 0) {
            r = ot;
            break;
          }
          r = Nt;
        case Nt:
          if (e.write = T, p = e.inflate_flush(h, p), T = e.write, F = /* (int) */
          T < e.read ? e.read - T - 1 : e.end - T, e.read != e.write)
            return e.bitb = E, e.bitk = R, h.avail_in = S, h.total_in += D - h.next_in_index, h.next_in_index = D, e.write = T, e.inflate_flush(h, p);
          r = sr;
        case sr:
          return p = qe, e.bitb = E, e.bitk = R, h.avail_in = S, h.total_in += D - h.next_in_index, h.next_in_index = D, e.write = T, e.inflate_flush(h, p);
        case Qe:
          return p = se, e.bitb = E, e.bitk = R, h.avail_in = S, h.total_in += D - h.next_in_index, h.next_in_index = D, e.write = T, e.inflate_flush(h, p);
        default:
          return p = ke, e.bitb = E, e.bitk = R, h.avail_in = S, h.total_in += D - h.next_in_index, h.next_in_index = D, e.write = T, e.inflate_flush(h, p);
      }
    }
  }, e.free = function(h) {
    e.reset(h, null), e.win = null, _ = null;
  }, e.set_dictionary = function(h, p, m) {
    e.win.set(h.subarray(p, p + m), 0), e.read = e.write = m;
  }, e.sync_point = function() {
    return r == ln ? 1 : 0;
  };
}
const Os = 32, Ps = 8, Bs = 0, ar = 1, or = 2, cr = 3, lr = 4, fr = 5, fn = 6, _t = 7, ur = 12, Ge = 13, Ns = [0, 0, 255, 255];
function Ms() {
  const n = this;
  n.mode = 0, n.method = 0, n.was = [0], n.need = 0, n.marker = 0, n.wbits = 0;
  function t(e) {
    return !e || !e.istate ? ke : (e.total_in = e.total_out = 0, e.msg = null, e.istate.mode = _t, e.istate.blocks.reset(e, null), Q);
  }
  n.inflateEnd = function(e) {
    return n.blocks && n.blocks.free(e), n.blocks = null, Q;
  }, n.inflateInit = function(e, r) {
    return e.msg = null, n.blocks = null, r < 8 || r > 15 ? (n.inflateEnd(e), ke) : (n.wbits = r, e.istate.blocks = new Us(e, 1 << r), t(e), Q);
  }, n.inflate = function(e, r) {
    let a, o;
    if (!e || !e.istate || !e.next_in)
      return ke;
    const c = e.istate;
    for (r = r == ks ? je : Q, a = je; ; )
      switch (c.mode) {
        case Bs:
          if (e.avail_in === 0)
            return a;
          if (a = r, e.avail_in--, e.total_in++, ((c.method = e.read_byte(e.next_in_index++)) & 15) != Ps) {
            c.mode = Ge, e.msg = "unknown compression method", c.marker = 5;
            break;
          }
          if ((c.method >> 4) + 8 > c.wbits) {
            c.mode = Ge, e.msg = "invalid win size", c.marker = 5;
            break;
          }
          c.mode = ar;
        case ar:
          if (e.avail_in === 0)
            return a;
          if (a = r, e.avail_in--, e.total_in++, o = e.read_byte(e.next_in_index++) & 255, ((c.method << 8) + o) % 31 !== 0) {
            c.mode = Ge, e.msg = "incorrect header check", c.marker = 5;
            break;
          }
          if (!(o & Os)) {
            c.mode = _t;
            break;
          }
          c.mode = or;
        case or:
          if (e.avail_in === 0)
            return a;
          a = r, e.avail_in--, e.total_in++, c.need = (e.read_byte(e.next_in_index++) & 255) << 24 & 4278190080, c.mode = cr;
        case cr:
          if (e.avail_in === 0)
            return a;
          a = r, e.avail_in--, e.total_in++, c.need += (e.read_byte(e.next_in_index++) & 255) << 16 & 16711680, c.mode = lr;
        case lr:
          if (e.avail_in === 0)
            return a;
          a = r, e.avail_in--, e.total_in++, c.need += (e.read_byte(e.next_in_index++) & 255) << 8 & 65280, c.mode = fr;
        case fr:
          return e.avail_in === 0 ? a : (a = r, e.avail_in--, e.total_in++, c.need += e.read_byte(e.next_in_index++) & 255, c.mode = fn, vs);
        case fn:
          return c.mode = Ge, e.msg = "need dictionary", c.marker = 0, ke;
        case _t:
          if (a = c.blocks.proc(e, a), a == se) {
            c.mode = Ge, c.marker = 0;
            break;
          }
          if (a == Q && (a = r), a != qe)
            return a;
          a = r, c.blocks.reset(e, c.was), c.mode = ur;
        case ur:
          return e.avail_in = 0, qe;
        case Ge:
          return se;
        default:
          return ke;
      }
  }, n.inflateSetDictionary = function(e, r, a) {
    let o = 0, c = a;
    if (!e || !e.istate || e.istate.mode != fn)
      return ke;
    const l = e.istate;
    return c >= 1 << l.wbits && (c = (1 << l.wbits) - 1, o = a - c), l.blocks.set_dictionary(r, o, c), l.mode = _t, Q;
  }, n.inflateSync = function(e) {
    let r, a, o, c, l;
    if (!e || !e.istate)
      return ke;
    const u = e.istate;
    if (u.mode != Ge && (u.mode = Ge, u.marker = 0), (r = e.avail_in) === 0)
      return je;
    for (a = e.next_in_index, o = u.marker; r !== 0 && o < 4; )
      e.read_byte(a) == Ns[o] ? o++ : e.read_byte(a) !== 0 ? o = 0 : o = 4 - o, a++, r--;
    return e.total_in += a - e.next_in_index, e.next_in_index = a, e.avail_in = r, u.marker = o, o != 4 ? se : (c = e.total_in, l = e.total_out, t(e), e.total_in = c, e.total_out = l, u.mode = _t, Q);
  }, n.inflateSyncPoint = function(e) {
    return !e || !e.istate || !e.istate.blocks ? ke : e.istate.blocks.sync_point();
  };
}
function Xr() {
}
Xr.prototype = {
  inflateInit(n) {
    const t = this;
    return t.istate = new Ms(), n || (n = ys), t.istate.inflateInit(t, n);
  },
  inflate(n) {
    const t = this;
    return t.istate ? t.istate.inflate(t, n) : ke;
  },
  inflateEnd() {
    const n = this;
    if (!n.istate)
      return ke;
    const t = n.istate.inflateEnd(n);
    return n.istate = null, t;
  },
  inflateSync() {
    const n = this;
    return n.istate ? n.istate.inflateSync(n) : ke;
  },
  inflateSetDictionary(n, t) {
    const e = this;
    return e.istate ? e.istate.inflateSetDictionary(e, n, t) : ke;
  },
  read_byte(n) {
    return this.next_in[n];
  },
  read_buf(n, t) {
    return this.next_in.subarray(n, n + t);
  }
};
function Ws(n) {
  const t = this, e = new Xr(), r = n && n.chunkSize ? Math.floor(n.chunkSize * 2) : 128 * 1024, a = Es, o = new Uint8Array(r);
  let c = !1;
  e.inflateInit(), e.next_out = o, t.append = function(l, u) {
    const g = [];
    let x, w, _ = 0, A = 0, P = 0;
    if (l.length !== 0) {
      e.next_in_index = 0, e.next_in = l, e.avail_in = l.length;
      do {
        if (e.next_out_index = 0, e.avail_out = r, e.avail_in === 0 && !c && (e.next_in_index = 0, c = !0), x = e.inflate(a), c && x === je) {
          if (e.avail_in !== 0)
            throw new Error("inflating: bad input");
        } else if (x !== Q && x !== qe)
          throw new Error("inflating: " + e.msg);
        if ((c || x === qe) && e.avail_in === l.length)
          throw new Error("inflating: bad input");
        e.next_out_index && (e.next_out_index === r ? g.push(new Uint8Array(o)) : g.push(o.subarray(0, e.next_out_index))), P += e.next_out_index, u && e.next_in_index > 0 && e.next_in_index != _ && (u(e.next_in_index), _ = e.next_in_index);
      } while (e.avail_in > 0 || e.avail_out === 0);
      return g.length > 1 ? (w = new Uint8Array(P), g.forEach(function(h) {
        w.set(h, A), A += h.length;
      })) : w = g[0] ? new Uint8Array(g[0]) : new Uint8Array(), w;
    }
  }, t.flush = function() {
    e.inflateEnd();
  };
}
const nt = 4294967295, Ke = 65535, qs = 8, js = 0, Hs = 99, Ys = 67324752, Gs = 134695760, dr = 33639248, Vs = 101010256, pr = 101075792, Zs = 117853008, ct = 22, un = 20, dn = 56, Ks = 1, Xs = 39169, $s = 10, Js = 1, zs = 21589, Qs = 28789, ea = 25461, ta = 6534, mr = 1, na = 6, hr = 8, xr = 2048, wr = 16, _r = 16384, gr = 73, br = "/", ve = void 0, $e = "undefined", kt = "function";
class yr {
  constructor(t) {
    return class extends TransformStream {
      constructor(e, r) {
        const a = new t(r);
        super({
          transform(o, c) {
            c.enqueue(a.append(o));
          },
          flush(o) {
            const c = a.flush();
            c && o.enqueue(c);
          }
        });
      }
    };
  }
}
const ra = 64;
let $r = 2;
try {
  typeof navigator != $e && navigator.hardwareConcurrency && ($r = navigator.hardwareConcurrency);
} catch {
}
const ia = {
  chunkSize: 512 * 1024,
  maxWorkers: $r,
  terminateWorkerTimeout: 5e3,
  useWebWorkers: !0,
  useCompressionStream: !0,
  workerScripts: ve,
  CompressionStreamNative: typeof CompressionStream != $e && CompressionStream,
  DecompressionStreamNative: typeof DecompressionStream != $e && DecompressionStream
}, Xe = Object.assign({}, ia);
function sa() {
  return Xe;
}
function aa(n) {
  return Math.max(n.chunkSize, ra);
}
function Dn(n) {
  const {
    baseURL: t,
    chunkSize: e,
    maxWorkers: r,
    terminateWorkerTimeout: a,
    useCompressionStream: o,
    useWebWorkers: c,
    Deflate: l,
    Inflate: u,
    CompressionStream: g,
    DecompressionStream: x,
    workerScripts: w
  } = n;
  if (Ve("baseURL", t), Ve("chunkSize", e), Ve("maxWorkers", r), Ve("terminateWorkerTimeout", a), Ve("useCompressionStream", o), Ve("useWebWorkers", c), l && (Xe.CompressionStream = new yr(l)), u && (Xe.DecompressionStream = new yr(u)), Ve("CompressionStream", g), Ve("DecompressionStream", x), w !== ve) {
    const { deflate: _, inflate: A } = w;
    if ((_ || A) && (Xe.workerScripts || (Xe.workerScripts = {})), _) {
      if (!Array.isArray(_))
        throw new Error("workerScripts.deflate must be an array");
      Xe.workerScripts.deflate = _;
    }
    if (A) {
      if (!Array.isArray(A))
        throw new Error("workerScripts.inflate must be an array");
      Xe.workerScripts.inflate = A;
    }
  }
}
function Ve(n, t) {
  t !== ve && (Xe[n] = t);
}
const pn = {
  application: {
    "andrew-inset": "ez",
    annodex: "anx",
    "atom+xml": "atom",
    "atomcat+xml": "atomcat",
    "atomserv+xml": "atomsrv",
    bbolin: "lin",
    "cu-seeme": "cu",
    "davmount+xml": "davmount",
    dsptype: "tsp",
    ecmascript: [
      "es",
      "ecma"
    ],
    futuresplash: "spl",
    hta: "hta",
    "java-archive": "jar",
    "java-serialized-object": "ser",
    "java-vm": "class",
    m3g: "m3g",
    "mac-binhex40": "hqx",
    mathematica: [
      "nb",
      "ma",
      "mb"
    ],
    msaccess: "mdb",
    msword: [
      "doc",
      "dot",
      "wiz"
    ],
    mxf: "mxf",
    oda: "oda",
    ogg: "ogx",
    pdf: "pdf",
    "pgp-keys": "key",
    "pgp-signature": [
      "asc",
      "sig"
    ],
    "pics-rules": "prf",
    postscript: [
      "ps",
      "ai",
      "eps",
      "epsi",
      "epsf",
      "eps2",
      "eps3"
    ],
    rar: "rar",
    "rdf+xml": "rdf",
    "rss+xml": "rss",
    rtf: "rtf",
    "xhtml+xml": [
      "xhtml",
      "xht"
    ],
    xml: [
      "xml",
      "xsl",
      "xsd",
      "xpdl"
    ],
    "xspf+xml": "xspf",
    zip: "zip",
    "vnd.android.package-archive": "apk",
    "vnd.cinderella": "cdy",
    "vnd.google-earth.kml+xml": "kml",
    "vnd.google-earth.kmz": "kmz",
    "vnd.mozilla.xul+xml": "xul",
    "vnd.ms-excel": [
      "xls",
      "xlb",
      "xlt",
      "xlm",
      "xla",
      "xlc",
      "xlw"
    ],
    "vnd.ms-pki.seccat": "cat",
    "vnd.ms-pki.stl": "stl",
    "vnd.ms-powerpoint": [
      "ppt",
      "pps",
      "pot",
      "ppa",
      "pwz"
    ],
    "vnd.oasis.opendocument.chart": "odc",
    "vnd.oasis.opendocument.database": "odb",
    "vnd.oasis.opendocument.formula": "odf",
    "vnd.oasis.opendocument.graphics": "odg",
    "vnd.oasis.opendocument.graphics-template": "otg",
    "vnd.oasis.opendocument.image": "odi",
    "vnd.oasis.opendocument.presentation": "odp",
    "vnd.oasis.opendocument.presentation-template": "otp",
    "vnd.oasis.opendocument.spreadsheet": "ods",
    "vnd.oasis.opendocument.spreadsheet-template": "ots",
    "vnd.oasis.opendocument.text": "odt",
    "vnd.oasis.opendocument.text-master": [
      "odm",
      "otm"
    ],
    "vnd.oasis.opendocument.text-template": "ott",
    "vnd.oasis.opendocument.text-web": "oth",
    "vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
    "vnd.openxmlformats-officedocument.spreadsheetml.template": "xltx",
    "vnd.openxmlformats-officedocument.presentationml.presentation": "pptx",
    "vnd.openxmlformats-officedocument.presentationml.slideshow": "ppsx",
    "vnd.openxmlformats-officedocument.presentationml.template": "potx",
    "vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
    "vnd.openxmlformats-officedocument.wordprocessingml.template": "dotx",
    "vnd.smaf": "mmf",
    "vnd.stardivision.calc": "sdc",
    "vnd.stardivision.chart": "sds",
    "vnd.stardivision.draw": "sda",
    "vnd.stardivision.impress": "sdd",
    "vnd.stardivision.math": [
      "sdf",
      "smf"
    ],
    "vnd.stardivision.writer": [
      "sdw",
      "vor"
    ],
    "vnd.stardivision.writer-global": "sgl",
    "vnd.sun.xml.calc": "sxc",
    "vnd.sun.xml.calc.template": "stc",
    "vnd.sun.xml.draw": "sxd",
    "vnd.sun.xml.draw.template": "std",
    "vnd.sun.xml.impress": "sxi",
    "vnd.sun.xml.impress.template": "sti",
    "vnd.sun.xml.math": "sxm",
    "vnd.sun.xml.writer": "sxw",
    "vnd.sun.xml.writer.global": "sxg",
    "vnd.sun.xml.writer.template": "stw",
    "vnd.symbian.install": [
      "sis",
      "sisx"
    ],
    "vnd.visio": [
      "vsd",
      "vst",
      "vss",
      "vsw",
      "vsdx",
      "vssx",
      "vstx",
      "vssm",
      "vstm"
    ],
    "vnd.wap.wbxml": "wbxml",
    "vnd.wap.wmlc": "wmlc",
    "vnd.wap.wmlscriptc": "wmlsc",
    "vnd.wordperfect": "wpd",
    "vnd.wordperfect5.1": "wp5",
    "x-123": "wk",
    "x-7z-compressed": "7z",
    "x-abiword": "abw",
    "x-apple-diskimage": "dmg",
    "x-bcpio": "bcpio",
    "x-bittorrent": "torrent",
    "x-cbr": [
      "cbr",
      "cba",
      "cbt",
      "cb7"
    ],
    "x-cbz": "cbz",
    "x-cdf": [
      "cdf",
      "cda"
    ],
    "x-cdlink": "vcd",
    "x-chess-pgn": "pgn",
    "x-cpio": "cpio",
    "x-csh": "csh",
    "x-director": [
      "dir",
      "dxr",
      "cst",
      "cct",
      "cxt",
      "w3d",
      "fgd",
      "swa"
    ],
    "x-dms": "dms",
    "x-doom": "wad",
    "x-dvi": "dvi",
    "x-httpd-eruby": "rhtml",
    "x-font": "pcf.Z",
    "x-freemind": "mm",
    "x-gnumeric": "gnumeric",
    "x-go-sgf": "sgf",
    "x-graphing-calculator": "gcf",
    "x-gtar": [
      "gtar",
      "taz"
    ],
    "x-hdf": "hdf",
    "x-httpd-php": [
      "phtml",
      "pht",
      "php"
    ],
    "x-httpd-php-source": "phps",
    "x-httpd-php3": "php3",
    "x-httpd-php3-preprocessed": "php3p",
    "x-httpd-php4": "php4",
    "x-httpd-php5": "php5",
    "x-ica": "ica",
    "x-info": "info",
    "x-internet-signup": [
      "ins",
      "isp"
    ],
    "x-iphone": "iii",
    "x-iso9660-image": "iso",
    "x-java-jnlp-file": "jnlp",
    "x-jmol": "jmz",
    "x-killustrator": "kil",
    "x-latex": "latex",
    "x-lyx": "lyx",
    "x-lzx": "lzx",
    "x-maker": [
      "frm",
      "fb",
      "fbdoc"
    ],
    "x-ms-wmd": "wmd",
    "x-msdos-program": [
      "com",
      "exe",
      "bat",
      "dll"
    ],
    "x-netcdf": [
      "nc"
    ],
    "x-ns-proxy-autoconfig": [
      "pac",
      "dat"
    ],
    "x-nwc": "nwc",
    "x-object": "o",
    "x-oz-application": "oza",
    "x-pkcs7-certreqresp": "p7r",
    "x-python-code": [
      "pyc",
      "pyo"
    ],
    "x-qgis": [
      "qgs",
      "shp",
      "shx"
    ],
    "x-quicktimeplayer": "qtl",
    "x-redhat-package-manager": [
      "rpm",
      "rpa"
    ],
    "x-ruby": "rb",
    "x-sh": "sh",
    "x-shar": "shar",
    "x-shockwave-flash": [
      "swf",
      "swfl"
    ],
    "x-silverlight": "scr",
    "x-stuffit": "sit",
    "x-sv4cpio": "sv4cpio",
    "x-sv4crc": "sv4crc",
    "x-tar": "tar",
    "x-tex-gf": "gf",
    "x-tex-pk": "pk",
    "x-texinfo": [
      "texinfo",
      "texi"
    ],
    "x-trash": [
      "~",
      "%",
      "bak",
      "old",
      "sik"
    ],
    "x-ustar": "ustar",
    "x-wais-source": "src",
    "x-wingz": "wz",
    "x-x509-ca-cert": [
      "crt",
      "der",
      "cer"
    ],
    "x-xcf": "xcf",
    "x-xfig": "fig",
    "x-xpinstall": "xpi",
    applixware: "aw",
    "atomsvc+xml": "atomsvc",
    "ccxml+xml": "ccxml",
    "cdmi-capability": "cdmia",
    "cdmi-container": "cdmic",
    "cdmi-domain": "cdmid",
    "cdmi-object": "cdmio",
    "cdmi-queue": "cdmiq",
    "docbook+xml": "dbk",
    "dssc+der": "dssc",
    "dssc+xml": "xdssc",
    "emma+xml": "emma",
    "epub+zip": "epub",
    exi: "exi",
    "font-tdpfr": "pfr",
    "gml+xml": "gml",
    "gpx+xml": "gpx",
    gxf: "gxf",
    hyperstudio: "stk",
    "inkml+xml": [
      "ink",
      "inkml"
    ],
    ipfix: "ipfix",
    "jsonml+json": "jsonml",
    "lost+xml": "lostxml",
    "mads+xml": "mads",
    marc: "mrc",
    "marcxml+xml": "mrcx",
    "mathml+xml": [
      "mathml",
      "mml"
    ],
    mbox: "mbox",
    "mediaservercontrol+xml": "mscml",
    "metalink+xml": "metalink",
    "metalink4+xml": "meta4",
    "mets+xml": "mets",
    "mods+xml": "mods",
    mp21: [
      "m21",
      "mp21"
    ],
    mp4: "mp4s",
    "oebps-package+xml": "opf",
    "omdoc+xml": "omdoc",
    onenote: [
      "onetoc",
      "onetoc2",
      "onetmp",
      "onepkg"
    ],
    oxps: "oxps",
    "patch-ops-error+xml": "xer",
    "pgp-encrypted": "pgp",
    pkcs10: "p10",
    "pkcs7-mime": [
      "p7m",
      "p7c"
    ],
    "pkcs7-signature": "p7s",
    pkcs8: "p8",
    "pkix-attr-cert": "ac",
    "pkix-crl": "crl",
    "pkix-pkipath": "pkipath",
    pkixcmp: "pki",
    "pls+xml": "pls",
    "prs.cww": "cww",
    "pskc+xml": "pskcxml",
    "reginfo+xml": "rif",
    "relax-ng-compact-syntax": "rnc",
    "resource-lists+xml": "rl",
    "resource-lists-diff+xml": "rld",
    "rls-services+xml": "rs",
    "rpki-ghostbusters": "gbr",
    "rpki-manifest": "mft",
    "rpki-roa": "roa",
    "rsd+xml": "rsd",
    "sbml+xml": "sbml",
    "scvp-cv-request": "scq",
    "scvp-cv-response": "scs",
    "scvp-vp-request": "spq",
    "scvp-vp-response": "spp",
    sdp: "sdp",
    "set-payment-initiation": "setpay",
    "set-registration-initiation": "setreg",
    "shf+xml": "shf",
    "sparql-query": "rq",
    "sparql-results+xml": "srx",
    srgs: "gram",
    "srgs+xml": "grxml",
    "sru+xml": "sru",
    "ssdl+xml": "ssdl",
    "ssml+xml": "ssml",
    "tei+xml": [
      "tei",
      "teicorpus"
    ],
    "thraud+xml": "tfi",
    "timestamped-data": "tsd",
    "vnd.3gpp.pic-bw-large": "plb",
    "vnd.3gpp.pic-bw-small": "psb",
    "vnd.3gpp.pic-bw-var": "pvb",
    "vnd.3gpp2.tcap": "tcap",
    "vnd.3m.post-it-notes": "pwn",
    "vnd.accpac.simply.aso": "aso",
    "vnd.accpac.simply.imp": "imp",
    "vnd.acucobol": "acu",
    "vnd.acucorp": [
      "atc",
      "acutc"
    ],
    "vnd.adobe.air-application-installer-package+zip": "air",
    "vnd.adobe.formscentral.fcdt": "fcdt",
    "vnd.adobe.fxp": [
      "fxp",
      "fxpl"
    ],
    "vnd.adobe.xdp+xml": "xdp",
    "vnd.adobe.xfdf": "xfdf",
    "vnd.ahead.space": "ahead",
    "vnd.airzip.filesecure.azf": "azf",
    "vnd.airzip.filesecure.azs": "azs",
    "vnd.amazon.ebook": "azw",
    "vnd.americandynamics.acc": "acc",
    "vnd.amiga.ami": "ami",
    "vnd.anser-web-certificate-issue-initiation": "cii",
    "vnd.anser-web-funds-transfer-initiation": "fti",
    "vnd.antix.game-component": "atx",
    "vnd.apple.installer+xml": "mpkg",
    "vnd.apple.mpegurl": "m3u8",
    "vnd.aristanetworks.swi": "swi",
    "vnd.astraea-software.iota": "iota",
    "vnd.audiograph": "aep",
    "vnd.blueice.multipass": "mpm",
    "vnd.bmi": "bmi",
    "vnd.businessobjects": "rep",
    "vnd.chemdraw+xml": "cdxml",
    "vnd.chipnuts.karaoke-mmd": "mmd",
    "vnd.claymore": "cla",
    "vnd.cloanto.rp9": "rp9",
    "vnd.clonk.c4group": [
      "c4g",
      "c4d",
      "c4f",
      "c4p",
      "c4u"
    ],
    "vnd.cluetrust.cartomobile-config": "c11amc",
    "vnd.cluetrust.cartomobile-config-pkg": "c11amz",
    "vnd.commonspace": "csp",
    "vnd.contact.cmsg": "cdbcmsg",
    "vnd.cosmocaller": "cmc",
    "vnd.crick.clicker": "clkx",
    "vnd.crick.clicker.keyboard": "clkk",
    "vnd.crick.clicker.palette": "clkp",
    "vnd.crick.clicker.template": "clkt",
    "vnd.crick.clicker.wordbank": "clkw",
    "vnd.criticaltools.wbs+xml": "wbs",
    "vnd.ctc-posml": "pml",
    "vnd.cups-ppd": "ppd",
    "vnd.curl.car": "car",
    "vnd.curl.pcurl": "pcurl",
    "vnd.dart": "dart",
    "vnd.data-vision.rdz": "rdz",
    "vnd.dece.data": [
      "uvf",
      "uvvf",
      "uvd",
      "uvvd"
    ],
    "vnd.dece.ttml+xml": [
      "uvt",
      "uvvt"
    ],
    "vnd.dece.unspecified": [
      "uvx",
      "uvvx"
    ],
    "vnd.dece.zip": [
      "uvz",
      "uvvz"
    ],
    "vnd.denovo.fcselayout-link": "fe_launch",
    "vnd.dna": "dna",
    "vnd.dolby.mlp": "mlp",
    "vnd.dpgraph": "dpg",
    "vnd.dreamfactory": "dfac",
    "vnd.ds-keypoint": "kpxx",
    "vnd.dvb.ait": "ait",
    "vnd.dvb.service": "svc",
    "vnd.dynageo": "geo",
    "vnd.ecowin.chart": "mag",
    "vnd.enliven": "nml",
    "vnd.epson.esf": "esf",
    "vnd.epson.msf": "msf",
    "vnd.epson.quickanime": "qam",
    "vnd.epson.salt": "slt",
    "vnd.epson.ssf": "ssf",
    "vnd.eszigno3+xml": [
      "es3",
      "et3"
    ],
    "vnd.ezpix-album": "ez2",
    "vnd.ezpix-package": "ez3",
    "vnd.fdf": "fdf",
    "vnd.fdsn.mseed": "mseed",
    "vnd.fdsn.seed": [
      "seed",
      "dataless"
    ],
    "vnd.flographit": "gph",
    "vnd.fluxtime.clip": "ftc",
    "vnd.framemaker": [
      "fm",
      "frame",
      "maker",
      "book"
    ],
    "vnd.frogans.fnc": "fnc",
    "vnd.frogans.ltf": "ltf",
    "vnd.fsc.weblaunch": "fsc",
    "vnd.fujitsu.oasys": "oas",
    "vnd.fujitsu.oasys2": "oa2",
    "vnd.fujitsu.oasys3": "oa3",
    "vnd.fujitsu.oasysgp": "fg5",
    "vnd.fujitsu.oasysprs": "bh2",
    "vnd.fujixerox.ddd": "ddd",
    "vnd.fujixerox.docuworks": "xdw",
    "vnd.fujixerox.docuworks.binder": "xbd",
    "vnd.fuzzysheet": "fzs",
    "vnd.genomatix.tuxedo": "txd",
    "vnd.geogebra.file": "ggb",
    "vnd.geogebra.tool": "ggt",
    "vnd.geometry-explorer": [
      "gex",
      "gre"
    ],
    "vnd.geonext": "gxt",
    "vnd.geoplan": "g2w",
    "vnd.geospace": "g3w",
    "vnd.gmx": "gmx",
    "vnd.grafeq": [
      "gqf",
      "gqs"
    ],
    "vnd.groove-account": "gac",
    "vnd.groove-help": "ghf",
    "vnd.groove-identity-message": "gim",
    "vnd.groove-injector": "grv",
    "vnd.groove-tool-message": "gtm",
    "vnd.groove-tool-template": "tpl",
    "vnd.groove-vcard": "vcg",
    "vnd.hal+xml": "hal",
    "vnd.handheld-entertainment+xml": "zmm",
    "vnd.hbci": "hbci",
    "vnd.hhe.lesson-player": "les",
    "vnd.hp-hpgl": "hpgl",
    "vnd.hp-hpid": "hpid",
    "vnd.hp-hps": "hps",
    "vnd.hp-jlyt": "jlt",
    "vnd.hp-pcl": "pcl",
    "vnd.hp-pclxl": "pclxl",
    "vnd.hydrostatix.sof-data": "sfd-hdstx",
    "vnd.ibm.minipay": "mpy",
    "vnd.ibm.modcap": [
      "afp",
      "listafp",
      "list3820"
    ],
    "vnd.ibm.rights-management": "irm",
    "vnd.ibm.secure-container": "sc",
    "vnd.iccprofile": [
      "icc",
      "icm"
    ],
    "vnd.igloader": "igl",
    "vnd.immervision-ivp": "ivp",
    "vnd.immervision-ivu": "ivu",
    "vnd.insors.igm": "igm",
    "vnd.intercon.formnet": [
      "xpw",
      "xpx"
    ],
    "vnd.intergeo": "i2g",
    "vnd.intu.qbo": "qbo",
    "vnd.intu.qfx": "qfx",
    "vnd.ipunplugged.rcprofile": "rcprofile",
    "vnd.irepository.package+xml": "irp",
    "vnd.is-xpr": "xpr",
    "vnd.isac.fcs": "fcs",
    "vnd.jam": "jam",
    "vnd.jcp.javame.midlet-rms": "rms",
    "vnd.jisp": "jisp",
    "vnd.joost.joda-archive": "joda",
    "vnd.kahootz": [
      "ktz",
      "ktr"
    ],
    "vnd.kde.karbon": "karbon",
    "vnd.kde.kchart": "chrt",
    "vnd.kde.kformula": "kfo",
    "vnd.kde.kivio": "flw",
    "vnd.kde.kontour": "kon",
    "vnd.kde.kpresenter": [
      "kpr",
      "kpt"
    ],
    "vnd.kde.kspread": "ksp",
    "vnd.kde.kword": [
      "kwd",
      "kwt"
    ],
    "vnd.kenameaapp": "htke",
    "vnd.kidspiration": "kia",
    "vnd.kinar": [
      "kne",
      "knp"
    ],
    "vnd.koan": [
      "skp",
      "skd",
      "skt",
      "skm"
    ],
    "vnd.kodak-descriptor": "sse",
    "vnd.las.las+xml": "lasxml",
    "vnd.llamagraphics.life-balance.desktop": "lbd",
    "vnd.llamagraphics.life-balance.exchange+xml": "lbe",
    "vnd.lotus-1-2-3": "123",
    "vnd.lotus-approach": "apr",
    "vnd.lotus-freelance": "pre",
    "vnd.lotus-notes": "nsf",
    "vnd.lotus-organizer": "org",
    "vnd.lotus-screencam": "scm",
    "vnd.lotus-wordpro": "lwp",
    "vnd.macports.portpkg": "portpkg",
    "vnd.mcd": "mcd",
    "vnd.medcalcdata": "mc1",
    "vnd.mediastation.cdkey": "cdkey",
    "vnd.mfer": "mwf",
    "vnd.mfmp": "mfm",
    "vnd.micrografx.flo": "flo",
    "vnd.micrografx.igx": "igx",
    "vnd.mif": "mif",
    "vnd.mobius.daf": "daf",
    "vnd.mobius.dis": "dis",
    "vnd.mobius.mbk": "mbk",
    "vnd.mobius.mqy": "mqy",
    "vnd.mobius.msl": "msl",
    "vnd.mobius.plc": "plc",
    "vnd.mobius.txf": "txf",
    "vnd.mophun.application": "mpn",
    "vnd.mophun.certificate": "mpc",
    "vnd.ms-artgalry": "cil",
    "vnd.ms-cab-compressed": "cab",
    "vnd.ms-excel.addin.macroenabled.12": "xlam",
    "vnd.ms-excel.sheet.binary.macroenabled.12": "xlsb",
    "vnd.ms-excel.sheet.macroenabled.12": "xlsm",
    "vnd.ms-excel.template.macroenabled.12": "xltm",
    "vnd.ms-fontobject": "eot",
    "vnd.ms-htmlhelp": "chm",
    "vnd.ms-ims": "ims",
    "vnd.ms-lrm": "lrm",
    "vnd.ms-officetheme": "thmx",
    "vnd.ms-powerpoint.addin.macroenabled.12": "ppam",
    "vnd.ms-powerpoint.presentation.macroenabled.12": "pptm",
    "vnd.ms-powerpoint.slide.macroenabled.12": "sldm",
    "vnd.ms-powerpoint.slideshow.macroenabled.12": "ppsm",
    "vnd.ms-powerpoint.template.macroenabled.12": "potm",
    "vnd.ms-project": [
      "mpp",
      "mpt"
    ],
    "vnd.ms-word.document.macroenabled.12": "docm",
    "vnd.ms-word.template.macroenabled.12": "dotm",
    "vnd.ms-works": [
      "wps",
      "wks",
      "wcm",
      "wdb"
    ],
    "vnd.ms-wpl": "wpl",
    "vnd.ms-xpsdocument": "xps",
    "vnd.mseq": "mseq",
    "vnd.musician": "mus",
    "vnd.muvee.style": "msty",
    "vnd.mynfc": "taglet",
    "vnd.neurolanguage.nlu": "nlu",
    "vnd.nitf": [
      "ntf",
      "nitf"
    ],
    "vnd.noblenet-directory": "nnd",
    "vnd.noblenet-sealer": "nns",
    "vnd.noblenet-web": "nnw",
    "vnd.nokia.n-gage.data": "ngdat",
    "vnd.nokia.n-gage.symbian.install": "n-gage",
    "vnd.nokia.radio-preset": "rpst",
    "vnd.nokia.radio-presets": "rpss",
    "vnd.novadigm.edm": "edm",
    "vnd.novadigm.edx": "edx",
    "vnd.novadigm.ext": "ext",
    "vnd.oasis.opendocument.chart-template": "otc",
    "vnd.oasis.opendocument.formula-template": "odft",
    "vnd.oasis.opendocument.image-template": "oti",
    "vnd.olpc-sugar": "xo",
    "vnd.oma.dd2+xml": "dd2",
    "vnd.openofficeorg.extension": "oxt",
    "vnd.openxmlformats-officedocument.presentationml.slide": "sldx",
    "vnd.osgeo.mapguide.package": "mgp",
    "vnd.osgi.dp": "dp",
    "vnd.osgi.subsystem": "esa",
    "vnd.palm": [
      "pdb",
      "pqa",
      "oprc"
    ],
    "vnd.pawaafile": "paw",
    "vnd.pg.format": "str",
    "vnd.pg.osasli": "ei6",
    "vnd.picsel": "efif",
    "vnd.pmi.widget": "wg",
    "vnd.pocketlearn": "plf",
    "vnd.powerbuilder6": "pbd",
    "vnd.previewsystems.box": "box",
    "vnd.proteus.magazine": "mgz",
    "vnd.publishare-delta-tree": "qps",
    "vnd.pvi.ptid1": "ptid",
    "vnd.quark.quarkxpress": [
      "qxd",
      "qxt",
      "qwd",
      "qwt",
      "qxl",
      "qxb"
    ],
    "vnd.realvnc.bed": "bed",
    "vnd.recordare.musicxml": "mxl",
    "vnd.recordare.musicxml+xml": "musicxml",
    "vnd.rig.cryptonote": "cryptonote",
    "vnd.rn-realmedia": "rm",
    "vnd.rn-realmedia-vbr": "rmvb",
    "vnd.route66.link66+xml": "link66",
    "vnd.sailingtracker.track": "st",
    "vnd.seemail": "see",
    "vnd.sema": "sema",
    "vnd.semd": "semd",
    "vnd.semf": "semf",
    "vnd.shana.informed.formdata": "ifm",
    "vnd.shana.informed.formtemplate": "itp",
    "vnd.shana.informed.interchange": "iif",
    "vnd.shana.informed.package": "ipk",
    "vnd.simtech-mindmapper": [
      "twd",
      "twds"
    ],
    "vnd.smart.teacher": "teacher",
    "vnd.solent.sdkm+xml": [
      "sdkm",
      "sdkd"
    ],
    "vnd.spotfire.dxp": "dxp",
    "vnd.spotfire.sfs": "sfs",
    "vnd.stepmania.package": "smzip",
    "vnd.stepmania.stepchart": "sm",
    "vnd.sus-calendar": [
      "sus",
      "susp"
    ],
    "vnd.svd": "svd",
    "vnd.syncml+xml": "xsm",
    "vnd.syncml.dm+wbxml": "bdm",
    "vnd.syncml.dm+xml": "xdm",
    "vnd.tao.intent-module-archive": "tao",
    "vnd.tcpdump.pcap": [
      "pcap",
      "cap",
      "dmp"
    ],
    "vnd.tmobile-livetv": "tmo",
    "vnd.trid.tpt": "tpt",
    "vnd.triscape.mxs": "mxs",
    "vnd.trueapp": "tra",
    "vnd.ufdl": [
      "ufd",
      "ufdl"
    ],
    "vnd.uiq.theme": "utz",
    "vnd.umajin": "umj",
    "vnd.unity": "unityweb",
    "vnd.uoml+xml": "uoml",
    "vnd.vcx": "vcx",
    "vnd.visionary": "vis",
    "vnd.vsf": "vsf",
    "vnd.webturbo": "wtb",
    "vnd.wolfram.player": "nbp",
    "vnd.wqd": "wqd",
    "vnd.wt.stf": "stf",
    "vnd.xara": "xar",
    "vnd.xfdl": "xfdl",
    "vnd.yamaha.hv-dic": "hvd",
    "vnd.yamaha.hv-script": "hvs",
    "vnd.yamaha.hv-voice": "hvp",
    "vnd.yamaha.openscoreformat": "osf",
    "vnd.yamaha.openscoreformat.osfpvg+xml": "osfpvg",
    "vnd.yamaha.smaf-audio": "saf",
    "vnd.yamaha.smaf-phrase": "spf",
    "vnd.yellowriver-custom-menu": "cmp",
    "vnd.zul": [
      "zir",
      "zirz"
    ],
    "vnd.zzazz.deck+xml": "zaz",
    "voicexml+xml": "vxml",
    widget: "wgt",
    winhlp: "hlp",
    "wsdl+xml": "wsdl",
    "wspolicy+xml": "wspolicy",
    "x-ace-compressed": "ace",
    "x-authorware-bin": [
      "aab",
      "x32",
      "u32",
      "vox"
    ],
    "x-authorware-map": "aam",
    "x-authorware-seg": "aas",
    "x-blorb": [
      "blb",
      "blorb"
    ],
    "x-bzip": "bz",
    "x-bzip2": [
      "bz2",
      "boz"
    ],
    "x-cfs-compressed": "cfs",
    "x-chat": "chat",
    "x-conference": "nsc",
    "x-dgc-compressed": "dgc",
    "x-dtbncx+xml": "ncx",
    "x-dtbook+xml": "dtb",
    "x-dtbresource+xml": "res",
    "x-eva": "eva",
    "x-font-bdf": "bdf",
    "x-font-ghostscript": "gsf",
    "x-font-linux-psf": "psf",
    "x-font-pcf": "pcf",
    "x-font-snf": "snf",
    "x-font-ttf": [
      "ttf",
      "ttc"
    ],
    "x-font-type1": [
      "pfa",
      "pfb",
      "pfm",
      "afm"
    ],
    "x-freearc": "arc",
    "x-gca-compressed": "gca",
    "x-glulx": "ulx",
    "x-gramps-xml": "gramps",
    "x-install-instructions": "install",
    "x-lzh-compressed": [
      "lzh",
      "lha"
    ],
    "x-mie": "mie",
    "x-mobipocket-ebook": [
      "prc",
      "mobi"
    ],
    "x-ms-application": "application",
    "x-ms-shortcut": "lnk",
    "x-ms-xbap": "xbap",
    "x-msbinder": "obd",
    "x-mscardfile": "crd",
    "x-msclip": "clp",
    "application/x-ms-installer": "msi",
    "x-msmediaview": [
      "mvb",
      "m13",
      "m14"
    ],
    "x-msmetafile": [
      "wmf",
      "wmz",
      "emf",
      "emz"
    ],
    "x-msmoney": "mny",
    "x-mspublisher": "pub",
    "x-msschedule": "scd",
    "x-msterminal": "trm",
    "x-mswrite": "wri",
    "x-nzb": "nzb",
    "x-pkcs12": [
      "p12",
      "pfx"
    ],
    "x-pkcs7-certificates": [
      "p7b",
      "spc"
    ],
    "x-research-info-systems": "ris",
    "x-silverlight-app": "xap",
    "x-sql": "sql",
    "x-stuffitx": "sitx",
    "x-subrip": "srt",
    "x-t3vm-image": "t3",
    "x-tex-tfm": "tfm",
    "x-tgif": "obj",
    "x-xliff+xml": "xlf",
    "x-xz": "xz",
    "x-zmachine": [
      "z1",
      "z2",
      "z3",
      "z4",
      "z5",
      "z6",
      "z7",
      "z8"
    ],
    "xaml+xml": "xaml",
    "xcap-diff+xml": "xdf",
    "xenc+xml": "xenc",
    "xml-dtd": "dtd",
    "xop+xml": "xop",
    "xproc+xml": "xpl",
    "xslt+xml": "xslt",
    "xv+xml": [
      "mxml",
      "xhvml",
      "xvml",
      "xvm"
    ],
    yang: "yang",
    "yin+xml": "yin",
    envoy: "evy",
    fractals: "fif",
    "internet-property-stream": "acx",
    olescript: "axs",
    "vnd.ms-outlook": "msg",
    "vnd.ms-pkicertstore": "sst",
    "x-compress": "z",
    "x-perfmon": [
      "pma",
      "pmc",
      "pmr",
      "pmw"
    ],
    "ynd.ms-pkipko": "pko",
    gzip: [
      "gz",
      "tgz"
    ],
    "smil+xml": [
      "smi",
      "smil"
    ],
    "vnd.debian.binary-package": [
      "deb",
      "udeb"
    ],
    "vnd.hzn-3d-crossword": "x3d",
    "vnd.sqlite3": [
      "db",
      "sqlite",
      "sqlite3",
      "db-wal",
      "sqlite-wal",
      "db-shm",
      "sqlite-shm"
    ],
    "vnd.wap.sic": "sic",
    "vnd.wap.slc": "slc",
    "x-krita": [
      "kra",
      "krz"
    ],
    "x-perl": [
      "pm",
      "pl"
    ],
    yaml: [
      "yaml",
      "yml"
    ]
  },
  audio: {
    amr: "amr",
    "amr-wb": "awb",
    annodex: "axa",
    basic: [
      "au",
      "snd"
    ],
    flac: "flac",
    midi: [
      "mid",
      "midi",
      "kar",
      "rmi"
    ],
    mpeg: [
      "mpga",
      "mpega",
      "mp3",
      "m4a",
      "mp2a",
      "m2a",
      "m3a"
    ],
    mpegurl: "m3u",
    ogg: [
      "oga",
      "ogg",
      "spx"
    ],
    "prs.sid": "sid",
    "x-aiff": "aifc",
    "x-gsm": "gsm",
    "x-ms-wma": "wma",
    "x-ms-wax": "wax",
    "x-pn-realaudio": "ram",
    "x-realaudio": "ra",
    "x-sd2": "sd2",
    adpcm: "adp",
    mp4: "mp4a",
    s3m: "s3m",
    silk: "sil",
    "vnd.dece.audio": [
      "uva",
      "uvva"
    ],
    "vnd.digital-winds": "eol",
    "vnd.dra": "dra",
    "vnd.dts": "dts",
    "vnd.dts.hd": "dtshd",
    "vnd.lucent.voice": "lvp",
    "vnd.ms-playready.media.pya": "pya",
    "vnd.nuera.ecelp4800": "ecelp4800",
    "vnd.nuera.ecelp7470": "ecelp7470",
    "vnd.nuera.ecelp9600": "ecelp9600",
    "vnd.rip": "rip",
    webm: "weba",
    "x-caf": "caf",
    "x-matroska": "mka",
    "x-pn-realaudio-plugin": "rmp",
    xm: "xm",
    aac: "aac",
    aiff: [
      "aiff",
      "aif",
      "aff"
    ],
    opus: "opus",
    wav: "wav"
  },
  chemical: {
    "x-alchemy": "alc",
    "x-cache": [
      "cac",
      "cache"
    ],
    "x-cache-csf": "csf",
    "x-cactvs-binary": [
      "cbin",
      "cascii",
      "ctab"
    ],
    "x-cdx": "cdx",
    "x-chem3d": "c3d",
    "x-cif": "cif",
    "x-cmdf": "cmdf",
    "x-cml": "cml",
    "x-compass": "cpa",
    "x-crossfire": "bsd",
    "x-csml": [
      "csml",
      "csm"
    ],
    "x-ctx": "ctx",
    "x-cxf": [
      "cxf",
      "cef"
    ],
    "x-embl-dl-nucleotide": [
      "emb",
      "embl"
    ],
    "x-gamess-input": [
      "inp",
      "gam",
      "gamin"
    ],
    "x-gaussian-checkpoint": [
      "fch",
      "fchk"
    ],
    "x-gaussian-cube": "cub",
    "x-gaussian-input": [
      "gau",
      "gjc",
      "gjf"
    ],
    "x-gaussian-log": "gal",
    "x-gcg8-sequence": "gcg",
    "x-genbank": "gen",
    "x-hin": "hin",
    "x-isostar": [
      "istr",
      "ist"
    ],
    "x-jcamp-dx": [
      "jdx",
      "dx"
    ],
    "x-kinemage": "kin",
    "x-macmolecule": "mcm",
    "x-macromodel-input": "mmod",
    "x-mdl-molfile": "mol",
    "x-mdl-rdfile": "rd",
    "x-mdl-rxnfile": "rxn",
    "x-mdl-sdfile": "sd",
    "x-mdl-tgf": "tgf",
    "x-mmcif": "mcif",
    "x-mol2": "mol2",
    "x-molconn-Z": "b",
    "x-mopac-graph": "gpt",
    "x-mopac-input": [
      "mop",
      "mopcrt",
      "zmt"
    ],
    "x-mopac-out": "moo",
    "x-ncbi-asn1": "asn",
    "x-ncbi-asn1-ascii": [
      "prt",
      "ent"
    ],
    "x-ncbi-asn1-binary": "val",
    "x-rosdal": "ros",
    "x-swissprot": "sw",
    "x-vamas-iso14976": "vms",
    "x-vmd": "vmd",
    "x-xtel": "xtel",
    "x-xyz": "xyz"
  },
  font: {
    otf: "otf",
    woff: "woff",
    woff2: "woff2"
  },
  image: {
    gif: "gif",
    ief: "ief",
    jpeg: [
      "jpeg",
      "jpg",
      "jpe",
      "jfif",
      "jfif-tbnl",
      "jif"
    ],
    pcx: "pcx",
    png: "png",
    "svg+xml": [
      "svg",
      "svgz"
    ],
    tiff: [
      "tiff",
      "tif"
    ],
    "vnd.djvu": [
      "djvu",
      "djv"
    ],
    "vnd.wap.wbmp": "wbmp",
    "x-canon-cr2": "cr2",
    "x-canon-crw": "crw",
    "x-cmu-raster": "ras",
    "x-coreldraw": "cdr",
    "x-coreldrawpattern": "pat",
    "x-coreldrawtemplate": "cdt",
    "x-corelphotopaint": "cpt",
    "x-epson-erf": "erf",
    "x-icon": "ico",
    "x-jg": "art",
    "x-jng": "jng",
    "x-nikon-nef": "nef",
    "x-olympus-orf": "orf",
    "x-portable-anymap": "pnm",
    "x-portable-bitmap": "pbm",
    "x-portable-graymap": "pgm",
    "x-portable-pixmap": "ppm",
    "x-rgb": "rgb",
    "x-xbitmap": "xbm",
    "x-xpixmap": "xpm",
    "x-xwindowdump": "xwd",
    bmp: "bmp",
    cgm: "cgm",
    g3fax: "g3",
    ktx: "ktx",
    "prs.btif": "btif",
    sgi: "sgi",
    "vnd.dece.graphic": [
      "uvi",
      "uvvi",
      "uvg",
      "uvvg"
    ],
    "vnd.dwg": "dwg",
    "vnd.dxf": "dxf",
    "vnd.fastbidsheet": "fbs",
    "vnd.fpx": "fpx",
    "vnd.fst": "fst",
    "vnd.fujixerox.edmics-mmr": "mmr",
    "vnd.fujixerox.edmics-rlc": "rlc",
    "vnd.ms-modi": "mdi",
    "vnd.ms-photo": "wdp",
    "vnd.net-fpx": "npx",
    "vnd.xiff": "xif",
    webp: "webp",
    "x-3ds": "3ds",
    "x-cmx": "cmx",
    "x-freehand": [
      "fh",
      "fhc",
      "fh4",
      "fh5",
      "fh7"
    ],
    "x-pict": [
      "pic",
      "pct"
    ],
    "x-tga": "tga",
    "cis-cod": "cod",
    avif: "avifs",
    heic: [
      "heif",
      "heic"
    ],
    pjpeg: [
      "pjpg"
    ],
    "vnd.adobe.photoshop": "psd",
    "x-adobe-dng": "dng",
    "x-fuji-raf": "raf",
    "x-icns": "icns",
    "x-kodak-dcr": "dcr",
    "x-kodak-k25": "k25",
    "x-kodak-kdc": "kdc",
    "x-minolta-mrw": "mrw",
    "x-panasonic-raw": [
      "raw",
      "rw2",
      "rwl"
    ],
    "x-pentax-pef": [
      "pef",
      "ptx"
    ],
    "x-sigma-x3f": "x3f",
    "x-sony-arw": "arw",
    "x-sony-sr2": "sr2",
    "x-sony-srf": "srf"
  },
  message: {
    rfc822: [
      "eml",
      "mime",
      "mht",
      "mhtml",
      "nws"
    ]
  },
  model: {
    iges: [
      "igs",
      "iges"
    ],
    mesh: [
      "msh",
      "mesh",
      "silo"
    ],
    vrml: [
      "wrl",
      "vrml"
    ],
    "x3d+vrml": [
      "x3dv",
      "x3dvz"
    ],
    "x3d+xml": "x3dz",
    "x3d+binary": [
      "x3db",
      "x3dbz"
    ],
    "vnd.collada+xml": "dae",
    "vnd.dwf": "dwf",
    "vnd.gdl": "gdl",
    "vnd.gtw": "gtw",
    "vnd.mts": "mts",
    "vnd.usdz+zip": "usdz",
    "vnd.vtu": "vtu"
  },
  text: {
    "cache-manifest": [
      "manifest",
      "appcache"
    ],
    calendar: [
      "ics",
      "icz",
      "ifb"
    ],
    css: "css",
    csv: "csv",
    h323: "323",
    html: [
      "html",
      "htm",
      "shtml",
      "stm"
    ],
    iuls: "uls",
    plain: [
      "txt",
      "text",
      "brf",
      "conf",
      "def",
      "list",
      "log",
      "in",
      "bas",
      "diff",
      "ksh"
    ],
    richtext: "rtx",
    scriptlet: [
      "sct",
      "wsc"
    ],
    texmacs: "tm",
    "tab-separated-values": "tsv",
    "vnd.sun.j2me.app-descriptor": "jad",
    "vnd.wap.wml": "wml",
    "vnd.wap.wmlscript": "wmls",
    "x-bibtex": "bib",
    "x-boo": "boo",
    "x-c++hdr": [
      "h++",
      "hpp",
      "hxx",
      "hh"
    ],
    "x-c++src": [
      "c++",
      "cpp",
      "cxx",
      "cc"
    ],
    "x-component": "htc",
    "x-dsrc": "d",
    "x-diff": "patch",
    "x-haskell": "hs",
    "x-java": "java",
    "x-literate-haskell": "lhs",
    "x-moc": "moc",
    "x-pascal": [
      "p",
      "pas",
      "pp",
      "inc"
    ],
    "x-pcs-gcd": "gcd",
    "x-python": "py",
    "x-scala": "scala",
    "x-setext": "etx",
    "x-tcl": [
      "tcl",
      "tk"
    ],
    "x-tex": [
      "tex",
      "ltx",
      "sty",
      "cls"
    ],
    "x-vcalendar": "vcs",
    "x-vcard": "vcf",
    n3: "n3",
    "prs.lines.tag": "dsc",
    sgml: [
      "sgml",
      "sgm"
    ],
    troff: [
      "t",
      "tr",
      "roff",
      "man",
      "me",
      "ms"
    ],
    turtle: "ttl",
    "uri-list": [
      "uri",
      "uris",
      "urls"
    ],
    vcard: "vcard",
    "vnd.curl": "curl",
    "vnd.curl.dcurl": "dcurl",
    "vnd.curl.scurl": "scurl",
    "vnd.curl.mcurl": "mcurl",
    "vnd.dvb.subtitle": "sub",
    "vnd.fly": "fly",
    "vnd.fmi.flexstor": "flx",
    "vnd.graphviz": "gv",
    "vnd.in3d.3dml": "3dml",
    "vnd.in3d.spot": "spot",
    "x-asm": [
      "s",
      "asm"
    ],
    "x-c": [
      "c",
      "h",
      "dic"
    ],
    "x-fortran": [
      "f",
      "for",
      "f77",
      "f90"
    ],
    "x-opml": "opml",
    "x-nfo": "nfo",
    "x-sfv": "sfv",
    "x-uuencode": "uu",
    webviewhtml: "htt",
    javascript: "js",
    json: "json",
    markdown: [
      "md",
      "markdown",
      "mdown",
      "markdn"
    ],
    "vnd.wap.si": "si",
    "vnd.wap.sl": "sl"
  },
  video: {
    avif: "avif",
    "3gpp": "3gp",
    annodex: "axv",
    dl: "dl",
    dv: [
      "dif",
      "dv"
    ],
    fli: "fli",
    gl: "gl",
    mpeg: [
      "mpeg",
      "mpg",
      "mpe",
      "m1v",
      "m2v",
      "mp2",
      "mpa",
      "mpv2"
    ],
    mp4: [
      "mp4",
      "mp4v",
      "mpg4"
    ],
    quicktime: [
      "qt",
      "mov"
    ],
    ogg: "ogv",
    "vnd.mpegurl": [
      "mxu",
      "m4u"
    ],
    "x-flv": "flv",
    "x-la-asf": [
      "lsf",
      "lsx"
    ],
    "x-mng": "mng",
    "x-ms-asf": [
      "asf",
      "asx",
      "asr"
    ],
    "x-ms-wm": "wm",
    "x-ms-wmv": "wmv",
    "x-ms-wmx": "wmx",
    "x-ms-wvx": "wvx",
    "x-msvideo": "avi",
    "x-sgi-movie": "movie",
    "x-matroska": [
      "mpv",
      "mkv",
      "mk3d",
      "mks"
    ],
    "3gpp2": "3g2",
    h261: "h261",
    h263: "h263",
    h264: "h264",
    jpeg: "jpgv",
    jpm: [
      "jpm",
      "jpgm"
    ],
    mj2: [
      "mj2",
      "mjp2"
    ],
    "vnd.dece.hd": [
      "uvh",
      "uvvh"
    ],
    "vnd.dece.mobile": [
      "uvm",
      "uvvm"
    ],
    "vnd.dece.pd": [
      "uvp",
      "uvvp"
    ],
    "vnd.dece.sd": [
      "uvs",
      "uvvs"
    ],
    "vnd.dece.video": [
      "uvv",
      "uvvv"
    ],
    "vnd.dvb.file": "dvb",
    "vnd.fvt": "fvt",
    "vnd.ms-playready.media.pyv": "pyv",
    "vnd.uvvu.mp4": [
      "uvu",
      "uvvu"
    ],
    "vnd.vivo": "viv",
    webm: "webm",
    "x-f4v": "f4v",
    "x-m4v": "m4v",
    "x-ms-vob": "vob",
    "x-smv": "smv",
    mp2t: "ts"
  },
  "x-conference": {
    "x-cooltalk": "ice"
  },
  "x-world": {
    "x-vrml": [
      "vrm",
      "flr",
      "wrz",
      "xaf",
      "xof"
    ]
  }
};
(() => {
  const n = {};
  for (const t of Object.keys(pn))
    for (const e of Object.keys(pn[t])) {
      const r = pn[t][e];
      if (typeof r == "string")
        n[r] = t + "/" + e;
      else
        for (let a = 0; a < r.length; a++)
          n[r[a]] = t + "/" + e;
    }
  return n;
})();
const Jr = [];
for (let n = 0; n < 256; n++) {
  let t = n;
  for (let e = 0; e < 8; e++)
    t & 1 ? t = t >>> 1 ^ 3988292384 : t = t >>> 1;
  Jr[n] = t;
}
class Zt {
  constructor(t) {
    this.crc = t || -1;
  }
  append(t) {
    let e = this.crc | 0;
    for (let r = 0, a = t.length | 0; r < a; r++)
      e = e >>> 8 ^ Jr[(e ^ t[r]) & 255];
    this.crc = e;
  }
  get() {
    return ~this.crc;
  }
}
class zr extends TransformStream {
  constructor() {
    let t;
    const e = new Zt();
    super({
      transform(r, a) {
        e.append(r), a.enqueue(r);
      },
      flush() {
        const r = new Uint8Array(4);
        new DataView(r.buffer).setUint32(0, e.get()), t.value = r;
      }
    }), t = this;
  }
}
function oa(n) {
  if (typeof TextEncoder == $e) {
    n = unescape(encodeURIComponent(n));
    const t = new Uint8Array(n.length);
    for (let e = 0; e < t.length; e++)
      t[e] = n.charCodeAt(e);
    return t;
  } else
    return new TextEncoder().encode(n);
}
const ye = {
  /**
   * Concatenate two bit arrays.
   * @param {bitArray} a1 The first array.
   * @param {bitArray} a2 The second array.
   * @return {bitArray} The concatenation of a1 and a2.
   */
  concat(n, t) {
    if (n.length === 0 || t.length === 0)
      return n.concat(t);
    const e = n[n.length - 1], r = ye.getPartial(e);
    return r === 32 ? n.concat(t) : ye._shiftRight(t, r, e | 0, n.slice(0, n.length - 1));
  },
  /**
   * Find the length of an array of bits.
   * @param {bitArray} a The array.
   * @return {Number} The length of a, in bits.
   */
  bitLength(n) {
    const t = n.length;
    if (t === 0)
      return 0;
    const e = n[t - 1];
    return (t - 1) * 32 + ye.getPartial(e);
  },
  /**
   * Truncate an array.
   * @param {bitArray} a The array.
   * @param {Number} len The length to truncate to, in bits.
   * @return {bitArray} A new array, truncated to len bits.
   */
  clamp(n, t) {
    if (n.length * 32 < t)
      return n;
    n = n.slice(0, Math.ceil(t / 32));
    const e = n.length;
    return t = t & 31, e > 0 && t && (n[e - 1] = ye.partial(t, n[e - 1] & 2147483648 >> t - 1, 1)), n;
  },
  /**
   * Make a partial word for a bit array.
   * @param {Number} len The number of bits in the word.
   * @param {Number} x The bits.
   * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.
   * @return {Number} The partial word.
   */
  partial(n, t, e) {
    return n === 32 ? t : (e ? t | 0 : t << 32 - n) + n * 1099511627776;
  },
  /**
   * Get the number of bits used by a partial word.
   * @param {Number} x The partial word.
   * @return {Number} The number of bits used by the partial word.
   */
  getPartial(n) {
    return Math.round(n / 1099511627776) || 32;
  },
  /** Shift an array right.
   * @param {bitArray} a The array to shift.
   * @param {Number} shift The number of bits to shift.
   * @param {Number} [carry=0] A byte to carry in
   * @param {bitArray} [out=[]] An array to prepend to the output.
   * @private
   */
  _shiftRight(n, t, e, r) {
    for (r === void 0 && (r = []); t >= 32; t -= 32)
      r.push(e), e = 0;
    if (t === 0)
      return r.concat(n);
    for (let c = 0; c < n.length; c++)
      r.push(e | n[c] >>> t), e = n[c] << 32 - t;
    const a = n.length ? n[n.length - 1] : 0, o = ye.getPartial(a);
    return r.push(ye.partial(t + o & 31, t + o > 32 ? e : r.pop(), 1)), r;
  }
}, Kt = {
  bytes: {
    /** Convert from a bitArray to an array of bytes. */
    fromBits(n) {
      const e = ye.bitLength(n) / 8, r = new Uint8Array(e);
      let a;
      for (let o = 0; o < e; o++)
        o & 3 || (a = n[o / 4]), r[o] = a >>> 24, a <<= 8;
      return r;
    },
    /** Convert from an array of bytes to a bitArray. */
    toBits(n) {
      const t = [];
      let e, r = 0;
      for (e = 0; e < n.length; e++)
        r = r << 8 | n[e], (e & 3) === 3 && (t.push(r), r = 0);
      return e & 3 && t.push(ye.partial(8 * (e & 3), r)), t;
    }
  }
}, Qr = {};
Qr.sha1 = class {
  constructor(n) {
    const t = this;
    t.blockSize = 512, t._init = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], t._key = [1518500249, 1859775393, 2400959708, 3395469782], n ? (t._h = n._h.slice(0), t._buffer = n._buffer.slice(0), t._length = n._length) : t.reset();
  }
  /**
   * Reset the hash state.
   * @return this
   */
  reset() {
    const n = this;
    return n._h = n._init.slice(0), n._buffer = [], n._length = 0, n;
  }
  /**
   * Input several words to the hash.
   * @param {bitArray|String} data the data to hash.
   * @return this
   */
  update(n) {
    const t = this;
    typeof n == "string" && (n = Kt.utf8String.toBits(n));
    const e = t._buffer = ye.concat(t._buffer, n), r = t._length, a = t._length = r + ye.bitLength(n);
    if (a > 9007199254740991)
      throw new Error("Cannot hash more than 2^53 - 1 bits");
    const o = new Uint32Array(e);
    let c = 0;
    for (let l = t.blockSize + r - (t.blockSize + r & t.blockSize - 1); l <= a; l += t.blockSize)
      t._block(o.subarray(16 * c, 16 * (c + 1))), c += 1;
    return e.splice(0, 16 * c), t;
  }
  /**
   * Complete hashing and output the hash value.
   * @return {bitArray} The hash value, an array of 5 big-endian words. TODO
   */
  finalize() {
    const n = this;
    let t = n._buffer;
    const e = n._h;
    t = ye.concat(t, [ye.partial(1, 1)]);
    for (let r = t.length + 2; r & 15; r++)
      t.push(0);
    for (t.push(Math.floor(n._length / 4294967296)), t.push(n._length | 0); t.length; )
      n._block(t.splice(0, 16));
    return n.reset(), e;
  }
  /**
   * The SHA-1 logical functions f(0), f(1), ..., f(79).
   * @private
   */
  _f(n, t, e, r) {
    if (n <= 19)
      return t & e | ~t & r;
    if (n <= 39)
      return t ^ e ^ r;
    if (n <= 59)
      return t & e | t & r | e & r;
    if (n <= 79)
      return t ^ e ^ r;
  }
  /**
   * Circular left-shift operator.
   * @private
   */
  _S(n, t) {
    return t << n | t >>> 32 - n;
  }
  /**
   * Perform one cycle of SHA-1.
   * @param {Uint32Array|bitArray} words one block of words.
   * @private
   */
  _block(n) {
    const t = this, e = t._h, r = Array(80);
    for (let g = 0; g < 16; g++)
      r[g] = n[g];
    let a = e[0], o = e[1], c = e[2], l = e[3], u = e[4];
    for (let g = 0; g <= 79; g++) {
      g >= 16 && (r[g] = t._S(1, r[g - 3] ^ r[g - 8] ^ r[g - 14] ^ r[g - 16]));
      const x = t._S(5, a) + t._f(g, o, c, l) + u + r[g] + t._key[Math.floor(g / 20)] | 0;
      u = l, l = c, c = t._S(30, o), o = a, a = x;
    }
    e[0] = e[0] + a | 0, e[1] = e[1] + o | 0, e[2] = e[2] + c | 0, e[3] = e[3] + l | 0, e[4] = e[4] + u | 0;
  }
};
const ei = {};
ei.aes = class {
  constructor(n) {
    const t = this;
    t._tables = [[[], [], [], [], []], [[], [], [], [], []]], t._tables[0][0][0] || t._precompute();
    const e = t._tables[0][4], r = t._tables[1], a = n.length;
    let o, c, l, u = 1;
    if (a !== 4 && a !== 6 && a !== 8)
      throw new Error("invalid aes key size");
    for (t._key = [c = n.slice(0), l = []], o = a; o < 4 * a + 28; o++) {
      let g = c[o - 1];
      (o % a === 0 || a === 8 && o % a === 4) && (g = e[g >>> 24] << 24 ^ e[g >> 16 & 255] << 16 ^ e[g >> 8 & 255] << 8 ^ e[g & 255], o % a === 0 && (g = g << 8 ^ g >>> 24 ^ u << 24, u = u << 1 ^ (u >> 7) * 283)), c[o] = c[o - a] ^ g;
    }
    for (let g = 0; o; g++, o--) {
      const x = c[g & 3 ? o : o - 4];
      o <= 4 || g < 4 ? l[g] = x : l[g] = r[0][e[x >>> 24]] ^ r[1][e[x >> 16 & 255]] ^ r[2][e[x >> 8 & 255]] ^ r[3][e[x & 255]];
    }
  }
  // public
  /* Something like this might appear here eventually
  name: "AES",
  blockSize: 4,
  keySizes: [4,6,8],
  */
  /**
   * Encrypt an array of 4 big-endian words.
   * @param {Array} data The plaintext.
   * @return {Array} The ciphertext.
   */
  encrypt(n) {
    return this._crypt(n, 0);
  }
  /**
   * Decrypt an array of 4 big-endian words.
   * @param {Array} data The ciphertext.
   * @return {Array} The plaintext.
   */
  decrypt(n) {
    return this._crypt(n, 1);
  }
  /**
   * Expand the S-box tables.
   *
   * @private
   */
  _precompute() {
    const n = this._tables[0], t = this._tables[1], e = n[4], r = t[4], a = [], o = [];
    let c, l, u, g;
    for (let x = 0; x < 256; x++)
      o[(a[x] = x << 1 ^ (x >> 7) * 283) ^ x] = x;
    for (let x = c = 0; !e[x]; x ^= l || 1, c = o[c] || 1) {
      let w = c ^ c << 1 ^ c << 2 ^ c << 3 ^ c << 4;
      w = w >> 8 ^ w & 255 ^ 99, e[x] = w, r[w] = x, g = a[u = a[l = a[x]]];
      let _ = g * 16843009 ^ u * 65537 ^ l * 257 ^ x * 16843008, A = a[w] * 257 ^ w * 16843008;
      for (let P = 0; P < 4; P++)
        n[P][x] = A = A << 24 ^ A >>> 8, t[P][w] = _ = _ << 24 ^ _ >>> 8;
    }
    for (let x = 0; x < 5; x++)
      n[x] = n[x].slice(0), t[x] = t[x].slice(0);
  }
  /**
   * Encryption and decryption core.
   * @param {Array} input Four words to be encrypted or decrypted.
   * @param dir The direction, 0 for encrypt and 1 for decrypt.
   * @return {Array} The four encrypted or decrypted words.
   * @private
   */
  _crypt(n, t) {
    if (n.length !== 4)
      throw new Error("invalid aes block size");
    const e = this._key[t], r = e.length / 4 - 2, a = [0, 0, 0, 0], o = this._tables[t], c = o[0], l = o[1], u = o[2], g = o[3], x = o[4];
    let w = n[0] ^ e[0], _ = n[t ? 3 : 1] ^ e[1], A = n[2] ^ e[2], P = n[t ? 1 : 3] ^ e[3], h = 4, p, m, E;
    for (let R = 0; R < r; R++)
      p = c[w >>> 24] ^ l[_ >> 16 & 255] ^ u[A >> 8 & 255] ^ g[P & 255] ^ e[h], m = c[_ >>> 24] ^ l[A >> 16 & 255] ^ u[P >> 8 & 255] ^ g[w & 255] ^ e[h + 1], E = c[A >>> 24] ^ l[P >> 16 & 255] ^ u[w >> 8 & 255] ^ g[_ & 255] ^ e[h + 2], P = c[P >>> 24] ^ l[w >> 16 & 255] ^ u[_ >> 8 & 255] ^ g[A & 255] ^ e[h + 3], h += 4, w = p, _ = m, A = E;
    for (let R = 0; R < 4; R++)
      a[t ? 3 & -R : R] = x[w >>> 24] << 24 ^ x[_ >> 16 & 255] << 16 ^ x[A >> 8 & 255] << 8 ^ x[P & 255] ^ e[h++], p = w, w = _, _ = A, A = P, P = p;
    return a;
  }
};
const ca = {
  /** 
   * Generate random words with pure js, cryptographically not as strong & safe as native implementation.
   * @param {TypedArray} typedArray The array to fill.
   * @return {TypedArray} The random values.
   */
  getRandomValues(n) {
    const t = new Uint32Array(n.buffer), e = (r) => {
      let a = 987654321;
      const o = 4294967295;
      return function() {
        return a = 36969 * (a & 65535) + (a >> 16) & o, r = 18e3 * (r & 65535) + (r >> 16) & o, (((a << 16) + r & o) / 4294967296 + 0.5) * (Math.random() > 0.5 ? 1 : -1);
      };
    };
    for (let r = 0, a; r < n.length; r += 4) {
      const o = e((a || Math.random()) * 4294967296);
      a = o() * 987654071, t[r / 4] = o() * 4294967296 | 0;
    }
    return n;
  }
}, ti = {};
ti.ctrGladman = class {
  constructor(n, t) {
    this._prf = n, this._initIv = t, this._iv = t;
  }
  reset() {
    this._iv = this._initIv;
  }
  /** Input some data to calculate.
   * @param {bitArray} data the data to process, it must be intergral multiple of 128 bits unless it's the last.
   */
  update(n) {
    return this.calculate(this._prf, n, this._iv);
  }
  incWord(n) {
    if ((n >> 24 & 255) === 255) {
      let t = n >> 16 & 255, e = n >> 8 & 255, r = n & 255;
      t === 255 ? (t = 0, e === 255 ? (e = 0, r === 255 ? r = 0 : ++r) : ++e) : ++t, n = 0, n += t << 16, n += e << 8, n += r;
    } else
      n += 1 << 24;
    return n;
  }
  incCounter(n) {
    (n[0] = this.incWord(n[0])) === 0 && (n[1] = this.incWord(n[1]));
  }
  calculate(n, t, e) {
    let r;
    if (!(r = t.length))
      return [];
    const a = ye.bitLength(t);
    for (let o = 0; o < r; o += 4) {
      this.incCounter(e);
      const c = n.encrypt(e);
      t[o] ^= c[0], t[o + 1] ^= c[1], t[o + 2] ^= c[2], t[o + 3] ^= c[3];
    }
    return ye.clamp(t, a);
  }
};
const rt = {
  importKey(n) {
    return new rt.hmacSha1(Kt.bytes.toBits(n));
  },
  pbkdf2(n, t, e, r) {
    if (e = e || 1e4, r < 0 || e < 0)
      throw new Error("invalid params to pbkdf2");
    const a = (r >> 5) + 1 << 2;
    let o, c, l, u, g;
    const x = new ArrayBuffer(a), w = new DataView(x);
    let _ = 0;
    const A = ye;
    for (t = Kt.bytes.toBits(t), g = 1; _ < (a || 1); g++) {
      for (o = c = n.encrypt(A.concat(t, [g])), l = 1; l < e; l++)
        for (c = n.encrypt(c), u = 0; u < c.length; u++)
          o[u] ^= c[u];
      for (l = 0; _ < (a || 1) && l < o.length; l++)
        w.setInt32(_, o[l]), _ += 4;
    }
    return x.slice(0, r / 8);
  }
};
rt.hmacSha1 = class {
  constructor(n) {
    const t = this, e = t._hash = Qr.sha1, r = [[], []];
    t._baseHash = [new e(), new e()];
    const a = t._baseHash[0].blockSize / 32;
    n.length > a && (n = new e().update(n).finalize());
    for (let o = 0; o < a; o++)
      r[0][o] = n[o] ^ 909522486, r[1][o] = n[o] ^ 1549556828;
    t._baseHash[0].update(r[0]), t._baseHash[1].update(r[1]), t._resultHash = new e(t._baseHash[0]);
  }
  reset() {
    const n = this;
    n._resultHash = new n._hash(n._baseHash[0]), n._updated = !1;
  }
  update(n) {
    const t = this;
    t._updated = !0, t._resultHash.update(n);
  }
  digest() {
    const n = this, t = n._resultHash.finalize(), e = new n._hash(n._baseHash[1]).update(t).finalize();
    return n.reset(), e;
  }
  encrypt(n) {
    if (this._updated)
      throw new Error("encrypt on already updated hmac called!");
    return this.update(n), this.digest(n);
  }
};
const la = typeof crypto != $e && typeof crypto.getRandomValues == kt, ni = "Invalid password", ri = "Invalid signature", Ln = "zipjs-abort-check-password";
function ii(n) {
  return la ? crypto.getRandomValues(n) : ca.getRandomValues(n);
}
const ft = 16, fa = "raw", si = { name: "PBKDF2" }, ua = { name: "HMAC" }, da = "SHA-1", pa = Object.assign({ hash: ua }, si), vn = Object.assign({ iterations: 1e3, hash: { name: da } }, si), ma = ["deriveBits"], yt = [8, 12, 16], gt = [16, 24, 32], Ze = 10, ha = [0, 0, 0, 0], en = typeof crypto != $e, St = en && crypto.subtle, ai = en && typeof St != $e, Be = Kt.bytes, xa = ei.aes, wa = ti.ctrGladman, _a = rt.hmacSha1;
let vr = en && ai && typeof St.importKey == kt, Er = en && ai && typeof St.deriveBits == kt;
class ga extends TransformStream {
  constructor({ password: t, rawPassword: e, signed: r, encryptionStrength: a, checkPasswordOnly: o }) {
    super({
      start() {
        Object.assign(this, {
          ready: new Promise((c) => this.resolveReady = c),
          password: li(t, e),
          signed: r,
          strength: a - 1,
          pending: new Uint8Array()
        });
      },
      async transform(c, l) {
        const u = this, {
          password: g,
          strength: x,
          resolveReady: w,
          ready: _
        } = u;
        g ? (await ya(u, x, g, Re(c, 0, yt[x] + 2)), c = Re(c, yt[x] + 2), o ? l.error(new Error(Ln)) : w()) : await _;
        const A = new Uint8Array(c.length - Ze - (c.length - Ze) % ft);
        l.enqueue(oi(u, c, A, 0, Ze, !0));
      },
      async flush(c) {
        const {
          signed: l,
          ctr: u,
          hmac: g,
          pending: x,
          ready: w
        } = this;
        if (g && u) {
          await w;
          const _ = Re(x, 0, x.length - Ze), A = Re(x, x.length - Ze);
          let P = new Uint8Array();
          if (_.length) {
            const h = Et(Be, _);
            g.update(h);
            const p = u.update(h);
            P = vt(Be, p);
          }
          if (l) {
            const h = Re(vt(Be, g.digest()), 0, Ze);
            for (let p = 0; p < Ze; p++)
              if (h[p] != A[p])
                throw new Error(ri);
          }
          c.enqueue(P);
        }
      }
    });
  }
}
class ba extends TransformStream {
  constructor({ password: t, rawPassword: e, encryptionStrength: r }) {
    let a;
    super({
      start() {
        Object.assign(this, {
          ready: new Promise((o) => this.resolveReady = o),
          password: li(t, e),
          strength: r - 1,
          pending: new Uint8Array()
        });
      },
      async transform(o, c) {
        const l = this, {
          password: u,
          strength: g,
          resolveReady: x,
          ready: w
        } = l;
        let _ = new Uint8Array();
        u ? (_ = await va(l, g, u), x()) : await w;
        const A = new Uint8Array(_.length + o.length - o.length % ft);
        A.set(_, 0), c.enqueue(oi(l, o, A, _.length, 0));
      },
      async flush(o) {
        const {
          ctr: c,
          hmac: l,
          pending: u,
          ready: g
        } = this;
        if (l && c) {
          await g;
          let x = new Uint8Array();
          if (u.length) {
            const w = c.update(Et(Be, u));
            l.update(w), x = vt(Be, w);
          }
          a.signature = vt(Be, l.digest()).slice(0, Ze), o.enqueue(Un(x, a.signature));
        }
      }
    }), a = this;
  }
}
function oi(n, t, e, r, a, o) {
  const {
    ctr: c,
    hmac: l,
    pending: u
  } = n, g = t.length - a;
  u.length && (t = Un(u, t), e = Sa(e, g - g % ft));
  let x;
  for (x = 0; x <= g - ft; x += ft) {
    const w = Et(Be, Re(t, x, x + ft));
    o && l.update(w);
    const _ = c.update(w);
    o || l.update(_), e.set(vt(Be, _), x + r);
  }
  return n.pending = Re(t, x), e;
}
async function ya(n, t, e, r) {
  const a = await ci(n, t, e, Re(r, 0, yt[t])), o = Re(r, yt[t]);
  if (a[0] != o[0] || a[1] != o[1])
    throw new Error(ni);
}
async function va(n, t, e) {
  const r = ii(new Uint8Array(yt[t])), a = await ci(n, t, e, r);
  return Un(r, a);
}
async function ci(n, t, e, r) {
  n.password = null;
  const a = await Ea(fa, e, pa, !1, ma), o = await ka(Object.assign({ salt: r }, vn), a, 8 * (gt[t] * 2 + 2)), c = new Uint8Array(o), l = Et(Be, Re(c, 0, gt[t])), u = Et(Be, Re(c, gt[t], gt[t] * 2)), g = Re(c, gt[t] * 2);
  return Object.assign(n, {
    keys: {
      key: l,
      authentication: u,
      passwordVerification: g
    },
    ctr: new wa(new xa(l), Array.from(ha)),
    hmac: new _a(u)
  }), g;
}
async function Ea(n, t, e, r, a) {
  if (vr)
    try {
      return await St.importKey(n, t, e, r, a);
    } catch {
      return vr = !1, rt.importKey(t);
    }
  else
    return rt.importKey(t);
}
async function ka(n, t, e) {
  if (Er)
    try {
      return await St.deriveBits(n, t, e);
    } catch {
      return Er = !1, rt.pbkdf2(t, n.salt, vn.iterations, e);
    }
  else
    return rt.pbkdf2(t, n.salt, vn.iterations, e);
}
function li(n, t) {
  return t === ve ? oa(n) : t;
}
function Un(n, t) {
  let e = n;
  return n.length + t.length && (e = new Uint8Array(n.length + t.length), e.set(n, 0), e.set(t, n.length)), e;
}
function Sa(n, t) {
  if (t && t > n.length) {
    const e = n;
    n = new Uint8Array(t), n.set(e, 0);
  }
  return n;
}
function Re(n, t, e) {
  return n.subarray(t, e);
}
function vt(n, t) {
  return n.fromBits(t);
}
function Et(n, t) {
  return n.toBits(t);
}
const ut = 12;
class Aa extends TransformStream {
  constructor({ password: t, passwordVerification: e, checkPasswordOnly: r }) {
    super({
      start() {
        Object.assign(this, {
          password: t,
          passwordVerification: e
        }), fi(this, t);
      },
      transform(a, o) {
        const c = this;
        if (c.password) {
          const l = kr(c, a.subarray(0, ut));
          if (c.password = null, l[ut - 1] != c.passwordVerification)
            throw new Error(ni);
          a = a.subarray(ut);
        }
        r ? o.error(new Error(Ln)) : o.enqueue(kr(c, a));
      }
    });
  }
}
class Ta extends TransformStream {
  constructor({ password: t, passwordVerification: e }) {
    super({
      start() {
        Object.assign(this, {
          password: t,
          passwordVerification: e
        }), fi(this, t);
      },
      transform(r, a) {
        const o = this;
        let c, l;
        if (o.password) {
          o.password = null;
          const u = ii(new Uint8Array(ut));
          u[ut - 1] = o.passwordVerification, c = new Uint8Array(r.length + u.length), c.set(Sr(o, u), 0), l = ut;
        } else
          c = new Uint8Array(r.length), l = 0;
        c.set(Sr(o, r), l), a.enqueue(c);
      }
    });
  }
}
function kr(n, t) {
  const e = new Uint8Array(t.length);
  for (let r = 0; r < t.length; r++)
    e[r] = ui(n) ^ t[r], On(n, e[r]);
  return e;
}
function Sr(n, t) {
  const e = new Uint8Array(t.length);
  for (let r = 0; r < t.length; r++)
    e[r] = ui(n) ^ t[r], On(n, t[r]);
  return e;
}
function fi(n, t) {
  const e = [305419896, 591751049, 878082192];
  Object.assign(n, {
    keys: e,
    crcKey0: new Zt(e[0]),
    crcKey2: new Zt(e[2])
  });
  for (let r = 0; r < t.length; r++)
    On(n, t.charCodeAt(r));
}
function On(n, t) {
  let [e, r, a] = n.keys;
  n.crcKey0.append([t]), e = ~n.crcKey0.get(), r = Ar(Math.imul(Ar(r + di(e)), 134775813) + 1), n.crcKey2.append([r >>> 24]), a = ~n.crcKey2.get(), n.keys = [e, r, a];
}
function ui(n) {
  const t = n.keys[2] | 2;
  return di(Math.imul(t, t ^ 1) >>> 8);
}
function di(n) {
  return n & 255;
}
function Ar(n) {
  return n & 4294967295;
}
const Tr = "deflate-raw";
class Fa extends TransformStream {
  constructor(t, { chunkSize: e, CompressionStream: r, CompressionStreamNative: a }) {
    super({});
    const { compressed: o, encrypted: c, useCompressionStream: l, zipCrypto: u, signed: g, level: x } = t, w = this;
    let _, A, P = pi(super.readable);
    (!c || u) && g && (_ = new zr(), P = Ne(P, _)), o && (P = hi(P, l, { level: x, chunkSize: e }, a, r)), c && (u ? P = Ne(P, new Ta(t)) : (A = new ba(t), P = Ne(P, A))), mi(w, P, () => {
      let h;
      c && !u && (h = A.signature), (!c || u) && g && (h = new DataView(_.value.buffer).getUint32(0)), w.signature = h;
    });
  }
}
class Ra extends TransformStream {
  constructor(t, { chunkSize: e, DecompressionStream: r, DecompressionStreamNative: a }) {
    super({});
    const { zipCrypto: o, encrypted: c, signed: l, signature: u, compressed: g, useCompressionStream: x } = t;
    let w, _, A = pi(super.readable);
    c && (o ? A = Ne(A, new Aa(t)) : (_ = new ga(t), A = Ne(A, _))), g && (A = hi(A, x, { chunkSize: e }, a, r)), (!c || o) && l && (w = new zr(), A = Ne(A, w)), mi(this, A, () => {
      if ((!c || o) && l) {
        const P = new DataView(w.value.buffer);
        if (u != P.getUint32(0, !1))
          throw new Error(ri);
      }
    });
  }
}
function pi(n) {
  return Ne(n, new TransformStream({
    transform(t, e) {
      t && t.length && e.enqueue(t);
    }
  }));
}
function mi(n, t, e) {
  t = Ne(t, new TransformStream({ flush: e })), Object.defineProperty(n, "readable", {
    get() {
      return t;
    }
  });
}
function hi(n, t, e, r, a) {
  try {
    const o = t && r ? r : a;
    n = Ne(n, new o(Tr, e));
  } catch {
    if (t)
      try {
        n = Ne(n, new a(Tr, e));
      } catch {
        return n;
      }
    else
      return n;
  }
  return n;
}
function Ne(n, t) {
  return n.pipeThrough(t);
}
const Ca = "message", Ia = "start", Da = "pull", Fr = "data", La = "ack", Rr = "close", Ua = "deflate", xi = "inflate";
class Oa extends TransformStream {
  constructor(t, e) {
    super({});
    const r = this, { codecType: a } = t;
    let o;
    a.startsWith(Ua) ? o = Fa : a.startsWith(xi) && (o = Ra);
    let c = 0, l = 0;
    const u = new o(t, e), g = super.readable, x = new TransformStream({
      transform(_, A) {
        _ && _.length && (l += _.length, A.enqueue(_));
      },
      flush() {
        Object.assign(r, {
          inputSize: l
        });
      }
    }), w = new TransformStream({
      transform(_, A) {
        _ && _.length && (c += _.length, A.enqueue(_));
      },
      flush() {
        const { signature: _ } = u;
        Object.assign(r, {
          signature: _,
          outputSize: c,
          inputSize: l
        });
      }
    });
    Object.defineProperty(r, "readable", {
      get() {
        return g.pipeThrough(x).pipeThrough(u).pipeThrough(w);
      }
    });
  }
}
class Pa extends TransformStream {
  constructor(t) {
    let e;
    super({
      transform: r,
      flush(a) {
        e && e.length && a.enqueue(e);
      }
    });
    function r(a, o) {
      if (e) {
        const c = new Uint8Array(e.length + a.length);
        c.set(e), c.set(a, e.length), a = c, e = null;
      }
      a.length > t ? (o.enqueue(a.slice(0, t)), r(a.slice(t), o)) : e = a;
    }
  }
}
let wi = typeof Worker != $e;
class mn {
  constructor(t, { readable: e, writable: r }, { options: a, config: o, streamOptions: c, useWebWorkers: l, transferStreams: u, scripts: g }, x) {
    const { signal: w } = c;
    return Object.assign(t, {
      busy: !0,
      readable: e.pipeThrough(new Pa(o.chunkSize)).pipeThrough(new Ba(e, c), { signal: w }),
      writable: r,
      options: Object.assign({}, a),
      scripts: g,
      transferStreams: u,
      terminate() {
        return new Promise((_) => {
          const { worker: A, busy: P } = t;
          A ? (P ? t.resolveTerminated = _ : (A.terminate(), _()), t.interface = null) : _();
        });
      },
      onTaskFinished() {
        const { resolveTerminated: _ } = t;
        _ && (t.resolveTerminated = null, t.terminated = !0, t.worker.terminate(), _()), t.busy = !1, x(t);
      }
    }), (l && wi ? Na : _i)(t, o);
  }
}
class Ba extends TransformStream {
  constructor(t, { onstart: e, onprogress: r, size: a, onend: o }) {
    let c = 0;
    super({
      async start() {
        e && await hn(e, a);
      },
      async transform(l, u) {
        c += l.length, r && await hn(r, c, a), u.enqueue(l);
      },
      async flush() {
        t.size = c, o && await hn(o, c);
      }
    });
  }
}
async function hn(n, ...t) {
  try {
    await n(...t);
  } catch {
  }
}
function _i(n, t) {
  return {
    run: () => Ma(n, t)
  };
}
function Na(n, t) {
  const { baseURL: e, chunkSize: r } = t;
  if (!n.interface) {
    let a;
    try {
      a = ja(n.scripts[0], e, n);
    } catch {
      return wi = !1, _i(n, t);
    }
    Object.assign(n, {
      worker: a,
      interface: {
        run: () => Wa(n, { chunkSize: r })
      }
    });
  }
  return n.interface;
}
async function Ma({ options: n, readable: t, writable: e, onTaskFinished: r }, a) {
  try {
    const o = new Oa(n, a);
    await t.pipeThrough(o).pipeTo(e, { preventClose: !0, preventAbort: !0 });
    const {
      signature: c,
      inputSize: l,
      outputSize: u
    } = o;
    return {
      signature: c,
      inputSize: l,
      outputSize: u
    };
  } finally {
    r();
  }
}
async function Wa(n, t) {
  let e, r;
  const a = new Promise((_, A) => {
    e = _, r = A;
  });
  Object.assign(n, {
    reader: null,
    writer: null,
    resolveResult: e,
    rejectResult: r,
    result: a
  });
  const { readable: o, options: c, scripts: l } = n, { writable: u, closed: g } = qa(n.writable), x = qt({
    type: Ia,
    scripts: l.slice(1),
    options: c,
    config: t,
    readable: o,
    writable: u
  }, n);
  x || Object.assign(n, {
    reader: o.getReader(),
    writer: u.getWriter()
  });
  const w = await a;
  return x || await u.getWriter().close(), await g, w;
}
function qa(n) {
  let t;
  const e = new Promise((a) => t = a);
  return { writable: new WritableStream({
    async write(a) {
      const o = n.getWriter();
      await o.ready, await o.write(a), o.releaseLock();
    },
    close() {
      t();
    },
    abort(a) {
      return n.getWriter().abort(a);
    }
  }), closed: e };
}
let Cr = !0, Ir = !0;
function ja(n, t, e) {
  const r = { type: "module" };
  let a, o;
  typeof n == kt && (n = n());
  try {
    a = new URL(n, t);
  } catch {
    a = n;
  }
  if (Cr)
    try {
      o = new Worker(a);
    } catch {
      Cr = !1, o = new Worker(a, r);
    }
  else
    o = new Worker(a, r);
  return o.addEventListener(Ca, (c) => Ha(c, e)), o;
}
function qt(n, { worker: t, writer: e, onTaskFinished: r, transferStreams: a }) {
  try {
    const { value: o, readable: c, writable: l } = n, u = [];
    if (o && (o.byteLength < o.buffer.byteLength ? n.value = o.buffer.slice(0, o.byteLength) : n.value = o.buffer, u.push(n.value)), a && Ir ? (c && u.push(c), l && u.push(l)) : n.readable = n.writable = null, u.length)
      try {
        return t.postMessage(n, u), !0;
      } catch {
        Ir = !1, n.readable = n.writable = null, t.postMessage(n);
      }
    else
      t.postMessage(n);
  } catch (o) {
    throw e && e.releaseLock(), r(), o;
  }
}
async function Ha({ data: n }, t) {
  const { type: e, value: r, messageId: a, result: o, error: c } = n, { reader: l, writer: u, resolveResult: g, rejectResult: x, onTaskFinished: w } = t;
  try {
    if (c) {
      const { message: A, stack: P, code: h, name: p } = c, m = new Error(A);
      Object.assign(m, { stack: P, code: h, name: p }), _(m);
    } else {
      if (e == Da) {
        const { value: A, done: P } = await l.read();
        qt({ type: Fr, value: A, done: P, messageId: a }, t);
      }
      e == Fr && (await u.ready, await u.write(new Uint8Array(r)), qt({ type: La, messageId: a }, t)), e == Rr && _(null, o);
    }
  } catch (A) {
    qt({ type: Rr, messageId: a }, t), _(A);
  }
  function _(A, P) {
    A ? x(A) : g(P), u && u.releaseLock(), w();
  }
}
let tt = [];
const xn = [];
let Dr = 0;
async function Ya(n, t) {
  const { options: e, config: r } = t, { transferStreams: a, useWebWorkers: o, useCompressionStream: c, codecType: l, compressed: u, signed: g, encrypted: x } = e, { workerScripts: w, maxWorkers: _ } = r;
  t.transferStreams = a || a === ve;
  const A = !u && !g && !x && !t.transferStreams;
  return t.useWebWorkers = !A && (o || o === ve && r.useWebWorkers), t.scripts = t.useWebWorkers && w ? w[l] : [], e.useCompressionStream = c || c === ve && r.useCompressionStream, (await P()).run();
  async function P() {
    const p = tt.find((m) => !m.busy);
    if (p)
      return Lr(p), new mn(p, n, t, h);
    if (tt.length < _) {
      const m = { indexWorker: Dr };
      return Dr++, tt.push(m), new mn(m, n, t, h);
    } else
      return new Promise((m) => xn.push({ resolve: m, stream: n, workerOptions: t }));
  }
  function h(p) {
    if (xn.length) {
      const [{ resolve: m, stream: E, workerOptions: R }] = xn.splice(0, 1);
      m(new mn(p, E, R, h));
    } else p.worker ? (Lr(p), Ga(p, t)) : tt = tt.filter((m) => m != p);
  }
}
function Ga(n, t) {
  const { config: e } = t, { terminateWorkerTimeout: r } = e;
  Number.isFinite(r) && r >= 0 && (n.terminated ? n.terminated = !1 : n.terminateTimeout = setTimeout(async () => {
    tt = tt.filter((a) => a != n);
    try {
      await n.terminate();
    } catch {
    }
  }, r));
}
function Lr(n) {
  const { terminateTimeout: t } = n;
  t && (clearTimeout(t), n.terminateTimeout = null);
}
function Va(n, t = {}) {
  const e = `const{Array:e,Object:t,Number:n,Math:r,Error:s,Uint8Array:i,Uint16Array:o,Uint32Array:c,Int32Array:f,Map:a,DataView:l,Promise:u,TextEncoder:w,crypto:h,postMessage:d,TransformStream:p,ReadableStream:y,WritableStream:m,CompressionStream:b,DecompressionStream:g}=self,k=void 0,v="undefined",S="function";class z{constructor(e){return class extends p{constructor(t,n){const r=new e(n);super({transform(e,t){t.enqueue(r.append(e))},flush(e){const t=r.flush();t&&e.enqueue(t)}})}}}}const C=[];for(let e=0;256>e;e++){let t=e;for(let e=0;8>e;e++)1&t?t=t>>>1^3988292384:t>>>=1;C[e]=t}class x{constructor(e){this.t=e||-1}append(e){let t=0|this.t;for(let n=0,r=0|e.length;r>n;n++)t=t>>>8^C[255&(t^e[n])];this.t=t}get(){return~this.t}}class A extends p{constructor(){let e;const t=new x;super({transform(e,n){t.append(e),n.enqueue(e)},flush(){const n=new i(4);new l(n.buffer).setUint32(0,t.get()),e.value=n}}),e=this}}const _={concat(e,t){if(0===e.length||0===t.length)return e.concat(t);const n=e[e.length-1],r=_.i(n);return 32===r?e.concat(t):_.o(t,r,0|n,e.slice(0,e.length-1))},l(e){const t=e.length;if(0===t)return 0;const n=e[t-1];return 32*(t-1)+_.i(n)},u(e,t){if(32*e.length<t)return e;const n=(e=e.slice(0,r.ceil(t/32))).length;return t&=31,n>0&&t&&(e[n-1]=_.h(t,e[n-1]&2147483648>>t-1,1)),e},h:(e,t,n)=>32===e?t:(n?0|t:t<<32-e)+1099511627776*e,i:e=>r.round(e/1099511627776)||32,o(e,t,n,r){for(void 0===r&&(r=[]);t>=32;t-=32)r.push(n),n=0;if(0===t)return r.concat(e);for(let s=0;s<e.length;s++)r.push(n|e[s]>>>t),n=e[s]<<32-t;const s=e.length?e[e.length-1]:0,i=_.i(s);return r.push(_.h(t+i&31,t+i>32?n:r.pop(),1)),r}},I={bytes:{p(e){const t=_.l(e)/8,n=new i(t);let r;for(let s=0;t>s;s++)3&s||(r=e[s/4]),n[s]=r>>>24,r<<=8;return n},m(e){const t=[];let n,r=0;for(n=0;n<e.length;n++)r=r<<8|e[n],3&~n||(t.push(r),r=0);return 3&n&&t.push(_.h(8*(3&n),r)),t}}},P=class{constructor(e){const t=this;t.blockSize=512,t.k=[1732584193,4023233417,2562383102,271733878,3285377520],t.v=[1518500249,1859775393,2400959708,3395469782],e?(t.S=e.S.slice(0),t.C=e.C.slice(0),t.A=e.A):t.reset()}reset(){const e=this;return e.S=e.k.slice(0),e.C=[],e.A=0,e}update(e){const t=this;"string"==typeof e&&(e=I._.m(e));const n=t.C=_.concat(t.C,e),r=t.A,i=t.A=r+_.l(e);if(i>9007199254740991)throw new s("Cannot hash more than 2^53 - 1 bits");const o=new c(n);let f=0;for(let e=t.blockSize+r-(t.blockSize+r&t.blockSize-1);i>=e;e+=t.blockSize)t.I(o.subarray(16*f,16*(f+1))),f+=1;return n.splice(0,16*f),t}P(){const e=this;let t=e.C;const n=e.S;t=_.concat(t,[_.h(1,1)]);for(let e=t.length+2;15&e;e++)t.push(0);for(t.push(r.floor(e.A/4294967296)),t.push(0|e.A);t.length;)e.I(t.splice(0,16));return e.reset(),n}D(e,t,n,r){return e>19?e>39?e>59?e>79?void 0:t^n^r:t&n|t&r|n&r:t^n^r:t&n|~t&r}V(e,t){return t<<e|t>>>32-e}I(t){const n=this,s=n.S,i=e(80);for(let e=0;16>e;e++)i[e]=t[e];let o=s[0],c=s[1],f=s[2],a=s[3],l=s[4];for(let e=0;79>=e;e++){16>e||(i[e]=n.V(1,i[e-3]^i[e-8]^i[e-14]^i[e-16]));const t=n.V(5,o)+n.D(e,c,f,a)+l+i[e]+n.v[r.floor(e/20)]|0;l=a,a=f,f=n.V(30,c),c=o,o=t}s[0]=s[0]+o|0,s[1]=s[1]+c|0,s[2]=s[2]+f|0,s[3]=s[3]+a|0,s[4]=s[4]+l|0}},D={getRandomValues(e){const t=new c(e.buffer),n=e=>{let t=987654321;const n=4294967295;return()=>(t=36969*(65535&t)+(t>>16)&n,(((t<<16)+(e=18e3*(65535&e)+(e>>16)&n)&n)/4294967296+.5)*(r.random()>.5?1:-1))};for(let s,i=0;i<e.length;i+=4){const e=n(4294967296*(s||r.random()));s=987654071*e(),t[i/4]=4294967296*e()|0}return e}},V={importKey:e=>new V.R(I.bytes.m(e)),B(e,t,n,r){if(n=n||1e4,0>r||0>n)throw new s("invalid params to pbkdf2");const i=1+(r>>5)<<2;let o,c,f,a,u;const w=new ArrayBuffer(i),h=new l(w);let d=0;const p=_;for(t=I.bytes.m(t),u=1;(i||1)>d;u++){for(o=c=e.encrypt(p.concat(t,[u])),f=1;n>f;f++)for(c=e.encrypt(c),a=0;a<c.length;a++)o[a]^=c[a];for(f=0;(i||1)>d&&f<o.length;f++)h.setInt32(d,o[f]),d+=4}return w.slice(0,r/8)},R:class{constructor(e){const t=this,n=t.M=P,r=[[],[]];t.U=[new n,new n];const s=t.U[0].blockSize/32;e.length>s&&(e=(new n).update(e).P());for(let t=0;s>t;t++)r[0][t]=909522486^e[t],r[1][t]=1549556828^e[t];t.U[0].update(r[0]),t.U[1].update(r[1]),t.K=new n(t.U[0])}reset(){const e=this;e.K=new e.M(e.U[0]),e.N=!1}update(e){this.N=!0,this.K.update(e)}digest(){const e=this,t=e.K.P(),n=new e.M(e.U[1]).update(t).P();return e.reset(),n}encrypt(e){if(this.N)throw new s("encrypt on already updated hmac called!");return this.update(e),this.digest(e)}}},R=typeof h!=v&&typeof h.getRandomValues==S,B="Invalid password",E="Invalid signature",M="zipjs-abort-check-password";function U(e){return R?h.getRandomValues(e):D.getRandomValues(e)}const K=16,N={name:"PBKDF2"},O=t.assign({hash:{name:"HMAC"}},N),T=t.assign({iterations:1e3,hash:{name:"SHA-1"}},N),W=["deriveBits"],j=[8,12,16],H=[16,24,32],L=10,F=[0,0,0,0],q=typeof h!=v,G=q&&h.subtle,J=q&&typeof G!=v,Q=I.bytes,X=class{constructor(e){const t=this;t.O=[[[],[],[],[],[]],[[],[],[],[],[]]],t.O[0][0][0]||t.T();const n=t.O[0][4],r=t.O[1],i=e.length;let o,c,f,a=1;if(4!==i&&6!==i&&8!==i)throw new s("invalid aes key size");for(t.v=[c=e.slice(0),f=[]],o=i;4*i+28>o;o++){let e=c[o-1];(o%i==0||8===i&&o%i==4)&&(e=n[e>>>24]<<24^n[e>>16&255]<<16^n[e>>8&255]<<8^n[255&e],o%i==0&&(e=e<<8^e>>>24^a<<24,a=a<<1^283*(a>>7))),c[o]=c[o-i]^e}for(let e=0;o;e++,o--){const t=c[3&e?o:o-4];f[e]=4>=o||4>e?t:r[0][n[t>>>24]]^r[1][n[t>>16&255]]^r[2][n[t>>8&255]]^r[3][n[255&t]]}}encrypt(e){return this.W(e,0)}decrypt(e){return this.W(e,1)}T(){const e=this.O[0],t=this.O[1],n=e[4],r=t[4],s=[],i=[];let o,c,f,a;for(let e=0;256>e;e++)i[(s[e]=e<<1^283*(e>>7))^e]=e;for(let l=o=0;!n[l];l^=c||1,o=i[o]||1){let i=o^o<<1^o<<2^o<<3^o<<4;i=i>>8^255&i^99,n[l]=i,r[i]=l,a=s[f=s[c=s[l]]];let u=16843009*a^65537*f^257*c^16843008*l,w=257*s[i]^16843008*i;for(let n=0;4>n;n++)e[n][l]=w=w<<24^w>>>8,t[n][i]=u=u<<24^u>>>8}for(let n=0;5>n;n++)e[n]=e[n].slice(0),t[n]=t[n].slice(0)}W(e,t){if(4!==e.length)throw new s("invalid aes block size");const n=this.v[t],r=n.length/4-2,i=[0,0,0,0],o=this.O[t],c=o[0],f=o[1],a=o[2],l=o[3],u=o[4];let w,h,d,p=e[0]^n[0],y=e[t?3:1]^n[1],m=e[2]^n[2],b=e[t?1:3]^n[3],g=4;for(let e=0;r>e;e++)w=c[p>>>24]^f[y>>16&255]^a[m>>8&255]^l[255&b]^n[g],h=c[y>>>24]^f[m>>16&255]^a[b>>8&255]^l[255&p]^n[g+1],d=c[m>>>24]^f[b>>16&255]^a[p>>8&255]^l[255&y]^n[g+2],b=c[b>>>24]^f[p>>16&255]^a[y>>8&255]^l[255&m]^n[g+3],g+=4,p=w,y=h,m=d;for(let e=0;4>e;e++)i[t?3&-e:e]=u[p>>>24]<<24^u[y>>16&255]<<16^u[m>>8&255]<<8^u[255&b]^n[g++],w=p,p=y,y=m,m=b,b=w;return i}},Y=class{constructor(e,t){this.j=e,this.H=t,this.L=t}reset(){this.L=this.H}update(e){return this.F(this.j,e,this.L)}q(e){if(255&~(e>>24))e+=1<<24;else{let t=e>>16&255,n=e>>8&255,r=255&e;255===t?(t=0,255===n?(n=0,255===r?r=0:++r):++n):++t,e=0,e+=t<<16,e+=n<<8,e+=r}return e}G(e){0===(e[0]=this.q(e[0]))&&(e[1]=this.q(e[1]))}F(e,t,n){let r;if(!(r=t.length))return[];const s=_.l(t);for(let s=0;r>s;s+=4){this.G(n);const r=e.encrypt(n);t[s]^=r[0],t[s+1]^=r[1],t[s+2]^=r[2],t[s+3]^=r[3]}return _.u(t,s)}},Z=V.R;let $=q&&J&&typeof G.importKey==S,ee=q&&J&&typeof G.deriveBits==S;class te extends p{constructor({password:e,rawPassword:n,signed:r,encryptionStrength:o,checkPasswordOnly:c}){super({start(){t.assign(this,{ready:new u((e=>this.J=e)),password:ie(e,n),signed:r,X:o-1,pending:new i})},async transform(e,t){const n=this,{password:r,X:o,J:f,ready:a}=n;r?(await(async(e,t,n,r)=>{const i=await se(e,t,n,ce(r,0,j[t])),o=ce(r,j[t]);if(i[0]!=o[0]||i[1]!=o[1])throw new s(B)})(n,o,r,ce(e,0,j[o]+2)),e=ce(e,j[o]+2),c?t.error(new s(M)):f()):await a;const l=new i(e.length-L-(e.length-L)%K);t.enqueue(re(n,e,l,0,L,!0))},async flush(e){const{signed:t,Y:n,Z:r,pending:o,ready:c}=this;if(r&&n){await c;const f=ce(o,0,o.length-L),a=ce(o,o.length-L);let l=new i;if(f.length){const e=ae(Q,f);r.update(e);const t=n.update(e);l=fe(Q,t)}if(t){const e=ce(fe(Q,r.digest()),0,L);for(let t=0;L>t;t++)if(e[t]!=a[t])throw new s(E)}e.enqueue(l)}}})}}class ne extends p{constructor({password:e,rawPassword:n,encryptionStrength:r}){let s;super({start(){t.assign(this,{ready:new u((e=>this.J=e)),password:ie(e,n),X:r-1,pending:new i})},async transform(e,t){const n=this,{password:r,X:s,J:o,ready:c}=n;let f=new i;r?(f=await(async(e,t,n)=>{const r=U(new i(j[t]));return oe(r,await se(e,t,n,r))})(n,s,r),o()):await c;const a=new i(f.length+e.length-e.length%K);a.set(f,0),t.enqueue(re(n,e,a,f.length,0))},async flush(e){const{Y:t,Z:n,pending:r,ready:o}=this;if(n&&t){await o;let c=new i;if(r.length){const e=t.update(ae(Q,r));n.update(e),c=fe(Q,e)}s.signature=fe(Q,n.digest()).slice(0,L),e.enqueue(oe(c,s.signature))}}}),s=this}}function re(e,t,n,r,s,o){const{Y:c,Z:f,pending:a}=e,l=t.length-s;let u;for(a.length&&(t=oe(a,t),n=((e,t)=>{if(t&&t>e.length){const n=e;(e=new i(t)).set(n,0)}return e})(n,l-l%K)),u=0;l-K>=u;u+=K){const e=ae(Q,ce(t,u,u+K));o&&f.update(e);const s=c.update(e);o||f.update(s),n.set(fe(Q,s),u+r)}return e.pending=ce(t,u),n}async function se(n,r,s,o){n.password=null;const c=await(async(e,t,n,r,s)=>{if(!$)return V.importKey(t);try{return await G.importKey("raw",t,n,!1,s)}catch(e){return $=!1,V.importKey(t)}})(0,s,O,0,W),f=await(async(e,t,n)=>{if(!ee)return V.B(t,e.salt,T.iterations,n);try{return await G.deriveBits(e,t,n)}catch(r){return ee=!1,V.B(t,e.salt,T.iterations,n)}})(t.assign({salt:o},T),c,8*(2*H[r]+2)),a=new i(f),l=ae(Q,ce(a,0,H[r])),u=ae(Q,ce(a,H[r],2*H[r])),w=ce(a,2*H[r]);return t.assign(n,{keys:{key:l,$:u,passwordVerification:w},Y:new Y(new X(l),e.from(F)),Z:new Z(u)}),w}function ie(e,t){return t===k?(e=>{if(typeof w==v){const t=new i((e=unescape(encodeURIComponent(e))).length);for(let n=0;n<t.length;n++)t[n]=e.charCodeAt(n);return t}return(new w).encode(e)})(e):t}function oe(e,t){let n=e;return e.length+t.length&&(n=new i(e.length+t.length),n.set(e,0),n.set(t,e.length)),n}function ce(e,t,n){return e.subarray(t,n)}function fe(e,t){return e.p(t)}function ae(e,t){return e.m(t)}class le extends p{constructor({password:e,passwordVerification:n,checkPasswordOnly:r}){super({start(){t.assign(this,{password:e,passwordVerification:n}),de(this,e)},transform(e,t){const n=this;if(n.password){const t=we(n,e.subarray(0,12));if(n.password=null,t[11]!=n.passwordVerification)throw new s(B);e=e.subarray(12)}r?t.error(new s(M)):t.enqueue(we(n,e))}})}}class ue extends p{constructor({password:e,passwordVerification:n}){super({start(){t.assign(this,{password:e,passwordVerification:n}),de(this,e)},transform(e,t){const n=this;let r,s;if(n.password){n.password=null;const t=U(new i(12));t[11]=n.passwordVerification,r=new i(e.length+t.length),r.set(he(n,t),0),s=12}else r=new i(e.length),s=0;r.set(he(n,e),s),t.enqueue(r)}})}}function we(e,t){const n=new i(t.length);for(let r=0;r<t.length;r++)n[r]=ye(e)^t[r],pe(e,n[r]);return n}function he(e,t){const n=new i(t.length);for(let r=0;r<t.length;r++)n[r]=ye(e)^t[r],pe(e,t[r]);return n}function de(e,n){const r=[305419896,591751049,878082192];t.assign(e,{keys:r,ee:new x(r[0]),te:new x(r[2])});for(let t=0;t<n.length;t++)pe(e,n.charCodeAt(t))}function pe(e,t){let[n,s,i]=e.keys;e.ee.append([t]),n=~e.ee.get(),s=be(r.imul(be(s+me(n)),134775813)+1),e.te.append([s>>>24]),i=~e.te.get(),e.keys=[n,s,i]}function ye(e){const t=2|e.keys[2];return me(r.imul(t,1^t)>>>8)}function me(e){return 255&e}function be(e){return 4294967295&e}const ge="deflate-raw";class ke extends p{constructor(e,{chunkSize:t,CompressionStream:n,CompressionStreamNative:r}){super({});const{compressed:s,encrypted:i,useCompressionStream:o,zipCrypto:c,signed:f,level:a}=e,u=this;let w,h,d=Se(super.readable);i&&!c||!f||(w=new A,d=xe(d,w)),s&&(d=Ce(d,o,{level:a,chunkSize:t},r,n)),i&&(c?d=xe(d,new ue(e)):(h=new ne(e),d=xe(d,h))),ze(u,d,(()=>{let e;i&&!c&&(e=h.signature),i&&!c||!f||(e=new l(w.value.buffer).getUint32(0)),u.signature=e}))}}class ve extends p{constructor(e,{chunkSize:t,DecompressionStream:n,DecompressionStreamNative:r}){super({});const{zipCrypto:i,encrypted:o,signed:c,signature:f,compressed:a,useCompressionStream:u}=e;let w,h,d=Se(super.readable);o&&(i?d=xe(d,new le(e)):(h=new te(e),d=xe(d,h))),a&&(d=Ce(d,u,{chunkSize:t},r,n)),o&&!i||!c||(w=new A,d=xe(d,w)),ze(this,d,(()=>{if((!o||i)&&c){const e=new l(w.value.buffer);if(f!=e.getUint32(0,!1))throw new s(E)}}))}}function Se(e){return xe(e,new p({transform(e,t){e&&e.length&&t.enqueue(e)}}))}function ze(e,n,r){n=xe(n,new p({flush:r})),t.defineProperty(e,"readable",{get:()=>n})}function Ce(e,t,n,r,s){try{e=xe(e,new(t&&r?r:s)(ge,n))}catch(r){if(!t)return e;try{e=xe(e,new s(ge,n))}catch(t){return e}}return e}function xe(e,t){return e.pipeThrough(t)}const Ae="data",_e="close";class Ie extends p{constructor(e,n){super({});const r=this,{codecType:s}=e;let i;s.startsWith("deflate")?i=ke:s.startsWith("inflate")&&(i=ve);let o=0,c=0;const f=new i(e,n),a=super.readable,l=new p({transform(e,t){e&&e.length&&(c+=e.length,t.enqueue(e))},flush(){t.assign(r,{inputSize:c})}}),u=new p({transform(e,t){e&&e.length&&(o+=e.length,t.enqueue(e))},flush(){const{signature:e}=f;t.assign(r,{signature:e,outputSize:o,inputSize:c})}});t.defineProperty(r,"readable",{get:()=>a.pipeThrough(l).pipeThrough(f).pipeThrough(u)})}}class Pe extends p{constructor(e){let t;super({transform:function n(r,s){if(t){const e=new i(t.length+r.length);e.set(t),e.set(r,t.length),r=e,t=null}r.length>e?(s.enqueue(r.slice(0,e)),n(r.slice(e),s)):t=r},flush(e){t&&t.length&&e.enqueue(t)}})}}const De=new a,Ve=new a;let Re,Be=0,Ee=!0;async function Me(e){try{const{options:t,scripts:r,config:s}=e;if(r&&r.length)try{Ee?importScripts.apply(k,r):await Ue(r)}catch(e){Ee=!1,await Ue(r)}self.initCodec&&self.initCodec(),s.CompressionStreamNative=self.CompressionStream,s.DecompressionStreamNative=self.DecompressionStream,self.Deflate&&(s.CompressionStream=new z(self.Deflate)),self.Inflate&&(s.DecompressionStream=new z(self.Inflate));const i={highWaterMark:1},o=e.readable||new y({async pull(e){const t=new u((e=>De.set(Be,e)));Ke({type:"pull",messageId:Be}),Be=(Be+1)%n.MAX_SAFE_INTEGER;const{value:r,done:s}=await t;e.enqueue(r),s&&e.close()}},i),c=e.writable||new m({async write(e){let t;const r=new u((e=>t=e));Ve.set(Be,t),Ke({type:Ae,value:e,messageId:Be}),Be=(Be+1)%n.MAX_SAFE_INTEGER,await r}},i),f=new Ie(t,s);Re=new AbortController;const{signal:a}=Re;await o.pipeThrough(f).pipeThrough(new Pe(s.chunkSize)).pipeTo(c,{signal:a,preventClose:!0,preventAbort:!0}),await c.getWriter().close();const{signature:l,inputSize:w,outputSize:h}=f;Ke({type:_e,result:{signature:l,inputSize:w,outputSize:h}})}catch(e){Ne(e)}}async function Ue(e){for(const t of e)await import(t)}function Ke(e){let{value:t}=e;if(t)if(t.length)try{t=new i(t),e.value=t.buffer,d(e,[e.value])}catch(t){d(e)}else d(e);else d(e)}function Ne(e=new s("Unknown error")){const{message:t,stack:n,code:r,name:i}=e;d({error:{message:t,stack:n,code:r,name:i}})}addEventListener("message",(({data:e})=>{const{type:t,messageId:n,value:r,done:s}=e;try{if("start"==t&&Me(e),t==Ae){const e=De.get(n);De.delete(n),e({value:new i(r),done:s})}if("ack"==t){const e=Ve.get(n);Ve.delete(n),e()}t==_e&&Re.abort()}catch(e){Ne(e)}}));const Oe=-2;function Te(t){return We(t.map((([t,n])=>new e(t).fill(n,0,t))))}function We(t){return t.reduce(((t,n)=>t.concat(e.isArray(n)?We(n):n)),[])}const je=[0,1,2,3].concat(...Te([[2,4],[2,5],[4,6],[4,7],[8,8],[8,9],[16,10],[16,11],[32,12],[32,13],[64,14],[64,15],[2,0],[1,16],[1,17],[2,18],[2,19],[4,20],[4,21],[8,22],[8,23],[16,24],[16,25],[32,26],[32,27],[64,28],[64,29]]));function He(){const e=this;function t(e,t){let n=0;do{n|=1&e,e>>>=1,n<<=1}while(--t>0);return n>>>1}e.ne=n=>{const s=e.re,i=e.ie.se,o=e.ie.oe;let c,f,a,l=-1;for(n.ce=0,n.fe=573,c=0;o>c;c++)0!==s[2*c]?(n.ae[++n.ce]=l=c,n.le[c]=0):s[2*c+1]=0;for(;2>n.ce;)a=n.ae[++n.ce]=2>l?++l:0,s[2*a]=1,n.le[a]=0,n.ue--,i&&(n.we-=i[2*a+1]);for(e.he=l,c=r.floor(n.ce/2);c>=1;c--)n.de(s,c);a=o;do{c=n.ae[1],n.ae[1]=n.ae[n.ce--],n.de(s,1),f=n.ae[1],n.ae[--n.fe]=c,n.ae[--n.fe]=f,s[2*a]=s[2*c]+s[2*f],n.le[a]=r.max(n.le[c],n.le[f])+1,s[2*c+1]=s[2*f+1]=a,n.ae[1]=a++,n.de(s,1)}while(n.ce>=2);n.ae[--n.fe]=n.ae[1],(t=>{const n=e.re,r=e.ie.se,s=e.ie.pe,i=e.ie.ye,o=e.ie.me;let c,f,a,l,u,w,h=0;for(l=0;15>=l;l++)t.be[l]=0;for(n[2*t.ae[t.fe]+1]=0,c=t.fe+1;573>c;c++)f=t.ae[c],l=n[2*n[2*f+1]+1]+1,l>o&&(l=o,h++),n[2*f+1]=l,f>e.he||(t.be[l]++,u=0,i>f||(u=s[f-i]),w=n[2*f],t.ue+=w*(l+u),r&&(t.we+=w*(r[2*f+1]+u)));if(0!==h){do{for(l=o-1;0===t.be[l];)l--;t.be[l]--,t.be[l+1]+=2,t.be[o]--,h-=2}while(h>0);for(l=o;0!==l;l--)for(f=t.be[l];0!==f;)a=t.ae[--c],a>e.he||(n[2*a+1]!=l&&(t.ue+=(l-n[2*a+1])*n[2*a],n[2*a+1]=l),f--)}})(n),((e,n,r)=>{const s=[];let i,o,c,f=0;for(i=1;15>=i;i++)s[i]=f=f+r[i-1]<<1;for(o=0;n>=o;o++)c=e[2*o+1],0!==c&&(e[2*o]=t(s[c]++,c))})(s,e.he,n.be)}}function Le(e,t,n,r,s){const i=this;i.se=e,i.pe=t,i.ye=n,i.oe=r,i.me=s}He.ge=[0,1,2,3,4,5,6,7].concat(...Te([[2,8],[2,9],[2,10],[2,11],[4,12],[4,13],[4,14],[4,15],[8,16],[8,17],[8,18],[8,19],[16,20],[16,21],[16,22],[16,23],[32,24],[32,25],[32,26],[31,27],[1,28]])),He.ke=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,0],He.ve=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576],He.Se=e=>256>e?je[e]:je[256+(e>>>7)],He.ze=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],He.Ce=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],He.xe=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],He.Ae=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];const Fe=Te([[144,8],[112,9],[24,7],[8,8]]);Le._e=We([12,140,76,204,44,172,108,236,28,156,92,220,60,188,124,252,2,130,66,194,34,162,98,226,18,146,82,210,50,178,114,242,10,138,74,202,42,170,106,234,26,154,90,218,58,186,122,250,6,134,70,198,38,166,102,230,22,150,86,214,54,182,118,246,14,142,78,206,46,174,110,238,30,158,94,222,62,190,126,254,1,129,65,193,33,161,97,225,17,145,81,209,49,177,113,241,9,137,73,201,41,169,105,233,25,153,89,217,57,185,121,249,5,133,69,197,37,165,101,229,21,149,85,213,53,181,117,245,13,141,77,205,45,173,109,237,29,157,93,221,61,189,125,253,19,275,147,403,83,339,211,467,51,307,179,435,115,371,243,499,11,267,139,395,75,331,203,459,43,299,171,427,107,363,235,491,27,283,155,411,91,347,219,475,59,315,187,443,123,379,251,507,7,263,135,391,71,327,199,455,39,295,167,423,103,359,231,487,23,279,151,407,87,343,215,471,55,311,183,439,119,375,247,503,15,271,143,399,79,335,207,463,47,303,175,431,111,367,239,495,31,287,159,415,95,351,223,479,63,319,191,447,127,383,255,511,0,64,32,96,16,80,48,112,8,72,40,104,24,88,56,120,4,68,36,100,20,84,52,116,3,131,67,195,35,163,99,227].map(((e,t)=>[e,Fe[t]])));const qe=Te([[30,5]]);function Ge(e,t,n,r,s){const i=this;i.Ie=e,i.Pe=t,i.De=n,i.Ve=r,i.Re=s}Le.Be=We([0,16,8,24,4,20,12,28,2,18,10,26,6,22,14,30,1,17,9,25,5,21,13,29,3,19,11,27,7,23].map(((e,t)=>[e,qe[t]]))),Le.Ee=new Le(Le._e,He.ze,257,286,15),Le.Me=new Le(Le.Be,He.Ce,0,30,15),Le.Ue=new Le(null,He.xe,0,19,7);const Je=[new Ge(0,0,0,0,0),new Ge(4,4,8,4,1),new Ge(4,5,16,8,1),new Ge(4,6,32,32,1),new Ge(4,4,16,16,2),new Ge(8,16,32,32,2),new Ge(8,16,128,128,2),new Ge(8,32,128,256,2),new Ge(32,128,258,1024,2),new Ge(32,258,258,4096,2)],Qe=["need dictionary","stream end","","","stream error","data error","","buffer error","",""],Xe=113,Ye=666,Ze=262;function $e(e,t,n,r){const s=e[2*t],i=e[2*n];return i>s||s==i&&r[t]<=r[n]}function et(){const e=this;let t,n,s,c,f,a,l,u,w,h,d,p,y,m,b,g,k,v,S,z,C,x,A,_,I,P,D,V,R,B,E,M,U;const K=new He,N=new He,O=new He;let T,W,j,H,L,F;function q(){let t;for(t=0;286>t;t++)E[2*t]=0;for(t=0;30>t;t++)M[2*t]=0;for(t=0;19>t;t++)U[2*t]=0;E[512]=1,e.ue=e.we=0,W=j=0}function G(e,t){let n,r=-1,s=e[1],i=0,o=7,c=4;0===s&&(o=138,c=3),e[2*(t+1)+1]=65535;for(let f=0;t>=f;f++)n=s,s=e[2*(f+1)+1],++i<o&&n==s||(c>i?U[2*n]+=i:0!==n?(n!=r&&U[2*n]++,U[32]++):i>10?U[36]++:U[34]++,i=0,r=n,0===s?(o=138,c=3):n==s?(o=6,c=3):(o=7,c=4))}function J(t){e.Ke[e.pending++]=t}function Q(e){J(255&e),J(e>>>8&255)}function X(e,t){let n;const r=t;F>16-r?(n=e,L|=n<<F&65535,Q(L),L=n>>>16-F,F+=r-16):(L|=e<<F&65535,F+=r)}function Y(e,t){const n=2*e;X(65535&t[n],65535&t[n+1])}function Z(e,t){let n,r,s=-1,i=e[1],o=0,c=7,f=4;for(0===i&&(c=138,f=3),n=0;t>=n;n++)if(r=i,i=e[2*(n+1)+1],++o>=c||r!=i){if(f>o)do{Y(r,U)}while(0!=--o);else 0!==r?(r!=s&&(Y(r,U),o--),Y(16,U),X(o-3,2)):o>10?(Y(18,U),X(o-11,7)):(Y(17,U),X(o-3,3));o=0,s=r,0===i?(c=138,f=3):r==i?(c=6,f=3):(c=7,f=4)}}function $(){16==F?(Q(L),L=0,F=0):8>F||(J(255&L),L>>>=8,F-=8)}function ee(t,n){let s,i,o;if(e.Ne[W]=t,e.Oe[W]=255&n,W++,0===t?E[2*n]++:(j++,t--,E[2*(He.ge[n]+256+1)]++,M[2*He.Se(t)]++),!(8191&W)&&D>2){for(s=8*W,i=C-k,o=0;30>o;o++)s+=M[2*o]*(5+He.Ce[o]);if(s>>>=3,j<r.floor(W/2)&&s<r.floor(i/2))return!0}return W==T-1}function te(t,n){let r,s,i,o,c=0;if(0!==W)do{r=e.Ne[c],s=e.Oe[c],c++,0===r?Y(s,t):(i=He.ge[s],Y(i+256+1,t),o=He.ze[i],0!==o&&(s-=He.ke[i],X(s,o)),r--,i=He.Se(r),Y(i,n),o=He.Ce[i],0!==o&&(r-=He.ve[i],X(r,o)))}while(W>c);Y(256,t),H=t[513]}function ne(){F>8?Q(L):F>0&&J(255&L),L=0,F=0}function re(t,n,r){X(0+(r?1:0),3),((t,n)=>{ne(),H=8,Q(n),Q(~n),e.Ke.set(u.subarray(t,t+n),e.pending),e.pending+=n})(t,n)}function se(n){((t,n,r)=>{let s,i,o=0;D>0?(K.ne(e),N.ne(e),o=(()=>{let t;for(G(E,K.he),G(M,N.he),O.ne(e),t=18;t>=3&&0===U[2*He.Ae[t]+1];t--);return e.ue+=14+3*(t+1),t})(),s=e.ue+3+7>>>3,i=e.we+3+7>>>3,i>s||(s=i)):s=i=n+5,n+4>s||-1==t?i==s?(X(2+(r?1:0),3),te(Le._e,Le.Be)):(X(4+(r?1:0),3),((e,t,n)=>{let r;for(X(e-257,5),X(t-1,5),X(n-4,4),r=0;n>r;r++)X(U[2*He.Ae[r]+1],3);Z(E,e-1),Z(M,t-1)})(K.he+1,N.he+1,o+1),te(E,M)):re(t,n,r),q(),r&&ne()})(0>k?-1:k,C-k,n),k=C,t.Te()}function ie(){let e,n,r,s;do{if(s=w-A-C,0===s&&0===C&&0===A)s=f;else if(-1==s)s--;else if(C>=f+f-Ze){u.set(u.subarray(f,f+f),0),x-=f,C-=f,k-=f,e=y,r=e;do{n=65535&d[--r],d[r]=f>n?0:n-f}while(0!=--e);e=f,r=e;do{n=65535&h[--r],h[r]=f>n?0:n-f}while(0!=--e);s+=f}if(0===t.We)return;e=t.je(u,C+A,s),A+=e,3>A||(p=255&u[C],p=(p<<g^255&u[C+1])&b)}while(Ze>A&&0!==t.We)}function oe(e){let t,n,r=I,s=C,i=_;const o=C>f-Ze?C-(f-Ze):0;let c=B;const a=l,w=C+258;let d=u[s+i-1],p=u[s+i];R>_||(r>>=2),c>A&&(c=A);do{if(t=e,u[t+i]==p&&u[t+i-1]==d&&u[t]==u[s]&&u[++t]==u[s+1]){s+=2,t++;do{}while(u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&w>s);if(n=258-(w-s),s=w-258,n>i){if(x=e,i=n,n>=c)break;d=u[s+i-1],p=u[s+i]}}}while((e=65535&h[e&a])>o&&0!=--r);return i>A?A:i}e.le=[],e.be=[],e.ae=[],E=[],M=[],U=[],e.de=(t,n)=>{const r=e.ae,s=r[n];let i=n<<1;for(;i<=e.ce&&(i<e.ce&&$e(t,r[i+1],r[i],e.le)&&i++,!$e(t,s,r[i],e.le));)r[n]=r[i],n=i,i<<=1;r[n]=s},e.He=(t,S,x,W,j,G)=>(W||(W=8),j||(j=8),G||(G=0),t.Le=null,-1==S&&(S=6),1>j||j>9||8!=W||9>x||x>15||0>S||S>9||0>G||G>2?Oe:(t.Fe=e,a=x,f=1<<a,l=f-1,m=j+7,y=1<<m,b=y-1,g=r.floor((m+3-1)/3),u=new i(2*f),h=[],d=[],T=1<<j+6,e.Ke=new i(4*T),s=4*T,e.Ne=new o(T),e.Oe=new i(T),D=S,V=G,(t=>(t.qe=t.Ge=0,t.Le=null,e.pending=0,e.Je=0,n=Xe,c=0,K.re=E,K.ie=Le.Ee,N.re=M,N.ie=Le.Me,O.re=U,O.ie=Le.Ue,L=0,F=0,H=8,q(),(()=>{w=2*f,d[y-1]=0;for(let e=0;y-1>e;e++)d[e]=0;P=Je[D].Pe,R=Je[D].Ie,B=Je[D].De,I=Je[D].Ve,C=0,k=0,A=0,v=_=2,z=0,p=0})(),0))(t))),e.Qe=()=>42!=n&&n!=Xe&&n!=Ye?Oe:(e.Oe=null,e.Ne=null,e.Ke=null,d=null,h=null,u=null,e.Fe=null,n==Xe?-3:0),e.Xe=(e,t,n)=>{let r=0;return-1==t&&(t=6),0>t||t>9||0>n||n>2?Oe:(Je[D].Re!=Je[t].Re&&0!==e.qe&&(r=e.Ye(1)),D!=t&&(D=t,P=Je[D].Pe,R=Je[D].Ie,B=Je[D].De,I=Je[D].Ve),V=n,r)},e.Ze=(e,t,r)=>{let s,i=r,o=0;if(!t||42!=n)return Oe;if(3>i)return 0;for(i>f-Ze&&(i=f-Ze,o=r-i),u.set(t.subarray(o,o+i),0),C=i,k=i,p=255&u[0],p=(p<<g^255&u[1])&b,s=0;i-3>=s;s++)p=(p<<g^255&u[s+2])&b,h[s&l]=d[p],d[p]=s;return 0},e.Ye=(r,i)=>{let o,w,m,I,R;if(i>4||0>i)return Oe;if(!r.$e||!r.et&&0!==r.We||n==Ye&&4!=i)return r.Le=Qe[4],Oe;if(0===r.tt)return r.Le=Qe[7],-5;var B;if(t=r,I=c,c=i,42==n&&(w=8+(a-8<<4)<<8,m=(D-1&255)>>1,m>3&&(m=3),w|=m<<6,0!==C&&(w|=32),w+=31-w%31,n=Xe,J((B=w)>>8&255),J(255&B)),0!==e.pending){if(t.Te(),0===t.tt)return c=-1,0}else if(0===t.We&&I>=i&&4!=i)return t.Le=Qe[7],-5;if(n==Ye&&0!==t.We)return r.Le=Qe[7],-5;if(0!==t.We||0!==A||0!=i&&n!=Ye){switch(R=-1,Je[D].Re){case 0:R=(e=>{let n,r=65535;for(r>s-5&&(r=s-5);;){if(1>=A){if(ie(),0===A&&0==e)return 0;if(0===A)break}if(C+=A,A=0,n=k+r,(0===C||C>=n)&&(A=C-n,C=n,se(!1),0===t.tt))return 0;if(C-k>=f-Ze&&(se(!1),0===t.tt))return 0}return se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i);break;case 1:R=(e=>{let n,r=0;for(;;){if(Ze>A){if(ie(),Ze>A&&0==e)return 0;if(0===A)break}if(3>A||(p=(p<<g^255&u[C+2])&b,r=65535&d[p],h[C&l]=d[p],d[p]=C),0===r||(C-r&65535)>f-Ze||2!=V&&(v=oe(r)),3>v)n=ee(0,255&u[C]),A--,C++;else if(n=ee(C-x,v-3),A-=v,v>P||3>A)C+=v,v=0,p=255&u[C],p=(p<<g^255&u[C+1])&b;else{v--;do{C++,p=(p<<g^255&u[C+2])&b,r=65535&d[p],h[C&l]=d[p],d[p]=C}while(0!=--v);C++}if(n&&(se(!1),0===t.tt))return 0}return se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i);break;case 2:R=(e=>{let n,r,s=0;for(;;){if(Ze>A){if(ie(),Ze>A&&0==e)return 0;if(0===A)break}if(3>A||(p=(p<<g^255&u[C+2])&b,s=65535&d[p],h[C&l]=d[p],d[p]=C),_=v,S=x,v=2,0!==s&&P>_&&f-Ze>=(C-s&65535)&&(2!=V&&(v=oe(s)),5>=v&&(1==V||3==v&&C-x>4096)&&(v=2)),3>_||v>_)if(0!==z){if(n=ee(0,255&u[C-1]),n&&se(!1),C++,A--,0===t.tt)return 0}else z=1,C++,A--;else{r=C+A-3,n=ee(C-1-S,_-3),A-=_-1,_-=2;do{++C>r||(p=(p<<g^255&u[C+2])&b,s=65535&d[p],h[C&l]=d[p],d[p]=C)}while(0!=--_);if(z=0,v=2,C++,n&&(se(!1),0===t.tt))return 0}}return 0!==z&&(n=ee(0,255&u[C-1]),z=0),se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i)}if(2!=R&&3!=R||(n=Ye),0==R||2==R)return 0===t.tt&&(c=-1),0;if(1==R){if(1==i)X(2,3),Y(256,Le._e),$(),9>1+H+10-F&&(X(2,3),Y(256,Le._e),$()),H=7;else if(re(0,0,!1),3==i)for(o=0;y>o;o++)d[o]=0;if(t.Te(),0===t.tt)return c=-1,0}}return 4!=i?0:1}}function tt(){const e=this;e.nt=0,e.rt=0,e.We=0,e.qe=0,e.tt=0,e.Ge=0}function nt(e){const t=new tt,n=(o=e&&e.chunkSize?e.chunkSize:65536)+5*(r.floor(o/16383)+1);var o;const c=new i(n);let f=e?e.level:-1;void 0===f&&(f=-1),t.He(f),t.$e=c,this.append=(e,r)=>{let o,f,a=0,l=0,u=0;const w=[];if(e.length){t.nt=0,t.et=e,t.We=e.length;do{if(t.rt=0,t.tt=n,o=t.Ye(0),0!=o)throw new s("deflating: "+t.Le);t.rt&&(t.rt==n?w.push(new i(c)):w.push(c.subarray(0,t.rt))),u+=t.rt,r&&t.nt>0&&t.nt!=a&&(r(t.nt),a=t.nt)}while(t.We>0||0===t.tt);return w.length>1?(f=new i(u),w.forEach((e=>{f.set(e,l),l+=e.length}))):f=w[0]?new i(w[0]):new i,f}},this.flush=()=>{let e,r,o=0,f=0;const a=[];do{if(t.rt=0,t.tt=n,e=t.Ye(4),1!=e&&0!=e)throw new s("deflating: "+t.Le);n-t.tt>0&&a.push(c.slice(0,t.rt)),f+=t.rt}while(t.We>0||0===t.tt);return t.Qe(),r=new i(f),a.forEach((e=>{r.set(e,o),o+=e.length})),r}}tt.prototype={He(e,t){const n=this;return n.Fe=new et,t||(t=15),n.Fe.He(n,e,t)},Ye(e){const t=this;return t.Fe?t.Fe.Ye(t,e):Oe},Qe(){const e=this;if(!e.Fe)return Oe;const t=e.Fe.Qe();return e.Fe=null,t},Xe(e,t){const n=this;return n.Fe?n.Fe.Xe(n,e,t):Oe},Ze(e,t){const n=this;return n.Fe?n.Fe.Ze(n,e,t):Oe},je(e,t,n){const r=this;let s=r.We;return s>n&&(s=n),0===s?0:(r.We-=s,e.set(r.et.subarray(r.nt,r.nt+s),t),r.nt+=s,r.qe+=s,s)},Te(){const e=this;let t=e.Fe.pending;t>e.tt&&(t=e.tt),0!==t&&(e.$e.set(e.Fe.Ke.subarray(e.Fe.Je,e.Fe.Je+t),e.rt),e.rt+=t,e.Fe.Je+=t,e.Ge+=t,e.tt-=t,e.Fe.pending-=t,0===e.Fe.pending&&(e.Fe.Je=0))}};const rt=-2,st=-3,it=-5,ot=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535],ct=[96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,192,80,7,10,0,8,96,0,8,32,0,9,160,0,8,0,0,8,128,0,8,64,0,9,224,80,7,6,0,8,88,0,8,24,0,9,144,83,7,59,0,8,120,0,8,56,0,9,208,81,7,17,0,8,104,0,8,40,0,9,176,0,8,8,0,8,136,0,8,72,0,9,240,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,200,81,7,13,0,8,100,0,8,36,0,9,168,0,8,4,0,8,132,0,8,68,0,9,232,80,7,8,0,8,92,0,8,28,0,9,152,84,7,83,0,8,124,0,8,60,0,9,216,82,7,23,0,8,108,0,8,44,0,9,184,0,8,12,0,8,140,0,8,76,0,9,248,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,196,81,7,11,0,8,98,0,8,34,0,9,164,0,8,2,0,8,130,0,8,66,0,9,228,80,7,7,0,8,90,0,8,26,0,9,148,84,7,67,0,8,122,0,8,58,0,9,212,82,7,19,0,8,106,0,8,42,0,9,180,0,8,10,0,8,138,0,8,74,0,9,244,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,204,81,7,15,0,8,102,0,8,38,0,9,172,0,8,6,0,8,134,0,8,70,0,9,236,80,7,9,0,8,94,0,8,30,0,9,156,84,7,99,0,8,126,0,8,62,0,9,220,82,7,27,0,8,110,0,8,46,0,9,188,0,8,14,0,8,142,0,8,78,0,9,252,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,194,80,7,10,0,8,97,0,8,33,0,9,162,0,8,1,0,8,129,0,8,65,0,9,226,80,7,6,0,8,89,0,8,25,0,9,146,83,7,59,0,8,121,0,8,57,0,9,210,81,7,17,0,8,105,0,8,41,0,9,178,0,8,9,0,8,137,0,8,73,0,9,242,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,202,81,7,13,0,8,101,0,8,37,0,9,170,0,8,5,0,8,133,0,8,69,0,9,234,80,7,8,0,8,93,0,8,29,0,9,154,84,7,83,0,8,125,0,8,61,0,9,218,82,7,23,0,8,109,0,8,45,0,9,186,0,8,13,0,8,141,0,8,77,0,9,250,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,198,81,7,11,0,8,99,0,8,35,0,9,166,0,8,3,0,8,131,0,8,67,0,9,230,80,7,7,0,8,91,0,8,27,0,9,150,84,7,67,0,8,123,0,8,59,0,9,214,82,7,19,0,8,107,0,8,43,0,9,182,0,8,11,0,8,139,0,8,75,0,9,246,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,206,81,7,15,0,8,103,0,8,39,0,9,174,0,8,7,0,8,135,0,8,71,0,9,238,80,7,9,0,8,95,0,8,31,0,9,158,84,7,99,0,8,127,0,8,63,0,9,222,82,7,27,0,8,111,0,8,47,0,9,190,0,8,15,0,8,143,0,8,79,0,9,254,96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,193,80,7,10,0,8,96,0,8,32,0,9,161,0,8,0,0,8,128,0,8,64,0,9,225,80,7,6,0,8,88,0,8,24,0,9,145,83,7,59,0,8,120,0,8,56,0,9,209,81,7,17,0,8,104,0,8,40,0,9,177,0,8,8,0,8,136,0,8,72,0,9,241,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,201,81,7,13,0,8,100,0,8,36,0,9,169,0,8,4,0,8,132,0,8,68,0,9,233,80,7,8,0,8,92,0,8,28,0,9,153,84,7,83,0,8,124,0,8,60,0,9,217,82,7,23,0,8,108,0,8,44,0,9,185,0,8,12,0,8,140,0,8,76,0,9,249,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,197,81,7,11,0,8,98,0,8,34,0,9,165,0,8,2,0,8,130,0,8,66,0,9,229,80,7,7,0,8,90,0,8,26,0,9,149,84,7,67,0,8,122,0,8,58,0,9,213,82,7,19,0,8,106,0,8,42,0,9,181,0,8,10,0,8,138,0,8,74,0,9,245,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,205,81,7,15,0,8,102,0,8,38,0,9,173,0,8,6,0,8,134,0,8,70,0,9,237,80,7,9,0,8,94,0,8,30,0,9,157,84,7,99,0,8,126,0,8,62,0,9,221,82,7,27,0,8,110,0,8,46,0,9,189,0,8,14,0,8,142,0,8,78,0,9,253,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,195,80,7,10,0,8,97,0,8,33,0,9,163,0,8,1,0,8,129,0,8,65,0,9,227,80,7,6,0,8,89,0,8,25,0,9,147,83,7,59,0,8,121,0,8,57,0,9,211,81,7,17,0,8,105,0,8,41,0,9,179,0,8,9,0,8,137,0,8,73,0,9,243,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,203,81,7,13,0,8,101,0,8,37,0,9,171,0,8,5,0,8,133,0,8,69,0,9,235,80,7,8,0,8,93,0,8,29,0,9,155,84,7,83,0,8,125,0,8,61,0,9,219,82,7,23,0,8,109,0,8,45,0,9,187,0,8,13,0,8,141,0,8,77,0,9,251,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,199,81,7,11,0,8,99,0,8,35,0,9,167,0,8,3,0,8,131,0,8,67,0,9,231,80,7,7,0,8,91,0,8,27,0,9,151,84,7,67,0,8,123,0,8,59,0,9,215,82,7,19,0,8,107,0,8,43,0,9,183,0,8,11,0,8,139,0,8,75,0,9,247,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,207,81,7,15,0,8,103,0,8,39,0,9,175,0,8,7,0,8,135,0,8,71,0,9,239,80,7,9,0,8,95,0,8,31,0,9,159,84,7,99,0,8,127,0,8,63,0,9,223,82,7,27,0,8,111,0,8,47,0,9,191,0,8,15,0,8,143,0,8,79,0,9,255],ft=[80,5,1,87,5,257,83,5,17,91,5,4097,81,5,5,89,5,1025,85,5,65,93,5,16385,80,5,3,88,5,513,84,5,33,92,5,8193,82,5,9,90,5,2049,86,5,129,192,5,24577,80,5,2,87,5,385,83,5,25,91,5,6145,81,5,7,89,5,1537,85,5,97,93,5,24577,80,5,4,88,5,769,84,5,49,92,5,12289,82,5,13,90,5,3073,86,5,193,192,5,24577],at=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],lt=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,112,112],ut=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],wt=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];function ht(){let e,t,n,r,s,i;function o(e,t,o,c,f,a,l,u,w,h,d){let p,y,m,b,g,k,v,S,z,C,x,A,_,I,P;C=0,g=o;do{n[e[t+C]]++,C++,g--}while(0!==g);if(n[0]==o)return l[0]=-1,u[0]=0,0;for(S=u[0],k=1;15>=k&&0===n[k];k++);for(v=k,k>S&&(S=k),g=15;0!==g&&0===n[g];g--);for(m=g,S>g&&(S=g),u[0]=S,I=1<<k;g>k;k++,I<<=1)if(0>(I-=n[k]))return st;if(0>(I-=n[g]))return st;for(n[g]+=I,i[1]=k=0,C=1,_=2;0!=--g;)i[_]=k+=n[C],_++,C++;g=0,C=0;do{0!==(k=e[t+C])&&(d[i[k]++]=g),C++}while(++g<o);for(o=i[m],i[0]=g=0,C=0,b=-1,A=-S,s[0]=0,x=0,P=0;m>=v;v++)for(p=n[v];0!=p--;){for(;v>A+S;){if(b++,A+=S,P=m-A,P=P>S?S:P,(y=1<<(k=v-A))>p+1&&(y-=p+1,_=v,P>k))for(;++k<P&&(y<<=1)>n[++_];)y-=n[_];if(P=1<<k,h[0]+P>1440)return st;s[b]=x=h[0],h[0]+=P,0!==b?(i[b]=g,r[0]=k,r[1]=S,k=g>>>A-S,r[2]=x-s[b-1]-k,w.set(r,3*(s[b-1]+k))):l[0]=x}for(r[1]=v-A,o>C?d[C]<c?(r[0]=256>d[C]?0:96,r[2]=d[C++]):(r[0]=a[d[C]-c]+16+64,r[2]=f[d[C++]-c]):r[0]=192,y=1<<v-A,k=g>>>A;P>k;k+=y)w.set(r,3*(x+k));for(k=1<<v-1;g&k;k>>>=1)g^=k;for(g^=k,z=(1<<A)-1;(g&z)!=i[b];)b--,A-=S,z=(1<<A)-1}return 0!==I&&1!=m?it:0}function c(o){let c;for(e||(e=[],t=[],n=new f(16),r=[],s=new f(15),i=new f(16)),t.length<o&&(t=[]),c=0;o>c;c++)t[c]=0;for(c=0;16>c;c++)n[c]=0;for(c=0;3>c;c++)r[c]=0;s.set(n.subarray(0,15),0),i.set(n.subarray(0,16),0)}this.st=(n,r,s,i,f)=>{let a;return c(19),e[0]=0,a=o(n,0,19,19,null,null,s,r,i,e,t),a==st?f.Le="oversubscribed dynamic bit lengths tree":a!=it&&0!==r[0]||(f.Le="incomplete dynamic bit lengths tree",a=st),a},this.it=(n,r,s,i,f,a,l,u,w)=>{let h;return c(288),e[0]=0,h=o(s,0,n,257,at,lt,a,i,u,e,t),0!=h||0===i[0]?(h==st?w.Le="oversubscribed literal/length tree":-4!=h&&(w.Le="incomplete literal/length tree",h=st),h):(c(288),h=o(s,n,r,0,ut,wt,l,f,u,e,t),0!=h||0===f[0]&&n>257?(h==st?w.Le="oversubscribed distance tree":h==it?(w.Le="incomplete distance tree",h=st):-4!=h&&(w.Le="empty distance tree with lengths",h=st),h):0)}}function dt(){const e=this;let t,n,r,s,i=0,o=0,c=0,f=0,a=0,l=0,u=0,w=0,h=0,d=0;function p(e,t,n,r,s,i,o,c){let f,a,l,u,w,h,d,p,y,m,b,g,k,v,S,z;d=c.nt,p=c.We,w=o.ot,h=o.ct,y=o.write,m=y<o.read?o.read-y-1:o.end-y,b=ot[e],g=ot[t];do{for(;20>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;if(f=w&b,a=n,l=r,z=3*(l+f),0!==(u=a[z]))for(;;){if(w>>=a[z+1],h-=a[z+1],16&u){for(u&=15,k=a[z+2]+(w&ot[u]),w>>=u,h-=u;15>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;for(f=w&g,a=s,l=i,z=3*(l+f),u=a[z];;){if(w>>=a[z+1],h-=a[z+1],16&u){for(u&=15;u>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;if(v=a[z+2]+(w&ot[u]),w>>=u,h-=u,m-=k,v>y){S=y-v;do{S+=o.end}while(0>S);if(u=o.end-S,k>u){if(k-=u,y-S>0&&u>y-S)do{o.lt[y++]=o.lt[S++]}while(0!=--u);else o.lt.set(o.lt.subarray(S,S+u),y),y+=u,S+=u,u=0;S=0}}else S=y-v,y-S>0&&2>y-S?(o.lt[y++]=o.lt[S++],o.lt[y++]=o.lt[S++],k-=2):(o.lt.set(o.lt.subarray(S,S+2),y),y+=2,S+=2,k-=2);if(y-S>0&&k>y-S)do{o.lt[y++]=o.lt[S++]}while(0!=--k);else o.lt.set(o.lt.subarray(S,S+k),y),y+=k,S+=k,k=0;break}if(64&u)return c.Le="invalid distance code",k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,st;f+=a[z+2],f+=w&ot[u],z=3*(l+f),u=a[z]}break}if(64&u)return 32&u?(k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,1):(c.Le="invalid literal/length code",k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,st);if(f+=a[z+2],f+=w&ot[u],z=3*(l+f),0===(u=a[z])){w>>=a[z+1],h-=a[z+1],o.lt[y++]=a[z+2],m--;break}}else w>>=a[z+1],h-=a[z+1],o.lt[y++]=a[z+2],m--}while(m>=258&&p>=10);return k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,0}e.init=(e,i,o,c,f,a)=>{t=0,u=e,w=i,r=o,h=c,s=f,d=a,n=null},e.ut=(e,y,m)=>{let b,g,k,v,S,z,C,x=0,A=0,_=0;for(_=y.nt,v=y.We,x=e.ot,A=e.ct,S=e.write,z=S<e.read?e.read-S-1:e.end-S;;)switch(t){case 0:if(z>=258&&v>=10&&(e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,m=p(u,w,r,h,s,d,e,y),_=y.nt,v=y.We,x=e.ot,A=e.ct,S=e.write,z=S<e.read?e.read-S-1:e.end-S,0!=m)){t=1==m?7:9;break}c=u,n=r,o=h,t=1;case 1:for(b=c;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}if(g=3*(o+(x&ot[b])),x>>>=n[g+1],A-=n[g+1],k=n[g],0===k){f=n[g+2],t=6;break}if(16&k){a=15&k,i=n[g+2],t=2;break}if(!(64&k)){c=k,o=g/3+n[g+2];break}if(32&k){t=7;break}return t=9,y.Le="invalid literal/length code",m=st,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);case 2:for(b=a;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}i+=x&ot[b],x>>=b,A-=b,c=w,n=s,o=d,t=3;case 3:for(b=c;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}if(g=3*(o+(x&ot[b])),x>>=n[g+1],A-=n[g+1],k=n[g],16&k){a=15&k,l=n[g+2],t=4;break}if(!(64&k)){c=k,o=g/3+n[g+2];break}return t=9,y.Le="invalid distance code",m=st,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);case 4:for(b=a;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}l+=x&ot[b],x>>=b,A-=b,t=5;case 5:for(C=S-l;0>C;)C+=e.end;for(;0!==i;){if(0===z&&(S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z&&(e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z)))return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);e.lt[S++]=e.lt[C++],z--,C==e.end&&(C=0),i--}t=0;break;case 6:if(0===z&&(S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z&&(e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z)))return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,e.lt[S++]=f,z--,t=0;break;case 7:if(A>7&&(A-=8,v++,_--),e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,e.read!=e.write)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);t=8;case 8:return m=1,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);case 9:return m=st,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);default:return m=rt,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m)}},e.ht=()=>{}}ht.dt=(e,t,n,r)=>(e[0]=9,t[0]=5,n[0]=ct,r[0]=ft,0);const pt=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function yt(e,t){const n=this;let r,s=0,o=0,c=0,a=0;const l=[0],u=[0],w=new dt;let h=0,d=new f(4320);const p=new ht;n.ct=0,n.ot=0,n.lt=new i(t),n.end=t,n.read=0,n.write=0,n.reset=(e,t)=>{t&&(t[0]=0),6==s&&w.ht(e),s=0,n.ct=0,n.ot=0,n.read=n.write=0},n.reset(e,null),n.wt=(e,t)=>{let r,s,i;return s=e.rt,i=n.read,r=(i>n.write?n.end:n.write)-i,r>e.tt&&(r=e.tt),0!==r&&t==it&&(t=0),e.tt-=r,e.Ge+=r,e.$e.set(n.lt.subarray(i,i+r),s),s+=r,i+=r,i==n.end&&(i=0,n.write==n.end&&(n.write=0),r=n.write-i,r>e.tt&&(r=e.tt),0!==r&&t==it&&(t=0),e.tt-=r,e.Ge+=r,e.$e.set(n.lt.subarray(i,i+r),s),s+=r,i+=r),e.rt=s,n.read=i,t},n.ut=(e,t)=>{let i,f,y,m,b,g,k,v;for(m=e.nt,b=e.We,f=n.ot,y=n.ct,g=n.write,k=g<n.read?n.read-g-1:n.end-g;;){let S,z,C,x,A,_,I,P;switch(s){case 0:for(;3>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}switch(i=7&f,h=1&i,i>>>1){case 0:f>>>=3,y-=3,i=7&y,f>>>=i,y-=i,s=1;break;case 1:S=[],z=[],C=[[]],x=[[]],ht.dt(S,z,C,x),w.init(S[0],z[0],C[0],0,x[0],0),f>>>=3,y-=3,s=6;break;case 2:f>>>=3,y-=3,s=3;break;case 3:return f>>>=3,y-=3,s=9,e.Le="invalid block type",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t)}break;case 1:for(;32>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if((~f>>>16&65535)!=(65535&f))return s=9,e.Le="invalid stored block lengths",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);o=65535&f,f=y=0,s=0!==o?2:0!==h?7:0;break;case 2:if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(0===k&&(g==n.end&&0!==n.read&&(g=0,k=g<n.read?n.read-g-1:n.end-g),0===k&&(n.write=g,t=n.wt(e,t),g=n.write,k=g<n.read?n.read-g-1:n.end-g,g==n.end&&0!==n.read&&(g=0,k=g<n.read?n.read-g-1:n.end-g),0===k)))return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(t=0,i=o,i>b&&(i=b),i>k&&(i=k),n.lt.set(e.je(m,i),g),m+=i,b-=i,g+=i,k-=i,0!=(o-=i))break;s=0!==h?7:0;break;case 3:for(;14>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(c=i=16383&f,(31&i)>29||(i>>5&31)>29)return s=9,e.Le="too many length or distance symbols",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(i=258+(31&i)+(i>>5&31),!r||r.length<i)r=[];else for(v=0;i>v;v++)r[v]=0;f>>>=14,y-=14,a=0,s=4;case 4:for(;4+(c>>>10)>a;){for(;3>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}r[pt[a++]]=7&f,f>>>=3,y-=3}for(;19>a;)r[pt[a++]]=0;if(l[0]=7,i=p.st(r,l,u,d,e),0!=i)return(t=i)==st&&(r=null,s=9),n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);a=0,s=5;case 5:for(;i=c,258+(31&i)+(i>>5&31)>a;){let o,w;for(i=l[0];i>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(i=d[3*(u[0]+(f&ot[i]))+1],w=d[3*(u[0]+(f&ot[i]))+2],16>w)f>>>=i,y-=i,r[a++]=w;else{for(v=18==w?7:w-14,o=18==w?11:3;i+v>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(f>>>=i,y-=i,o+=f&ot[v],f>>>=v,y-=v,v=a,i=c,v+o>258+(31&i)+(i>>5&31)||16==w&&1>v)return r=null,s=9,e.Le="invalid bit length repeat",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);w=16==w?r[v-1]:0;do{r[v++]=w}while(0!=--o);a=v}}if(u[0]=-1,A=[],_=[],I=[],P=[],A[0]=9,_[0]=6,i=c,i=p.it(257+(31&i),1+(i>>5&31),r,A,_,I,P,d,e),0!=i)return i==st&&(r=null,s=9),t=i,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);w.init(A[0],_[0],d,I[0],d,P[0]),s=6;case 6:if(n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,1!=(t=w.ut(n,e,t)))return n.wt(e,t);if(t=0,w.ht(e),m=e.nt,b=e.We,f=n.ot,y=n.ct,g=n.write,k=g<n.read?n.read-g-1:n.end-g,0===h){s=0;break}s=7;case 7:if(n.write=g,t=n.wt(e,t),g=n.write,k=g<n.read?n.read-g-1:n.end-g,n.read!=n.write)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);s=8;case 8:return t=1,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);case 9:return t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);default:return t=rt,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t)}}},n.ht=e=>{n.reset(e,null),n.lt=null,d=null},n.yt=(e,t,r)=>{n.lt.set(e.subarray(t,t+r),0),n.read=n.write=r},n.bt=()=>1==s?1:0}const mt=13,bt=[0,0,255,255];function gt(){const e=this;function t(e){return e&&e.gt?(e.qe=e.Ge=0,e.Le=null,e.gt.mode=7,e.gt.kt.reset(e,null),0):rt}e.mode=0,e.method=0,e.vt=[0],e.St=0,e.marker=0,e.zt=0,e.Ct=t=>(e.kt&&e.kt.ht(t),e.kt=null,0),e.xt=(n,r)=>(n.Le=null,e.kt=null,8>r||r>15?(e.Ct(n),rt):(e.zt=r,n.gt.kt=new yt(n,1<<r),t(n),0)),e.At=(e,t)=>{let n,r;if(!e||!e.gt||!e.et)return rt;const s=e.gt;for(t=4==t?it:0,n=it;;)switch(s.mode){case 0:if(0===e.We)return n;if(n=t,e.We--,e.qe++,8!=(15&(s.method=e.ft(e.nt++)))){s.mode=mt,e.Le="unknown compression method",s.marker=5;break}if(8+(s.method>>4)>s.zt){s.mode=mt,e.Le="invalid win size",s.marker=5;break}s.mode=1;case 1:if(0===e.We)return n;if(n=t,e.We--,e.qe++,r=255&e.ft(e.nt++),((s.method<<8)+r)%31!=0){s.mode=mt,e.Le="incorrect header check",s.marker=5;break}if(!(32&r)){s.mode=7;break}s.mode=2;case 2:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St=(255&e.ft(e.nt++))<<24&4278190080,s.mode=3;case 3:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St+=(255&e.ft(e.nt++))<<16&16711680,s.mode=4;case 4:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St+=(255&e.ft(e.nt++))<<8&65280,s.mode=5;case 5:return 0===e.We?n:(n=t,e.We--,e.qe++,s.St+=255&e.ft(e.nt++),s.mode=6,2);case 6:return s.mode=mt,e.Le="need dictionary",s.marker=0,rt;case 7:if(n=s.kt.ut(e,n),n==st){s.mode=mt,s.marker=0;break}if(0==n&&(n=t),1!=n)return n;n=t,s.kt.reset(e,s.vt),s.mode=12;case 12:return e.We=0,1;case mt:return st;default:return rt}},e._t=(e,t,n)=>{let r=0,s=n;if(!e||!e.gt||6!=e.gt.mode)return rt;const i=e.gt;return s<1<<i.zt||(s=(1<<i.zt)-1,r=n-s),i.kt.yt(t,r,s),i.mode=7,0},e.It=e=>{let n,r,s,i,o;if(!e||!e.gt)return rt;const c=e.gt;if(c.mode!=mt&&(c.mode=mt,c.marker=0),0===(n=e.We))return it;for(r=e.nt,s=c.marker;0!==n&&4>s;)e.ft(r)==bt[s]?s++:s=0!==e.ft(r)?0:4-s,r++,n--;return e.qe+=r-e.nt,e.nt=r,e.We=n,c.marker=s,4!=s?st:(i=e.qe,o=e.Ge,t(e),e.qe=i,e.Ge=o,c.mode=7,0)},e.Pt=e=>e&&e.gt&&e.gt.kt?e.gt.kt.bt():rt}function kt(){}function vt(e){const t=new kt,n=e&&e.chunkSize?r.floor(2*e.chunkSize):131072,o=new i(n);let c=!1;t.xt(),t.$e=o,this.append=(e,r)=>{const f=[];let a,l,u=0,w=0,h=0;if(0!==e.length){t.nt=0,t.et=e,t.We=e.length;do{if(t.rt=0,t.tt=n,0!==t.We||c||(t.nt=0,c=!0),a=t.At(0),c&&a===it){if(0!==t.We)throw new s("inflating: bad input")}else if(0!==a&&1!==a)throw new s("inflating: "+t.Le);if((c||1===a)&&t.We===e.length)throw new s("inflating: bad input");t.rt&&(t.rt===n?f.push(new i(o)):f.push(o.subarray(0,t.rt))),h+=t.rt,r&&t.nt>0&&t.nt!=u&&(r(t.nt),u=t.nt)}while(t.We>0||0===t.tt);return f.length>1?(l=new i(h),f.forEach((e=>{l.set(e,w),w+=e.length}))):l=f[0]?new i(f[0]):new i,l}},this.flush=()=>{t.Ct()}}kt.prototype={xt(e){const t=this;return t.gt=new gt,e||(e=15),t.gt.xt(t,e)},At(e){const t=this;return t.gt?t.gt.At(t,e):rt},Ct(){const e=this;if(!e.gt)return rt;const t=e.gt.Ct(e);return e.gt=null,t},It(){const e=this;return e.gt?e.gt.It(e):rt},_t(e,t){const n=this;return n.gt?n.gt._t(n,e,t):rt},ft(e){return this.et[e]},je(e,t){return this.et.subarray(e,e+t)}},self.initCodec=()=>{self.Deflate=nt,self.Inflate=vt};
`, r = () => t.useDataURI ? "data:text/javascript," + encodeURIComponent(e) : URL.createObjectURL(new Blob([e], { type: "text/javascript" }));
  n({ workerScripts: { inflate: [r], deflate: [r] } });
}
const Za = "Writer iterator completed too soon", Ka = "Content-Type", Xa = 64 * 1024, gi = "writable";
class Pn {
  constructor() {
    this.size = 0;
  }
  init() {
    this.initialized = !0;
  }
}
class bi extends Pn {
  get readable() {
    const t = this, { chunkSize: e = Xa } = t, r = new ReadableStream({
      start() {
        this.chunkOffset = 0;
      },
      async pull(a) {
        const { offset: o = 0, size: c, diskNumberStart: l } = r, { chunkOffset: u } = this;
        a.enqueue(await _e(t, o + u, Math.min(e, c - u), l)), u + e > c ? a.close() : this.chunkOffset += e;
      }
    });
    return r;
  }
}
class En extends bi {
  constructor(t) {
    super(), Object.assign(this, {
      blob: t,
      size: t.size
    });
  }
  async readUint8Array(t, e) {
    const r = this, a = t + e;
    let c = await (t || a < r.size ? r.blob.slice(t, a) : r.blob).arrayBuffer();
    return c.byteLength > e && (c = c.slice(t, a)), new Uint8Array(c);
  }
}
class $a extends Pn {
  constructor(t) {
    super();
    const e = this, r = new TransformStream(), a = [];
    t && a.push([Ka, t]), Object.defineProperty(e, gi, {
      get() {
        return r.writable;
      }
    }), e.blob = new Response(r.readable, { headers: a }).blob();
  }
  getData() {
    return this.blob;
  }
}
class Ja extends bi {
  constructor(t) {
    super(), this.readers = t;
  }
  async init() {
    const t = this, { readers: e } = t;
    t.lastDiskNumber = 0, t.lastDiskOffset = 0, await Promise.all(e.map(async (r, a) => {
      await r.init(), a != e.length - 1 && (t.lastDiskOffset += r.size), t.size += r.size;
    })), super.init();
  }
  async readUint8Array(t, e, r = 0) {
    const a = this, { readers: o } = this;
    let c, l = r;
    l == -1 && (l = o.length - 1);
    let u = t;
    for (; u >= o[l].size; )
      u -= o[l].size, l++;
    const g = o[l], x = g.size;
    if (u + e <= x)
      c = await _e(g, u, e);
    else {
      const w = x - u;
      c = new Uint8Array(e), c.set(await _e(g, u, w)), c.set(await a.readUint8Array(t + w, e - w, r), w);
    }
    return a.lastDiskNumber = Math.max(l, a.lastDiskNumber), c;
  }
}
class Ur extends Pn {
  constructor(t, e = 4294967295) {
    super();
    const r = this;
    Object.assign(r, {
      diskNumber: 0,
      diskOffset: 0,
      size: 0,
      maxSize: e,
      availableSize: e
    });
    let a, o, c;
    const l = new WritableStream({
      async write(x) {
        const { availableSize: w } = r;
        if (c)
          x.length >= w ? (await u(x.slice(0, w)), await g(), r.diskOffset += a.size, r.diskNumber++, c = null, await this.write(x.slice(w))) : await u(x);
        else {
          const { value: _, done: A } = await t.next();
          if (A && !_)
            throw new Error(Za);
          a = _, a.size = 0, a.maxSize && (r.maxSize = a.maxSize), r.availableSize = r.maxSize, await Xt(a), o = _.writable, c = o.getWriter(), await this.write(x);
        }
      },
      async close() {
        await c.ready, await g();
      }
    });
    Object.defineProperty(r, gi, {
      get() {
        return l;
      }
    });
    async function u(x) {
      const w = x.length;
      w && (await c.ready, await c.write(x), a.size += w, r.size += w, r.availableSize -= w);
    }
    async function g() {
      o.size = a.size, await c.close();
    }
  }
}
async function Xt(n, t) {
  if (n.init && !n.initialized)
    await n.init(t);
  else
    return Promise.resolve();
}
function za(n) {
  return Array.isArray(n) && (n = new Ja(n)), n instanceof ReadableStream && (n = {
    readable: n
  }), n;
}
function Qa(n) {
  n.writable === ve && typeof n.next == kt && (n = new Ur(n)), n instanceof WritableStream && (n = {
    writable: n
  });
  const { writable: t } = n;
  return t.size === ve && (t.size = 0), n instanceof Ur || Object.assign(n, {
    diskNumber: 0,
    diskOffset: 0,
    availableSize: 1 / 0,
    maxSize: 1 / 0
  }), n;
}
function _e(n, t, e, r) {
  return n.readUint8Array(t, e, r);
}
const yi = "\0 !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ ".split(""), eo = yi.length == 256;
function to(n) {
  if (eo) {
    let t = "";
    for (let e = 0; e < n.length; e++)
      t += yi[n[e]];
    return t;
  } else
    return new TextDecoder().decode(n);
}
function jt(n, t) {
  return t && t.trim().toLowerCase() == "cp437" ? to(n) : new TextDecoder(t).decode(n);
}
const vi = "filename", Ei = "rawFilename", ki = "comment", Si = "rawComment", Ai = "uncompressedSize", Ti = "compressedSize", Fi = "offset", kn = "diskNumberStart", Sn = "lastModDate", An = "rawLastModDate", Ri = "lastAccessDate", no = "rawLastAccessDate", Ci = "creationDate", ro = "rawCreationDate", io = "internalFileAttribute", so = "internalFileAttributes", ao = "externalFileAttribute", oo = "externalFileAttributes", co = "msDosCompatible", lo = "zip64", fo = "encrypted", uo = "version", po = "versionMadeBy", mo = "zipCrypto", ho = "directory", xo = "executable", wo = [
  vi,
  Ei,
  Ti,
  Ai,
  Sn,
  An,
  ki,
  Si,
  Ri,
  Ci,
  Fi,
  kn,
  kn,
  io,
  so,
  ao,
  oo,
  co,
  lo,
  fo,
  uo,
  po,
  mo,
  ho,
  xo,
  "bitFlag",
  "signature",
  "filenameUTF8",
  "commentUTF8",
  "compressionMethod",
  "extraField",
  "rawExtraField",
  "extraFieldZip64",
  "extraFieldUnicodePath",
  "extraFieldUnicodeComment",
  "extraFieldAES",
  "extraFieldNTFS",
  "extraFieldExtendedTimestamp"
];
class Or {
  constructor(t) {
    wo.forEach((e) => this[e] = t[e]);
  }
}
const wn = "File format is not recognized", _o = "End of central directory not found", go = "End of Zip64 central directory locator not found", bo = "Central directory header not found", yo = "Local file header not found", vo = "Zip64 extra field not found", Eo = "File contains encrypted entry", ko = "Encryption method not supported", Pr = "Compression method not supported", Br = "Split zip file", Nr = "utf-8", Mr = "cp437", So = [
  [Ai, nt],
  [Ti, nt],
  [Fi, nt],
  [kn, Ke]
], Ao = {
  [Ke]: {
    getValue: ce,
    bytes: 4
  },
  [nt]: {
    getValue: Ht,
    bytes: 8
  }
};
class Wr {
  constructor(t, e = {}) {
    Object.assign(this, {
      reader: za(t),
      options: e,
      config: sa()
    });
  }
  async *getEntriesGenerator(t = {}) {
    const e = this;
    let { reader: r } = e;
    const { config: a } = e;
    if (await Xt(r), (r.size === ve || !r.readUint8Array) && (r = new En(await new Response(r.readable).blob()), await Xt(r)), r.size < ct)
      throw new Error(wn);
    r.chunkSize = aa(a);
    const o = await Do(r, Vs, r.size, ct, Ke * 16);
    if (!o) {
      const v = await _e(r, 0, 4), k = he(v);
      throw ce(k) == Gs ? new Error(Br) : new Error(_o);
    }
    const c = he(o);
    let l = ce(c, 12), u = ce(c, 16);
    const g = o.offset, x = me(c, 20), w = g + ct + x;
    let _ = me(c, 4);
    const A = r.lastDiskNumber || 0;
    let P = me(c, 6), h = me(c, 8), p = 0, m = 0;
    if (u == nt || l == nt || h == Ke || P == Ke) {
      const v = await _e(r, o.offset - un, un), k = he(v);
      if (ce(k, 0) == Zs) {
        u = Ht(k, 8);
        let W = await _e(r, u, dn, -1), O = he(W);
        const Z = o.offset - un - dn;
        if (ce(O, 0) != pr && u != Z) {
          const H = u;
          u = Z, p = u - H, W = await _e(r, u, dn, -1), O = he(W);
        }
        if (ce(O, 0) != pr)
          throw new Error(go);
        _ == Ke && (_ = ce(O, 16)), P == Ke && (P = ce(O, 20)), h == Ke && (h = Ht(O, 32)), l == nt && (l = Ht(O, 40)), u -= l;
      }
    }
    if (u >= r.size && (p = r.size - u - l - ct, u = r.size - l - ct), A != _)
      throw new Error(Br);
    if (u < 0)
      throw new Error(wn);
    let E = 0, R = await _e(r, u, l, P), D = he(R);
    if (l) {
      const v = o.offset - l;
      if (ce(D, E) != dr && u != v) {
        const k = u;
        u = v, p += u - k, R = await _e(r, u, l, P), D = he(R);
      }
    }
    const S = o.offset - u - (r.lastDiskOffset || 0);
    if (l != S && S >= 0 && (l = S, R = await _e(r, u, l, P), D = he(R)), u < 0 || u >= r.size)
      throw new Error(wn);
    const T = be(e, t, "filenameEncoding"), F = be(e, t, "commentEncoding");
    for (let v = 0; v < h; v++) {
      const k = new To(r, a, e.options);
      if (ce(D, E) != dr)
        throw new Error(bo);
      Ii(k, D, E + 6);
      const W = !!k.bitFlag.languageEncodingFlag, O = E + 46, Z = O + k.filenameLength, H = Z + k.extraFieldLength, j = me(D, E + 4), K = j >> 8 == 0, X = j >> 8 == 3, oe = R.subarray(O, Z), G = me(D, E + 32), z = H + G, Y = R.subarray(H, z), ee = W, Ce = W, de = ce(D, E + 38), le = K && (dt(D, E + 38) & wr) == wr || X && (de >> 16 & _r) == _r || oe.length && oe[oe.length - 1] == br.charCodeAt(0), pt = X && (de >> 16 & gr) == gr, Me = ce(D, E + 42) + p;
      Object.assign(k, {
        versionMadeBy: j,
        msDosCompatible: K,
        compressedSize: 0,
        uncompressedSize: 0,
        commentLength: G,
        directory: le,
        offset: Me,
        diskNumberStart: me(D, E + 34),
        internalFileAttributes: me(D, E + 36),
        externalFileAttributes: de,
        rawFilename: oe,
        filenameUTF8: ee,
        commentUTF8: Ce,
        rawExtraField: R.subarray(Z, H),
        executable: pt
      }), k.internalFileAttribute = k.internalFileAttributes, k.externalFileAttribute = k.externalFileAttributes;
      const it = be(e, t, "decodeText") || jt, Je = ee ? Nr : T || Mr, ze = Ce ? Nr : F || Mr;
      let we = it(oe, Je);
      we === ve && (we = jt(oe, Je));
      let fe = it(Y, ze);
      fe === ve && (fe = jt(Y, ze)), Object.assign(k, {
        rawComment: Y,
        filename: we,
        comment: fe,
        directory: le || we.endsWith(br)
      }), m = Math.max(Me, m), Di(k, k, D, E + 6), k.zipCrypto = k.encrypted && !k.extraFieldAES;
      const We = new Or(k);
      We.getData = (f, i) => k.getData(f, We, i), E = z;
      const { onprogress: ue } = t;
      if (ue)
        try {
          await ue(v + 1, h, new Or(k));
        } catch {
        }
      yield We;
    }
    const b = be(e, t, "extractPrependedData"), I = be(e, t, "extractAppendedData");
    return b && (e.prependedData = m > 0 ? await _e(r, 0, m) : new Uint8Array()), e.comment = x ? await _e(r, g + ct, x) : new Uint8Array(), I && (e.appendedData = w < r.size ? await _e(r, w, r.size - w) : new Uint8Array()), !0;
  }
  async getEntries(t = {}) {
    const e = [];
    for await (const r of this.getEntriesGenerator(t))
      e.push(r);
    return e;
  }
  async close() {
  }
}
class To {
  constructor(t, e, r) {
    Object.assign(this, {
      reader: t,
      config: e,
      options: r
    });
  }
  async getData(t, e, r = {}) {
    const a = this, {
      reader: o,
      offset: c,
      diskNumberStart: l,
      extraFieldAES: u,
      compressionMethod: g,
      config: x,
      bitFlag: w,
      signature: _,
      rawLastModDate: A,
      uncompressedSize: P,
      compressedSize: h
    } = a, p = e.localDirectory = {}, m = await _e(o, c, 30, l), E = he(m);
    let R = be(a, r, "password"), D = be(a, r, "rawPassword");
    const S = be(a, r, "passThrough");
    if (R = R && R.length && R, D = D && D.length && D, u && u.originalCompressionMethod != Hs)
      throw new Error(Pr);
    if (g != js && g != qs && !S)
      throw new Error(Pr);
    if (ce(E, 0) != Ys)
      throw new Error(yo);
    Ii(p, E, 4), p.rawExtraField = p.extraFieldLength ? await _e(o, c + 30 + p.filenameLength, p.extraFieldLength, l) : new Uint8Array(), Di(a, p, E, 4, !0), Object.assign(e, {
      lastAccessDate: p.lastAccessDate,
      creationDate: p.creationDate
    });
    const T = a.encrypted && p.encrypted && !S, F = T && !u;
    if (S || (e.zipCrypto = F), T) {
      if (!F && u.strength === ve)
        throw new Error(ko);
      if (!R && !D)
        throw new Error(Eo);
    }
    const b = c + 30 + p.filenameLength + p.extraFieldLength, I = h, v = o.readable;
    Object.assign(v, {
      diskNumberStart: l,
      offset: b,
      size: I
    });
    const k = be(a, r, "signal"), W = be(a, r, "checkPasswordOnly");
    W && (t = new WritableStream()), t = Qa(t), await Xt(t, S ? h : P);
    const { writable: O } = t, { onstart: Z, onprogress: H, onend: j } = r, K = {
      options: {
        codecType: xi,
        password: R,
        rawPassword: D,
        zipCrypto: F,
        encryptionStrength: u && u.strength,
        signed: be(a, r, "checkSignature") && !S,
        passwordVerification: F && (w.dataDescriptor ? A >>> 8 & 255 : _ >>> 24 & 255),
        signature: _,
        compressed: g != 0 && !S,
        encrypted: a.encrypted && !S,
        useWebWorkers: be(a, r, "useWebWorkers"),
        useCompressionStream: be(a, r, "useCompressionStream"),
        transferStreams: be(a, r, "transferStreams"),
        checkPasswordOnly: W
      },
      config: x,
      streamOptions: { signal: k, size: I, onstart: Z, onprogress: H, onend: j }
    };
    let X = 0;
    try {
      ({ outputSize: X } = await Ya({ readable: v, writable: O }, K));
    } catch (oe) {
      if (!W || oe.message != Ln)
        throw oe;
    } finally {
      const oe = be(a, r, "preventClose");
      O.size += X, !oe && !O.locked && await O.getWriter().close();
    }
    return W ? ve : t.getData ? t.getData() : O;
  }
}
function Ii(n, t, e) {
  const r = n.rawBitFlag = me(t, e + 2), a = (r & mr) == mr, o = ce(t, e + 6);
  Object.assign(n, {
    encrypted: a,
    version: me(t, e),
    bitFlag: {
      level: (r & na) >> 1,
      dataDescriptor: (r & hr) == hr,
      languageEncodingFlag: (r & xr) == xr
    },
    rawLastModDate: o,
    lastModDate: Lo(o),
    filenameLength: me(t, e + 22),
    extraFieldLength: me(t, e + 24)
  });
}
function Di(n, t, e, r, a) {
  const { rawExtraField: o } = t, c = t.extraField = /* @__PURE__ */ new Map(), l = he(new Uint8Array(o));
  let u = 0;
  try {
    for (; u < o.length; ) {
      const m = me(l, u), E = me(l, u + 2);
      c.set(m, {
        type: m,
        data: o.slice(u + 4, u + 4 + E)
      }), u += 4 + E;
    }
  } catch {
  }
  const g = me(e, r + 4);
  Object.assign(t, {
    signature: ce(e, r + 10),
    uncompressedSize: ce(e, r + 18),
    compressedSize: ce(e, r + 14)
  });
  const x = c.get(Ks);
  x && (Fo(x, t), t.extraFieldZip64 = x);
  const w = c.get(Qs);
  w && (qr(w, vi, Ei, t, n), t.extraFieldUnicodePath = w);
  const _ = c.get(ea);
  _ && (qr(_, ki, Si, t, n), t.extraFieldUnicodeComment = _);
  const A = c.get(Xs);
  A ? (Ro(A, t, g), t.extraFieldAES = A) : t.compressionMethod = g;
  const P = c.get($s);
  P && (Co(P, t), t.extraFieldNTFS = P);
  const h = c.get(zs);
  h && (Io(h, t, a), t.extraFieldExtendedTimestamp = h);
  const p = c.get(ta);
  p && (t.extraFieldUSDZ = p);
}
function Fo(n, t) {
  t.zip64 = !0;
  const e = he(n.data), r = So.filter(([a, o]) => t[a] == o);
  for (let a = 0, o = 0; a < r.length; a++) {
    const [c, l] = r[a];
    if (t[c] == l) {
      const u = Ao[l];
      t[c] = n[c] = u.getValue(e, o), o += u.bytes;
    } else if (n[c])
      throw new Error(vo);
  }
}
function qr(n, t, e, r, a) {
  const o = he(n.data), c = new Zt();
  c.append(a[e]);
  const l = he(new Uint8Array(4));
  l.setUint32(0, c.get(), !0);
  const u = ce(o, 1);
  Object.assign(n, {
    version: dt(o, 0),
    [t]: jt(n.data.subarray(5)),
    valid: !a.bitFlag.languageEncodingFlag && u == ce(l, 0)
  }), n.valid && (r[t] = n[t], r[t + "UTF8"] = !0);
}
function Ro(n, t, e) {
  const r = he(n.data), a = dt(r, 4);
  Object.assign(n, {
    vendorVersion: dt(r, 0),
    vendorId: dt(r, 2),
    strength: a,
    originalCompressionMethod: e,
    compressionMethod: me(r, 5)
  }), t.compressionMethod = n.compressionMethod;
}
function Co(n, t) {
  const e = he(n.data);
  let r = 4, a;
  try {
    for (; r < n.data.length && !a; ) {
      const o = me(e, r), c = me(e, r + 2);
      o == Js && (a = n.data.slice(r + 4, r + 4 + c)), r += 4 + c;
    }
  } catch {
  }
  try {
    if (a && a.length == 24) {
      const o = he(a), c = o.getBigUint64(0, !0), l = o.getBigUint64(8, !0), u = o.getBigUint64(16, !0);
      Object.assign(n, {
        rawLastModDate: c,
        rawLastAccessDate: l,
        rawCreationDate: u
      });
      const g = _n(c), x = _n(l), w = _n(u), _ = { lastModDate: g, lastAccessDate: x, creationDate: w };
      Object.assign(n, _), Object.assign(t, _);
    }
  } catch {
  }
}
function Io(n, t, e) {
  const r = he(n.data), a = dt(r, 0), o = [], c = [];
  e ? ((a & 1) == 1 && (o.push(Sn), c.push(An)), (a & 2) == 2 && (o.push(Ri), c.push(no)), (a & 4) == 4 && (o.push(Ci), c.push(ro))) : n.data.length >= 5 && (o.push(Sn), c.push(An));
  let l = 1;
  o.forEach((u, g) => {
    if (n.data.length >= l + 4) {
      const x = ce(r, l);
      t[u] = n[u] = new Date(x * 1e3);
      const w = c[g];
      n[w] = x;
    }
    l += 4;
  });
}
async function Do(n, t, e, r, a) {
  const o = new Uint8Array(4), c = he(o);
  Uo(c, 0, t);
  const l = r + a;
  return await u(r) || await u(Math.min(l, e));
  async function u(g) {
    const x = e - g, w = await _e(n, x, g);
    for (let _ = w.length - r; _ >= 0; _--)
      if (w[_] == o[0] && w[_ + 1] == o[1] && w[_ + 2] == o[2] && w[_ + 3] == o[3])
        return {
          offset: x + _,
          buffer: w.slice(_, _ + r).buffer
        };
  }
}
function be(n, t, e) {
  return t[e] === ve ? n.options[e] : t[e];
}
function Lo(n) {
  const t = (n & 4294901760) >> 16, e = n & 65535;
  try {
    return new Date(1980 + ((t & 65024) >> 9), ((t & 480) >> 5) - 1, t & 31, (e & 63488) >> 11, (e & 2016) >> 5, (e & 31) * 2, 0);
  } catch {
  }
}
function _n(n) {
  return new Date(Number(n / BigInt(1e4) - BigInt(116444736e5)));
}
function dt(n, t) {
  return n.getUint8(t);
}
function me(n, t) {
  return n.getUint16(t, !0);
}
function ce(n, t) {
  return n.getUint32(t, !0);
}
function Ht(n, t) {
  return Number(n.getBigUint64(t, !0));
}
function Uo(n, t, e) {
  n.setUint32(t, e, !0);
}
function he(n) {
  return new DataView(n.buffer);
}
let Li;
try {
  Li = import.meta.url;
} catch {
}
Dn({ baseURL: Li });
Va(Dn);
Dn({ Deflate: gs, Inflate: Ws });
class Oo {
  constructor(t) {
    this.fileTree = t;
  }
  async read(t) {
    let e = this.getEntryAtPath(t);
    if (typeof e == "string")
      e = new TextEncoder().encode(e);
    else if (!(e instanceof Uint8Array))
      throw new Error(`Unsupported content type: ${typeof e}`);
    const r = new ReadableStream({
      start(a) {
        a.enqueue(e), a.close();
      }
    });
    return new Yt(r, t, {
      filesize: e.byteLength
    });
  }
  getEntryAtPath(t) {
    let e = t.replace(/^\//, ""), r = this.fileTree;
    for (; e; ) {
      if (r[e])
        return r[e];
      const a = e.split("/"), o = a.shift();
      if (!o || !r[o])
        break;
      r = r[o], e = a.join("/");
    }
    throw new Error(`File not found at ${t}`);
  }
}
class $t {
  constructor(t) {
    this.entries = /* @__PURE__ */ new Map(), this.zipReader = t;
  }
  static fromStream(t) {
    const e = new Wr(
      new En(new Yt(t, "archive.zip"))
    );
    return new $t(e);
  }
  static fromArrayBuffer(t) {
    const e = new Wr(
      new En(new Blob([t]))
    );
    return new $t(e);
  }
  async read(t) {
    const e = await this.getEntry(t), r = await e.getData(new $a());
    return new Yt(r.stream(), t, {
      filesize: e.uncompressedSize
    });
  }
  async getEntry(t) {
    const r = (await this.getEntries()).get(t.replace(/^\//, ""));
    if (!r)
      throw new Error(`File ${t} not found in the zip.`);
    return r;
  }
  async getEntries() {
    if (this.entries.size === 0) {
      const t = await this.zipReader.getEntries();
      for (const e of t)
        this.entries.set(e.filename, e);
    }
    return this.entries;
  }
}
class Po {
  /**
   * Creates a new OverlayFilesystem.
   *
   * @param filesystems An array of Filesystem instances to cascade through.
   *                    The order determines the priority - earlier filesystems
   *                    are checked first.
   */
  constructor(t) {
    if (!t.length)
      throw new Error(
        "OverlayFilesystem requires at least one filesystem"
      );
    this.filesystems = t;
  }
  /**
   * Reads a file by trying each filesystem in order until one succeeds.
   *
   * @param path The path to the file to read.
   * @returns A Promise that resolves to a StreamedFile from the first
   *          filesystem that successfully resolves the path.
   * @throws Error if all filesystems fail to resolve the path.
   */
  async read(t) {
    const e = [];
    for (const a of this.filesystems)
      try {
        return await a.read(t);
      } catch (o) {
        e.push(
          o instanceof Error ? o : new Error(String(o))
        );
      }
    const r = e.map((a) => a.message).join("; ");
    throw new Error(
      `Failed to read ${t} from any filesystem: ${r}`,
      { cause: e }
    );
  }
}
class Bo {
  constructor(t) {
    this.root = t;
  }
  async ensureNodeModules() {
    if (!this.fs || !this.path) {
      try {
        this.fs = await import("fs"), this.path = await import("path");
      } catch {
        this.fs = require("fs"), this.path = require("path");
      }
      this.root = this.path.resolve(this.root) + this.path.sep;
    }
  }
  async read(t) {
    if (await this.ensureNodeModules(), t = this.path.resolve(
      this.root,
      this.path.normalize(t.replace(/^\//, ""))
    ), !t.startsWith(this.root))
      throw new Error(
        `Refused to read a file outside of the root directory: ${t}`
      );
    return new Promise((e, r) => {
      const a = this.path.resolve(t), o = this.fs.createReadStream(a);
      o.on("error", (c) => {
        r(
          new Error(
            `Failed to read file at ${t}: ${c.message}`
          )
        );
      }), this.fs.stat(a, (c, l) => {
        c ? r(
          new Error(
            `Failed to read file at ${t}: ${c.message}`
          )
        ) : e(
          new Yt(
            No(o),
            t,
            {
              filesize: l.size
            }
          )
        );
      });
    });
  }
}
function No(n) {
  return new ReadableStream({
    start(e) {
      n.on("data", (r) => e.enqueue(r)), n.on("end", () => e.close());
    }
  });
}
class Ui extends Error {
  constructor(t, e) {
    super(t, {
      ...e,
      cause: {
        isReportableInCLI: !0
      }
    }), this.isReportableInCLI = !0, this.isReportableInCLI = !0;
  }
  static getReportableCause(t) {
    let e = 0;
    const r = 15, a = [t];
    for (; a.length > 0 && e < r; ) {
      const o = a.pop();
      if (o instanceof Error) {
        if (o.isReportableInCLI)
          return o;
        Array.isArray(o.cause) ? a.push(...o.cause) : a.push(o.cause), e++, e >= r && Hi.warn(
          "Recursion limit exceeded while checking if error is reportable"
        );
      }
    }
    return null;
  }
}
async function Mo({
  sourceString: n,
  blueprintMayReadAdjacentFiles: t
}) {
  if (!n)
    return;
  if (n.startsWith("http://") || n.startsWith("https://"))
    return await ji(n);
  let e = Ft.resolve(process.cwd(), n);
  if (!Tt.existsSync(e))
    throw new Error(`Blueprint file does not exist: ${e}`);
  const r = Tt.statSync(e);
  if (r.isDirectory() && (e = Ft.join(e, "blueprint.json")), !r.isFile() && r.isSymbolicLink())
    throw new Error(
      `Blueprint path is neither a file nor a directory: ${e}`
    );
  const a = Ft.extname(e);
  switch (a) {
    case ".zip":
      return $t.fromArrayBuffer(
        Tt.readFileSync(e)
      );
    case ".json": {
      const o = Tt.readFileSync(e, "utf-8");
      try {
        JSON.parse(o);
      } catch {
        throw new Error(
          `Blueprint file at ${e} is not a valid JSON file`
        );
      }
      const c = Ft.dirname(e), l = new Bo(c);
      return new Po([
        new Oo({
          "blueprint.json": o
        }),
        /**
         * Wrap the NodeJS filesystem to prevent access to local files
         * unless the user explicitly allowed it.
         */
        {
          read(u) {
            if (!t)
              throw new Ui(
                `Error: Blueprint contained tried to read a local file at path "${u}" (via a resource of type "bundled"). Playground restricts access to local resources by default as a security measure. 

You can allow this Blueprint to read files from the same parent directory by explicitly adding the --blueprint-may-read-adjacent-files option to your command.`
              );
            return l.read(u);
          }
        }
      ]);
    }
    default:
      throw new Error(
        `Unsupported blueprint file extension: ${a}. Only .zip and .json files are supported.`
      );
  }
}
async function Wo() {
  const n = Wi(process.argv.slice(2)).usage("Usage: wp-playground <command> [options]").positional("command", {
    describe: "Command to run",
    choices: ["server", "run-blueprint", "build-snapshot"],
    demandOption: !0
  }).option("outfile", {
    describe: "When building, write to this output file.",
    type: "string",
    default: "wordpress.zip"
  }).option("port", {
    describe: "Port to listen on when serving.",
    type: "number",
    default: 9400
  }).option("php", {
    describe: "PHP version to use.",
    type: "string",
    default: Mi,
    choices: Ni
  }).option("wp", {
    describe: "WordPress version to use.",
    type: "string",
    default: "latest"
  }).option("mount", {
    describe: "Mount a directory to the PHP runtime. You can provide --mount multiple times. Format: /host/path:/vfs/path",
    type: "array",
    string: !0
  }).option("mountBeforeInstall", {
    describe: "Mount a directory to the PHP runtime before installing WordPress. You can provide --mount-before-install multiple times. Format: /host/path:/vfs/path",
    type: "array",
    string: !0
  }).option("login", {
    describe: "Should log the user in",
    type: "boolean",
    default: !1
  }).option("blueprint", {
    describe: "Blueprint to execute.",
    type: "string"
  }).option("blueprintMayReadAdjacentFiles", {
    describe: 'Consent flag: Allow "bundled" resources in a local blueprint to read files in the same directory as the blueprint file.',
    type: "boolean",
    default: !1
  }).option("skipWordPressSetup", {
    describe: "Do not download, unzip, and install WordPress. Useful for mounting a pre-configured WordPress directory at /wordpress.",
    type: "boolean",
    default: !1
  }).option("skipSqliteSetup", {
    describe: "Skip the SQLite integration plugin setup to allow the WordPress site to use MySQL.",
    type: "boolean",
    default: !1
  }).option("quiet", {
    describe: "Do not output logs and progress messages.",
    type: "boolean",
    default: !1
  }).option("debug", {
    describe: "Print PHP error log content if an error occurs during Playground boot.",
    type: "boolean",
    default: !1
  }).option("autoMount", {
    describe: "Automatically mount the current working directory. You can mount a WordPress directory, a plugin directory, a theme directory, a wp-content directory, or any directory containing PHP and HTML files.",
    type: "boolean",
    default: !1
  }).option("followSymlinks", {
    describe: `Allow Playground to follow symlinks by automatically mounting symlinked directories and files encountered in mounted directories. 
Warning: Following symlinks will expose files outside mounted directories to Playground and could be a security risk.`,
    type: "boolean",
    default: !1
  }).showHelpOnFail(!1).check((a) => {
    if (a.wp !== void 0 && !Yi(a.wp))
      try {
        new URL(a.wp);
      } catch {
        throw new Error(
          'Unrecognized WordPress version. Please use "latest", a URL, or a numeric version such as "6.2", "6.0.1", "6.2-beta1", or "6.2-RC1"'
        );
      }
    return !0;
  });
  n.wrap(n.terminalWidth());
  const t = await n.argv, e = t._[0];
  ["run-blueprint", "server", "build-snapshot"].includes(e) || (n.showHelp(), process.exit(1));
  const r = {
    ...t,
    command: e,
    blueprint: await Mo({
      sourceString: t.blueprint,
      blueprintMayReadAdjacentFiles: t.blueprintMayReadAdjacentFiles
    })
  };
  try {
    return qi(r);
  } catch (a) {
    const o = Ui.getReportableCause(a);
    if (o)
      console.log(""), console.log(o.message), process.exit(1);
    else
      throw a;
  }
}
Wo();
//# sourceMappingURL=cli.js.map
